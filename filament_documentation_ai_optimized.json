{
  "documentation_info": {
    "title": "Filament PHP v3.x Complete Documentation",
    "description": "Complete documentation for Filament PHP framework version 3.x",
    "source_url": "https://filamentphp.com/docs/3.x/",
    "total_pages": 80,
    "total_sections": 8,
    "generated_date": "2025-06-19",
    "format_optimized_for": "AI consumption and analysis"
  },
  "quick_reference": {
    "sections_overview": [
      {
        "section": "panels",
        "page_count": 15,
        "description": "Main admin panel framework for building complete admin interfaces"
      },
      {
        "section": "tables",
        "page_count": 13,
        "description": "Interactive datatable builder for displaying and managing data"
      },
      {
        "section": "forms",
        "page_count": 10,
        "description": "Dynamic form builder with validation and field components"
      },
      {
        "section": "infolists",
        "page_count": 8,
        "description": "Read-only information display components for showing data"
      },
      {
        "section": "actions",
        "page_count": 10,
        "description": "Button and modal system for user interactions"
      },
      {
        "section": "notifications",
        "page_count": 7,
        "description": "Toast notifications and database notification system"
      },
      {
        "section": "widgets",
        "page_count": 5,
        "description": "Dashboard widgets including stats, charts, and tables"
      },
      {
        "section": "support",
        "page_count": 12,
        "description": "Core concepts, styling, assets, and framework fundamentals"
      }
    ],
    "key_concepts": [
      "Panel Builder - Main admin panel framework",
      "Table Builder - Interactive datatables for Livewire",
      "Form Builder - Dynamic form creation and validation",
      "Infolists - Read-only information displays",
      "Actions - Button and modal system",
      "Notifications - Toast and database notifications",
      "Widgets - Dashboard widgets and components",
      "Core Concepts - Fundamental framework concepts"
    ],
    "installation_urls": [
      {
        "section": "panels",
        "url": "https://filamentphp.com/docs/3.x/panels/installation"
      },
      {
        "section": "tables",
        "url": "https://filamentphp.com/docs/3.x/tables/installation"
      },
      {
        "section": "forms",
        "url": "https://filamentphp.com/docs/3.x/forms/installation"
      },
      {
        "section": "infolists",
        "url": "https://filamentphp.com/docs/3.x/infolists/installation"
      },
      {
        "section": "actions",
        "url": "https://filamentphp.com/docs/3.x/actions/installation"
      },
      {
        "section": "notifications",
        "url": "https://filamentphp.com/docs/3.x/notifications/installation"
      },
      {
        "section": "widgets",
        "url": "https://filamentphp.com/docs/3.x/widgets/installation"
      }
    ],
    "getting_started_urls": [
      {
        "section": "panels",
        "url": "https://filamentphp.com/docs/3.x/panels/getting-started"
      },
      {
        "section": "tables",
        "url": "https://filamentphp.com/docs/3.x/tables/getting-started"
      },
      {
        "section": "forms",
        "url": "https://filamentphp.com/docs/3.x/forms/getting-started"
      },
      {
        "section": "infolists",
        "url": "https://filamentphp.com/docs/3.x/infolists/getting-started"
      }
    ]
  },
  "complete_documentation": {
    "panels": {
      "section_info": {
        "name": "panels",
        "page_count": 15,
        "description": "Main admin panel framework for building complete admin interfaces"
      },
      "pages": {
        "installation": {
          "metadata": {
            "title": "Installation",
            "url": "https://filamentphp.com/docs/3.x/panels/installation",
            "section": "panels",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "getting-started": {
          "metadata": {
            "title": "Getting Started",
            "url": "https://filamentphp.com/docs/3.x/panels/getting-started",
            "section": "panels",
            "word_count": 3343,
            "character_count": 28360
          },
          "content": {
            "full_text": "\n# Getting started - Panels - Filament\n\nPanels\n\n# Getting started\n\n## #Overview\n\nPanels are the top-level container in Filament, allowing you to build feature-rich admin panels that include pages, resources, forms, tables, notifications, actions, infolists, and widgets. All Panels include a default dashboard that can include widgets with statistics, charts, tables, and more.\n\n## #Prerequisites\n\nBefore using Filament, you should be familiar with Laravel. Filament builds upon many core Laravel concepts, especially database migrations and Eloquent ORM. If you’re new to Laravel or need a refresher, we highly recommend completing the Laravel Bootcamp, which covers the fundamentals of building Laravel apps.\n\n## #The demo project\n\nThis guide covers building a simple patient management system for a veterinary practice using Filament. It will support adding new patients (cats, dogs, or rabbits), assigning them to an owner, and recording which treatments they received. The system will have a dashboard with statistics about the types of patients and a chart showing the number of treatments administered over the past year.\n\n## #Setting up the database and models\n\nThis project needs three models and migrations: Owner, Patient, and Treatment. Use the following artisan commands to create these:\n\n`Owner``Patient``Treatment````\nphp artisan make:model Owner -m\nphp artisan make:model Patient -m\nphp artisan make:model Treatment -m\n```\n\n### #Defining migrations\n\nUse the following basic schemas for your database migrations:\n\n```\n// create_owners_table\nSchema::create('owners', function (Blueprint $table) {\n    $table->id();\n    $table->string('email');\n    $table->string('name');\n    $table->string('phone');\n    $table->timestamps();\n});\n\n// create_patients_table\nSchema::create('patients', function (Blueprint $table) {\n    $table->id();\n    $table->date('date_of_birth');\n    $table->string('name');\n    $table->foreignId('owner_id')->constrained('owners')->cascadeOnDelete();\n    $table->string('type');\n    $table->timestamps();\n});\n\n// create_treatments_table\nSchema::create('treatments', function (Blueprint $table) {\n    $table->id();\n    $table->string('description');\n    $table->text('notes')->nullable();\n    $table->foreignId('patient_id')->constrained('patients')->cascadeOnDelete();\n    $table->unsignedInteger('price')->nullable();\n    $table->timestamps();\n});\n```\n\nRun the migrations using php artisan migrate.\n\n`php artisan migrate`### #Unguarding all models\n\nFor brevity in this guide, we will disable Laravel’s mass assignment protection. Filament only saves valid data to models so the models can be unguarded safely. To unguard all Laravel models at once, add Model::unguard() to the boot() method of app/Providers/AppServiceProvider.php:\n\n`Model::unguard()``boot()``app/Providers/AppServiceProvider.php````\nuse Illuminate\\Database\\Eloquent\\Model;\n\npublic function boot(): void\n{\n    Model::unguard();\n}\n```\n\n### #Setting up relationships between models\n\nLet’s set up relationships between the models. For our system, pet owners can own multiple pets (patients), and patients can have many treatments:\n\n```\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\Relations\\BelongsTo;\nuse Illuminate\\Database\\Eloquent\\Relations\\HasMany;\n\nclass Owner extends Model\n{\n    public function patients(): HasMany\n    {\n        return $this->hasMany(Patient::class);\n    }\n}\n\nclass Patient extends Model\n{\n    public function owner(): BelongsTo\n    {\n        return $this->belongsTo(Owner::class);\n    }\n\n    public function treatments(): HasMany\n    {\n        return $this->hasMany(Treatment::class);\n    }\n}\n\nclass Treatment extends Model\n{\n    public function patient(): BelongsTo\n    {\n        return $this->belongsTo(Patient::class);\n    }\n}\n```\n\n## #Introducing resources\n\nIn Filament, resources are static classes used to build CRUD interfaces for your Eloquent models. They describe how administrators can interact with data from your panel using tables and forms.\n\nSince patients (pets) are the core entity in this system, let’s start by creating a patient resource that enables us to build pages for creating, viewing, updating, and deleting patients.\n\nUse the following artisan command to create a new Filament resource for the Patient model:\n\n`Patient````\nphp artisan make:filament-resource Patient\n```\n\nThis will create several files in the app/Filament/Resources directory:\n\n`app/Filament/Resources````\n.\n+-- PatientResource.php\n+-- PatientResource\n|   +-- Pages\n|   |   +-- CreatePatient.php\n|   |   +-- EditPatient.php\n|   |   +-- ListPatients.php\n```\n\nVisit /admin/patients in your browser and observe a new link called “Patients” in the navigation. Clicking the link will display an empty table. Let’s add a form to create new patients.\n\n`/admin/patients`### #Setting up the resource form\n\nIf you open the PatientResource.php file, there’s a form() method with an empty schema([...]) array. Adding form fields to this schema will build a form that can be used to create and edit new patients.\n\n`PatientResource.php``form()``schema([...])`#### #”Name” text input\n\nFilament bundles a large selection of form fields. Let’s start with a simple text input field:\n\n```\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic static function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('name'),\n        ]);\n}\n```\n\nVisit /admin/patients/create (or click the “New Patient” button) and observe that a form field for the patient’s name was added.\n\n`/admin/patients/create`Since this field is required in the database and has a maximum length of 255 characters, let’s add two validation rules to the name field:\n\n```\nuse Filament\\Forms;\n\nForms\\Components\\TextInput::make('name')\n    ->required()\n    ->maxLength(255)\n```\n\nAttempt to submit the form to create a new patient without a name and observe that a message is displayed informing you that the name field is required.\n\n#### #”Type” select\n\nLet’s add a second field for the type of patient: a choice between a cat, dog, or rabbit. Since there’s a fixed set of options to choose from, a select field works well:\n\n```\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic static function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('name')\n                ->required()\n                ->maxLength(255),\n            Forms\\Components\\Select::make('type')\n                ->options([\n                    'cat' => 'Cat',\n                    'dog' => 'Dog',\n                    'rabbit' => 'Rabbit',\n                ]),\n        ]);\n}\n```\n\nThe options() method of the Select field accepts an array of options for the user to choose from. The array keys should match the database, and the values are used as the form labels. Feel free to add as many animals to this array as you wish.\n\n`options()`Since this field is also required in the database, let’s add the required() validation rule:\n\n`required()````\nuse Filament\\Forms;\n\nForms\\Components\\Select::make('type')\n    ->options([\n        'cat' => 'Cat',\n        'dog' => 'Dog',\n        'rabbit' => 'Rabbit',\n    ])\n    ->required()\n```\n\n#### #“Date of birth” picker\n\nLet’s add a date picker field for the date_of_birth column along with the validation (the date of birth is required and the date should be no later than the current day).\n\n`date_of_birth````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic static function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('name')\n                ->required()\n                ->maxLength(255),\n            Forms\\Components\\Select::make('type')\n                ->options([\n                    'cat' => 'Cat',\n                    'dog' => 'Dog',\n                    'rabbit' => 'Rabbit',\n                ])\n                ->required(),\n            Forms\\Components\\DatePicker::make('date_of_birth')\n                ->required()\n                ->maxDate(now()),\n        ]);\n}\n```\n\n#### #”Owner” select\n\nWe should also add an owner when creating a new patient. Since we added a BelongsTo relationship in the Patient model (associating it to the related Owner model), we can use the relationship() method from the select field to load a list of owners to choose from:\n\n`BelongsTo``Owner``relationship()````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic static function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('name')\n                ->required()\n                ->maxLength(255),\n            Forms\\Components\\Select::make('type')\n                ->options([\n                    'cat' => 'Cat',\n                    'dog' => 'Dog',\n                    'rabbit' => 'Rabbit',\n                ])\n                ->required(),\n            Forms\\Components\\DatePicker::make('date_of_birth')\n                ->required()\n                ->maxDate(now()),\n            Forms\\Components\\Select::make('owner_id')\n                ->relationship('owner', 'name')\n                ->required(),\n        ]);\n}\n```\n\nThe first argument of the relationship() method is the name of the function that defines the relationship in the model (used by Filament to load the select options) — in this case, owner. The second argument is the column name to use from the related table — in this case, name.\n\n`relationship()``owner``name`Let’s also make the owner field required, searchable(), and preload() the first 50 owners into the searchable list (in case the list is long):\n\n`owner``searchable()``preload()````\nuse Filament\\Forms;\n\nForms\\Components\\Select::make('owner_id')\n    ->relationship('owner', 'name')\n    ->searchable()\n    ->preload()\n    ->required()\n```\n\n#### #Creating new owners without leaving the page\n\nCurrently, there are no owners in our database. Instead of creating a separate Filament owner resource, let’s give users an easier way to add owners via a modal form (accessible as a + button next to the select). Use the createOptionForm() method to embed a modal form with TextInput fields for the owner’s name, email address, and phone number:\n\n`+``createOptionForm()``TextInput````\nuse Filament\\Forms;\n\nForms\\Components\\Select::make('owner_id')\n    ->relationship('owner', 'name')\n    ->searchable()\n    ->preload()\n    ->createOptionForm([\n        Forms\\Components\\TextInput::make('name')\n            ->required()\n            ->maxLength(255),\n        Forms\\Components\\TextInput::make('email')\n            ->label('Email address')\n            ->email()\n            ->required()\n            ->maxLength(255),\n        Forms\\Components\\TextInput::make('phone')\n            ->label('Phone number')\n            ->tel()\n            ->required(),\n    ])\n    ->required()\n```\n\nA few new methods on the TextInput were used in this example:\n\n- label() overrides the auto-generated label for each field. In this case, we want the Email label to be Email address, and the Phone label to be Phone number.\n- email() ensures that only valid email addresses can be input into the field. It also changes the keyboard layout on mobile devices.\n- tel() ensures that only valid phone numbers can be input into the field. It also changes the keyboard layout on mobile devices.\n\n`label()``Email``Email address``Phone``Phone number``email()``tel()`The form should be working now! Try creating a new patient and their owner. Once created, you will be redirected to the Edit page, where you can update their details.\n\n### #Setting up the patients table\n\nVisit the /admin/patients page again. If you have created a patient, there should be one empty row in the table — with an edit button. Let’s add some columns to the table, so we can view the actual patient data.\n\n`/admin/patients`Open the PatientResource.php file. You should see a table() method with an empty columns([...]) array. You can use this array to add columns to the patients table.\n\n`PatientResource.php``table()``columns([...])``patients`#### #Adding text columns\n\nFilament bundles a large selection of table columns. Let’s use a simple text column for all the fields in the patients table:\n\n`patients````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('name'),\n            Tables\\Columns\\TextColumn::make('type'),\n            Tables\\Columns\\TextColumn::make('date_of_birth'),\n            Tables\\Columns\\TextColumn::make('owner.name'),\n        ]);\n}\n```\n\n> Filament uses dot notation to eager-load related data. We used owner.name in our table to display a list of owner names instead of less informational ID numbers. You could also add columns for the owner’s email address and phone number.\n\nFilament uses dot notation to eager-load related data. We used owner.name in our table to display a list of owner names instead of less informational ID numbers. You could also add columns for the owner’s email address and phone number.\n\n`owner.name`##### #Making columns searchable\n\nThe ability to search for patients directly in the table would be helpful as a veterinary practice grows. You can make columns searchable by chaining the searchable() method to the column. Let’s make the patient’s name and owner’s name searchable.\n\n`searchable()````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('name')\n                ->searchable(),\n            Tables\\Columns\\TextColumn::make('type'),\n            Tables\\Columns\\TextColumn::make('date_of_birth'),\n            Tables\\Columns\\TextColumn::make('owner.name')\n                ->searchable(),\n        ]);\n}\n```\n\nReload the page and observe a new search input field on the table that filters the table entries using the search criteria.\n\n##### #Making the columns sortable\n\nTo make the patients table sortable by age, add the sortable() method to the date_of_birth column:\n\n`patients``sortable()``date_of_birth````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('name')\n                ->searchable(),\n            Tables\\Columns\\TextColumn::make('type'),\n            Tables\\Columns\\TextColumn::make('date_of_birth')\n                ->sortable(),\n            Tables\\Columns\\TextColumn::make('owner.name')\n                ->searchable(),\n        ]);\n}\n```\n\nThis will add a sort icon button to the column header. Clicking it will sort the table by date of birth.\n\n#### #Filtering the table by patient type\n\nAlthough you can make the type field searchable, making it filterable is a much better user experience.\n\n`type`Filament tables can have filters, which are components that reduce the number of records in a table by adding a scope to the Eloquent query. Filters can even contain custom form components, making them a potent tool for building interfaces.\n\nFilament includes a prebuilt SelectFilter that you can add to the table’s filters():\n\n`SelectFilter``filters()````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->filters([\n            Tables\\Filters\\SelectFilter::make('type')\n                ->options([\n                    'cat' => 'Cat',\n                    'dog' => 'Dog',\n                    'rabbit' => 'Rabbit',\n                ]),\n        ]);\n}\n```\n\nReload the page, and you should see a new filter icon in the top right corner (next to the search form). The filter opens a select menu with a list of patient types. Try filtering your patients by type.\n\n## #Introducing relation managers\n\nCurrently, patients can be associated with their owners in our system. But what happens if we want a third level? Patients come to the vet practice for treatment, and the system should be able to record these treatments and associate them with a patient.\n\nOne option is to create a new TreatmentResource with a select field to associate treatments with a patient. However, managing treatments separately from the rest of the patient information is cumbersome for the user. Filament uses “relation managers” to solve this problem.\n\n`TreatmentResource`Relation managers are tables that display related records for an existing resource on the edit screen for the parent resource. For example, in our project, you could view and manage a patient’s treatments directly below their edit form.\n\n> You can also use Filament “actions” to open a modal form to create, edit, and delete treatments directly from the patient’s table.\n\nYou can also use Filament “actions” to open a modal form to create, edit, and delete treatments directly from the patient’s table.\n\nUse the make:filament-relation-manager artisan command to quickly create a relation manager, connecting the patient resource to the related treatments:\n\n`make:filament-relation-manager````\nphp artisan make:filament-relation-manager PatientResource treatments description\n```\n\n- PatientResource is the name of the resource class for the owner model. Since treatments belong to patients, the treatments should be displayed on the Edit Patient page.\n- treatments is the name of the relationship in the Patient model we created earlier.\n- description is the column to display from the treatments table.\n\n`PatientResource``treatments``description`This will create a PatientResource/RelationManagers/TreatmentsRelationManager.php file. You must register the new relation manager in the getRelations() method of the PatientResource:\n\n`PatientResource/RelationManagers/TreatmentsRelationManager.php``getRelations()``PatientResource````\nuse App\\Filament\\Resources\\PatientResource\\RelationManagers;\n\npublic static function getRelations(): array\n{\n    return [\n        RelationManagers\\TreatmentsRelationManager::class,\n    ];\n}\n```\n\nThe TreatmentsRelationManager.php file contains a class that is prepopulated with a form and table using the parameters from the make:filament-relation-manager artisan command. You can customize the fields and columns in the relation manager similar to how you would in a resource:\n\n`TreatmentsRelationManager.php``make:filament-relation-manager````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('description')\n                ->required()\n                ->maxLength(255),\n        ]);\n}\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('description'),\n        ]);\n}\n```\n\nVisit the Edit page for one of your patients. You should already be able to create, edit, delete, and list treatments for that patient.\n\n### #Setting up the treatment form\n\nBy default, text fields only span half the width of the form. Since the description field might contain a lot of information, add a columnSpan('full') method to make the field span the entire width of the modal form:\n\n`description``columnSpan('full')````\nuse Filament\\Forms;\n\nForms\\Components\\TextInput::make('description')\n    ->required()\n    ->maxLength(255)\n    ->columnSpan('full')\n```\n\nLet’s add the notes field, which can be used to add more details about the treatment. We can use a textarea field with a columnSpan('full'):\n\n`notes``columnSpan('full')````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('description')\n                ->required()\n                ->maxLength(255)\n                ->columnSpan('full'),\n            Forms\\Components\\Textarea::make('notes')\n                ->maxLength(65535)\n                ->columnSpan('full'),\n        ]);\n}\n```\n\n#### #Configuring the price field\n\n`price`Let’s add a price field for the treatment. We can use a text input with some customizations to make it suitable for currency input. It should be numeric(), which adds validation and changes the keyboard layout on mobile devices. Add your preferred currency prefix using the prefix() method; for example, prefix('€') will add a € before the input without impacting the saved output value:\n\n`price``numeric()``prefix()``prefix('€')``€````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('description')\n                ->required()\n                ->maxLength(255)\n                ->columnSpan('full'),\n            Forms\\Components\\Textarea::make('notes')\n                ->maxLength(65535)\n                ->columnSpan('full'),\n            Forms\\Components\\TextInput::make('price')\n                ->numeric()\n                ->prefix('€')\n                ->maxValue(42949672.95),\n        ]);\n}\n```\n\n##### #Casting the price to an integer\n\nFilament stores currency values as integers (not floats) to avoid rounding and precision issues — a widely-accepted approach in the Laravel community. However, this requires creating a cast in Laravel that transforms the integer into a float when retrieved and back to an integer when stored in the database. Use the following artisan command to create the cast:\n\n```\nphp artisan make:cast MoneyCast\n```\n\nInside the new app/Casts/MoneyCast.php file, update the get() and set() methods:\n\n`app/Casts/MoneyCast.php``get()``set()````\npublic function get($model, string $key, $value, array $attributes): float\n{\n    // Transform the integer stored in the database into a float.\n    return round(floatval($value) / 100, precision: 2);\n}\n\npublic function set($model, string $key, $value, array $attributes): float\n{\n    // Transform the float into an integer for storage.\n    return round(floatval($value) * 100);\n}\n```\n\nNow, add the MoneyCast to the price attribute in the Treatment model:\n\n`MoneyCast``price``Treatment````\nuse App\\Casts\\MoneyCast;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Treatment extends Model\n{\n    protected $casts = [\n        'price' => MoneyCast::class,\n    ];\n\n    // ...\n}\n```\n\n### #Setting up the treatments table\n\nWhen the relation manager was generated previously, the description text column was automatically added. Let’s also add a sortable() column for the price with a currency prefix. Use the Filament money() method to format the price column as money — in this case for EUR (€):\n\n`description``sortable()``price``money()``price``EUR``€````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('description'),\n            Tables\\Columns\\TextColumn::make('price')\n                ->money('EUR')\n                ->sortable(),\n        ]);\n}\n```\n\nLet’s also add a column to indicate when the treatment was administered using the default created_at timestamp. Use the dateTime() method to display the date-time in a human-readable format:\n\n`created_at``dateTime()````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('description'),\n            Tables\\Columns\\TextColumn::make('price')\n                ->money('EUR')\n                ->sortable(),\n            Tables\\Columns\\TextColumn::make('created_at')\n                ->dateTime(),\n        ]);\n}\n```\n\n> You can pass any valid PHP date formatting string to the dateTime() method (e.g. dateTime('m-d-Y h:i A')).\n\nYou can pass any valid PHP date formatting string to the dateTime() method (e.g. dateTime('m-d-Y h:i A')).\n\n`dateTime()``dateTime('m-d-Y h:i A')`## #Introducing widgets\n\nFilament widgets are components that display information on your dashboard, especially statistics. Widgets are typically added to the default Dashboard of the panel, but you can add them to any page, including resource pages. Filament includes built-in widgets like the stats widget, to render important statistics in a simple overview; chart widget, which can render an interactive chart; and table widget, which allows you to easily embed the Table Builder.\n\nLet’s add a stats widget to our default dashboard page that includes a stat for each type of patient and a chart to visualize treatments administered over time.\n\n### #Creating a stats widget\n\nCreate a stats widget to render patient types using the following artisan command:\n\n```\nphp artisan make:filament-widget PatientTypeOverview --stats-overview\n```\n\nWhen prompted, do not specify a resource, and select “admin” for the location.\n\nThis will create a new app/Filament/Widgets/PatientTypeOverview.php file. Open it, and return Stat instances from the getStats() method:\n\n`app/Filament/Widgets/PatientTypeOverview.php``Stat``getStats()````\n<?php\n\nnamespace App\\Filament\\Widgets;\n\nuse App\\Models\\Patient;\nuse Filament\\Widgets\\StatsOverviewWidget as BaseWidget;\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nclass PatientTypeOverview extends BaseWidget\n{\n    protected function getStats(): array\n    {\n        return [\n            Stat::make('Cats', Patient::query()->where('type', 'cat')->count()),\n            Stat::make('Dogs', Patient::query()->where('type', 'dog')->count()),\n            Stat::make('Rabbits', Patient::query()->where('type', 'rabbit')->count()),\n        ];\n    }\n}\n```\n\nOpen your dashboard, and you should see your new widget displayed. Each stat should show the total number of patients for the specified type.\n\n### #Creating a chart widget\n\nLet’s add a chart to the dashboard to visualize the number of treatments administered over time. Use the following artisan command to create a new chart widget:\n\n```\nphp artisan make:filament-widget TreatmentsChart --chart\n```\n\nWhen prompted, do not specify a resource, select “admin” for the location, and choose “line chart” as the chart type.\n\nOpen app/Filament/Widgets/TreatmentsChart.php and set the $heading of the chart to “Treatments”.\n\n`app/Filament/Widgets/TreatmentsChart.php``$heading`The getData() method returns an array of datasets and labels. Each dataset is a labeled array of points to plot on the chart, and each label is a string. This structure is identical to the Chart.js library, which Filament uses to render charts.\n\n`getData()`To populate chart data from an Eloquent model, Filament recommends that you install the flowframe/laravel-trend package:\n\n```\ncomposer require flowframe/laravel-trend\n```\n\nUpdate the getData() to display the number of treatments per month for the past year:\n\n`getData()````\nuse App\\Models\\Treatment;\nuse Flowframe\\Trend\\Trend;\nuse Flowframe\\Trend\\TrendValue;\n\nprotected function getData(): array\n{\n    $data = Trend::model(Treatment::class)\n        ->between(\n            start: now()->subYear(),\n            end: now(),\n        )\n        ->perMonth()\n        ->count();\n\n    return [\n        'datasets' => [\n            [\n                'label' => 'Treatments',\n                'data' => $data->map(fn (TrendValue $value) => $value->aggregate),\n            ],\n        ],\n        'labels' => $data->map(fn (TrendValue $value) => $value->date),\n    ];\n}\n```\n\nNow, check out your new chart widget in the dashboard!\n\n> You can customize your dashboard page to change the grid and how many widgets are displayed.\n\nYou can customize your dashboard page to change the grid and how many widgets are displayed.\n\n## #Next steps with the Panel Builder\n\nCongratulations! Now that you know how to build a basic Filament application, here are some suggestions for further learning:\n\n- Create custom pages in the panel that don’t belong to resources.\n- Learn more about adding action buttons to pages and resources, with modals to collect user input or for confirmation.\n- Explore the available fields to collect input from your users.\n- Check out the list of form layout components.\n- Discover how to build complex, responsive table layouts without touching CSS.\n- Add summaries to your tables\n- Write automated tests for your panel using our suite of helper methods.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Panels are the top-level container in Filament, allowing you to build feature-rich admin panels that include pages, resources, forms, tables, notifications, actions, infolists, and widgets. All Panels include a default dashboard that can include widgets with statistics, charts, tables, and more.",
                "level": 3
              },
              {
                "title": "## #Prerequisites",
                "content": "Before using Filament, you should be familiar with Laravel. Filament builds upon many core Laravel concepts, especially database migrations and Eloquent ORM. If you’re new to Laravel or need a refresher, we highly recommend completing the Laravel Bootcamp, which covers the fundamentals of building Laravel apps.",
                "level": 3
              },
              {
                "title": "## #The demo project",
                "content": "This guide covers building a simple patient management system for a veterinary practice using Filament. It will support adding new patients (cats, dogs, or rabbits), assigning them to an owner, and recording which treatments they received. The system will have a dashboard with statistics about the types of patients and a chart showing the number of treatments administered over the past year.",
                "level": 3
              },
              {
                "title": "## #Setting up the database and models",
                "content": "This project needs three models and migrations: Owner, Patient, and Treatment. Use the following artisan commands to create these:\n\n`Owner``Patient``Treatment````\nphp artisan make:model Owner -m\nphp artisan make:model Patient -m\nphp artisan make:model Treatment -m\n```",
                "level": 3
              },
              {
                "title": "### #Defining migrations",
                "content": "Use the following basic schemas for your database migrations:\n\n```\n// create_owners_table\nSchema::create('owners', function (Blueprint $table) {\n    $table->id();\n    $table->string('email');\n    $table->string('name');\n    $table->string('phone');\n    $table->timestamps();\n});\n\n// create_patients_table\nSchema::create('patients', function (Blueprint $table) {\n    $table->id();\n    $table->date('date_of_birth');\n    $table->string('name');\n    $table->foreignId('owner_id')->constrained('owners')->cascadeOnDelete();\n    $table->string('type');\n    $table->timestamps();\n});\n\n// create_treatments_table\nSchema::create('treatments', function (Blueprint $table) {\n    $table->id();\n    $table->string('description');\n    $table->text('notes')->nullable();\n    $table->foreignId('patient_id')->constrained('patients')->cascadeOnDelete();\n    $table->unsignedInteger('price')->nullable();\n    $table->timestamps();\n});\n```\n\nRun the migrations using php artisan migrate.\n\n`php artisan migrate`### #Unguarding all models\n\nFor brevity in this guide, we will disable Laravel’s mass assignment protection. Filament only saves valid data to models so the models can be unguarded safely. To unguard all Laravel models at once, add Model::unguard() to the boot() method of app/Providers/AppServiceProvider.php:\n\n`Model::unguard()``boot()``app/Providers/AppServiceProvider.php````\nuse Illuminate\\Database\\Eloquent\\Model;\n\npublic function boot(): void\n{\n    Model::unguard();\n}\n```",
                "level": 4
              },
              {
                "title": "### #Setting up relationships between models",
                "content": "Let’s set up relationships between the models. For our system, pet owners can own multiple pets (patients), and patients can have many treatments:\n\n```\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\Relations\\BelongsTo;\nuse Illuminate\\Database\\Eloquent\\Relations\\HasMany;\n\nclass Owner extends Model\n{\n    public function patients(): HasMany\n    {\n        return $this->hasMany(Patient::class);\n    }\n}\n\nclass Patient extends Model\n{\n    public function owner(): BelongsTo\n    {\n        return $this->belongsTo(Owner::class);\n    }\n\n    public function treatments(): HasMany\n    {\n        return $this->hasMany(Treatment::class);\n    }\n}\n\nclass Treatment extends Model\n{\n    public function patient(): BelongsTo\n    {\n        return $this->belongsTo(Patient::class);\n    }\n}\n```",
                "level": 4
              },
              {
                "title": "## #Introducing resources",
                "content": "In Filament, resources are static classes used to build CRUD interfaces for your Eloquent models. They describe how administrators can interact with data from your panel using tables and forms.\n\nSince patients (pets) are the core entity in this system, let’s start by creating a patient resource that enables us to build pages for creating, viewing, updating, and deleting patients.\n\nUse the following artisan command to create a new Filament resource for the Patient model:\n\n`Patient````\nphp artisan make:filament-resource Patient\n```\n\nThis will create several files in the app/Filament/Resources directory:\n\n`app/Filament/Resources````\n.\n+-- PatientResource.php\n+-- PatientResource\n|   +-- Pages\n|   |   +-- CreatePatient.php\n|   |   +-- EditPatient.php\n|   |   +-- ListPatients.php\n```\n\nVisit /admin/patients in your browser and observe a new link called “Patients” in the navigation. Clicking the link will display an empty table. Let’s add a form to create new patients.\n\n`/admin/patients`### #Setting up the resource form\n\nIf you open the PatientResource.php file, there’s a form() method with an empty schema([...]) array. Adding form fields to this schema will build a form that can be used to create and edit new patients.\n\n`PatientResource.php``form()``schema([...])`#### #”Name” text input\n\nFilament bundles a large selection of form fields. Let’s start with a simple text input field:\n\n```\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic static function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('name'),\n        ]);\n}\n```\n\nVisit /admin/patients/create (or click the “New Patient” button) and observe that a form field for the patient’s name was added.\n\n`/admin/patients/create`Since this field is required in the database and has a maximum length of 255 characters, let’s add two validation rules to the name field:\n\n```\nuse Filament\\Forms;\n\nForms\\Components\\TextInput::make('name')\n    ->required()\n    ->maxLength(255)\n```\n\nAttempt to submit the form to create a new patient without a name and observe that a message is displayed informing you that the name field is required.",
                "level": 3
              },
              {
                "title": "#### #”Type” select",
                "content": "Let’s add a second field for the type of patient: a choice between a cat, dog, or rabbit. Since there’s a fixed set of options to choose from, a select field works well:\n\n```\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic static function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('name')\n                ->required()\n                ->maxLength(255),\n            Forms\\Components\\Select::make('type')\n                ->options([\n                    'cat' => 'Cat',\n                    'dog' => 'Dog',\n                    'rabbit' => 'Rabbit',\n                ]),\n        ]);\n}\n```\n\nThe options() method of the Select field accepts an array of options for the user to choose from. The array keys should match the database, and the values are used as the form labels. Feel free to add as many animals to this array as you wish.\n\n`options()`Since this field is also required in the database, let’s add the required() validation rule:\n\n`required()````\nuse Filament\\Forms;\n\nForms\\Components\\Select::make('type')\n    ->options([\n        'cat' => 'Cat',\n        'dog' => 'Dog',\n        'rabbit' => 'Rabbit',\n    ])\n    ->required()\n```",
                "level": 5
              },
              {
                "title": "#### #“Date of birth” picker",
                "content": "Let’s add a date picker field for the date_of_birth column along with the validation (the date of birth is required and the date should be no later than the current day).\n\n`date_of_birth````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic static function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('name')\n                ->required()\n                ->maxLength(255),\n            Forms\\Components\\Select::make('type')\n                ->options([\n                    'cat' => 'Cat',\n                    'dog' => 'Dog',\n                    'rabbit' => 'Rabbit',\n                ])\n                ->required(),\n            Forms\\Components\\DatePicker::make('date_of_birth')\n                ->required()\n                ->maxDate(now()),\n        ]);\n}\n```",
                "level": 5
              },
              {
                "title": "#### #”Owner” select",
                "content": "We should also add an owner when creating a new patient. Since we added a BelongsTo relationship in the Patient model (associating it to the related Owner model), we can use the relationship() method from the select field to load a list of owners to choose from:\n\n`BelongsTo``Owner``relationship()````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic static function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('name')\n                ->required()\n                ->maxLength(255),\n            Forms\\Components\\Select::make('type')\n                ->options([\n                    'cat' => 'Cat',\n                    'dog' => 'Dog',\n                    'rabbit' => 'Rabbit',\n                ])\n                ->required(),\n            Forms\\Components\\DatePicker::make('date_of_birth')\n                ->required()\n                ->maxDate(now()),\n            Forms\\Components\\Select::make('owner_id')\n                ->relationship('owner', 'name')\n                ->required(),\n        ]);\n}\n```\n\nThe first argument of the relationship() method is the name of the function that defines the relationship in the model (used by Filament to load the select options) — in this case, owner. The second argument is the column name to use from the related table — in this case, name.\n\n`relationship()``owner``name`Let’s also make the owner field required, searchable(), and preload() the first 50 owners into the searchable list (in case the list is long):\n\n`owner``searchable()``preload()````\nuse Filament\\Forms;\n\nForms\\Components\\Select::make('owner_id')\n    ->relationship('owner', 'name')\n    ->searchable()\n    ->preload()\n    ->required()\n```",
                "level": 5
              },
              {
                "title": "#### #Creating new owners without leaving the page",
                "content": "Currently, there are no owners in our database. Instead of creating a separate Filament owner resource, let’s give users an easier way to add owners via a modal form (accessible as a + button next to the select). Use the createOptionForm() method to embed a modal form with TextInput fields for the owner’s name, email address, and phone number:\n\n`+``createOptionForm()``TextInput````\nuse Filament\\Forms;\n\nForms\\Components\\Select::make('owner_id')\n    ->relationship('owner', 'name')\n    ->searchable()\n    ->preload()\n    ->createOptionForm([\n        Forms\\Components\\TextInput::make('name')\n            ->required()\n            ->maxLength(255),\n        Forms\\Components\\TextInput::make('email')\n            ->label('Email address')\n            ->email()\n            ->required()\n            ->maxLength(255),\n        Forms\\Components\\TextInput::make('phone')\n            ->label('Phone number')\n            ->tel()\n            ->required(),\n    ])\n    ->required()\n```\n\nA few new methods on the TextInput were used in this example:\n\n- label() overrides the auto-generated label for each field. In this case, we want the Email label to be Email address, and the Phone label to be Phone number.\n- email() ensures that only valid email addresses can be input into the field. It also changes the keyboard layout on mobile devices.\n- tel() ensures that only valid phone numbers can be input into the field. It also changes the keyboard layout on mobile devices.\n\n`label()``Email``Email address``Phone``Phone number``email()``tel()`The form should be working now! Try creating a new patient and their owner. Once created, you will be redirected to the Edit page, where you can update their details.",
                "level": 5
              },
              {
                "title": "### #Setting up the patients table",
                "content": "Visit the /admin/patients page again. If you have created a patient, there should be one empty row in the table — with an edit button. Let’s add some columns to the table, so we can view the actual patient data.\n\n`/admin/patients`Open the PatientResource.php file. You should see a table() method with an empty columns([...]) array. You can use this array to add columns to the patients table.\n\n`PatientResource.php``table()``columns([...])``patients`#### #Adding text columns\n\nFilament bundles a large selection of table columns. Let’s use a simple text column for all the fields in the patients table:\n\n`patients````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('name'),\n            Tables\\Columns\\TextColumn::make('type'),\n            Tables\\Columns\\TextColumn::make('date_of_birth'),\n            Tables\\Columns\\TextColumn::make('owner.name'),\n        ]);\n}\n```\n\n> Filament uses dot notation to eager-load related data. We used owner.name in our table to display a list of owner names instead of less informational ID numbers. You could also add columns for the owner’s email address and phone number.\n\nFilament uses dot notation to eager-load related data. We used owner.name in our table to display a list of owner names instead of less informational ID numbers. You could also add columns for the owner’s email address and phone number.\n\n`owner.name`##### #Making columns searchable\n\nThe ability to search for patients directly in the table would be helpful as a veterinary practice grows. You can make columns searchable by chaining the searchable() method to the column. Let’s make the patient’s name and owner’s name searchable.\n\n`searchable()````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('name')\n                ->searchable(),\n            Tables\\Columns\\TextColumn::make('type'),\n            Tables\\Columns\\TextColumn::make('date_of_birth'),\n            Tables\\Columns\\TextColumn::make('owner.name')\n                ->searchable(),\n        ]);\n}\n```\n\nReload the page and observe a new search input field on the table that filters the table entries using the search criteria.",
                "level": 4
              },
              {
                "title": "##### #Making the columns sortable",
                "content": "To make the patients table sortable by age, add the sortable() method to the date_of_birth column:\n\n`patients``sortable()``date_of_birth````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('name')\n                ->searchable(),\n            Tables\\Columns\\TextColumn::make('type'),\n            Tables\\Columns\\TextColumn::make('date_of_birth')\n                ->sortable(),\n            Tables\\Columns\\TextColumn::make('owner.name')\n                ->searchable(),\n        ]);\n}\n```\n\nThis will add a sort icon button to the column header. Clicking it will sort the table by date of birth.",
                "level": 6
              },
              {
                "title": "#### #Filtering the table by patient type",
                "content": "Although you can make the type field searchable, making it filterable is a much better user experience.\n\n`type`Filament tables can have filters, which are components that reduce the number of records in a table by adding a scope to the Eloquent query. Filters can even contain custom form components, making them a potent tool for building interfaces.\n\nFilament includes a prebuilt SelectFilter that you can add to the table’s filters():\n\n`SelectFilter``filters()````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->filters([\n            Tables\\Filters\\SelectFilter::make('type')\n                ->options([\n                    'cat' => 'Cat',\n                    'dog' => 'Dog',\n                    'rabbit' => 'Rabbit',\n                ]),\n        ]);\n}\n```\n\nReload the page, and you should see a new filter icon in the top right corner (next to the search form). The filter opens a select menu with a list of patient types. Try filtering your patients by type.",
                "level": 5
              },
              {
                "title": "## #Introducing relation managers",
                "content": "Currently, patients can be associated with their owners in our system. But what happens if we want a third level? Patients come to the vet practice for treatment, and the system should be able to record these treatments and associate them with a patient.\n\nOne option is to create a new TreatmentResource with a select field to associate treatments with a patient. However, managing treatments separately from the rest of the patient information is cumbersome for the user. Filament uses “relation managers” to solve this problem.\n\n`TreatmentResource`Relation managers are tables that display related records for an existing resource on the edit screen for the parent resource. For example, in our project, you could view and manage a patient’s treatments directly below their edit form.\n\n> You can also use Filament “actions” to open a modal form to create, edit, and delete treatments directly from the patient’s table.\n\nYou can also use Filament “actions” to open a modal form to create, edit, and delete treatments directly from the patient’s table.\n\nUse the make:filament-relation-manager artisan command to quickly create a relation manager, connecting the patient resource to the related treatments:\n\n`make:filament-relation-manager````\nphp artisan make:filament-relation-manager PatientResource treatments description\n```\n\n- PatientResource is the name of the resource class for the owner model. Since treatments belong to patients, the treatments should be displayed on the Edit Patient page.\n- treatments is the name of the relationship in the Patient model we created earlier.\n- description is the column to display from the treatments table.\n\n`PatientResource``treatments``description`This will create a PatientResource/RelationManagers/TreatmentsRelationManager.php file. You must register the new relation manager in the getRelations() method of the PatientResource:\n\n`PatientResource/RelationManagers/TreatmentsRelationManager.php``getRelations()``PatientResource````\nuse App\\Filament\\Resources\\PatientResource\\RelationManagers;\n\npublic static function getRelations(): array\n{\n    return [\n        RelationManagers\\TreatmentsRelationManager::class,\n    ];\n}\n```\n\nThe TreatmentsRelationManager.php file contains a class that is prepopulated with a form and table using the parameters from the make:filament-relation-manager artisan command. You can customize the fields and columns in the relation manager similar to how you would in a resource:\n\n`TreatmentsRelationManager.php``make:filament-relation-manager````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('description')\n                ->required()\n                ->maxLength(255),\n        ]);\n}\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('description'),\n        ]);\n}\n```\n\nVisit the Edit page for one of your patients. You should already be able to create, edit, delete, and list treatments for that patient.",
                "level": 3
              },
              {
                "title": "### #Setting up the treatment form",
                "content": "By default, text fields only span half the width of the form. Since the description field might contain a lot of information, add a columnSpan('full') method to make the field span the entire width of the modal form:\n\n`description``columnSpan('full')````\nuse Filament\\Forms;\n\nForms\\Components\\TextInput::make('description')\n    ->required()\n    ->maxLength(255)\n    ->columnSpan('full')\n```\n\nLet’s add the notes field, which can be used to add more details about the treatment. We can use a textarea field with a columnSpan('full'):\n\n`notes``columnSpan('full')````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('description')\n                ->required()\n                ->maxLength(255)\n                ->columnSpan('full'),\n            Forms\\Components\\Textarea::make('notes')\n                ->maxLength(65535)\n                ->columnSpan('full'),\n        ]);\n}\n```",
                "level": 4
              },
              {
                "title": "#### #Configuring the price field",
                "content": "`price`Let’s add a price field for the treatment. We can use a text input with some customizations to make it suitable for currency input. It should be numeric(), which adds validation and changes the keyboard layout on mobile devices. Add your preferred currency prefix using the prefix() method; for example, prefix('€') will add a € before the input without impacting the saved output value:\n\n`price``numeric()``prefix()``prefix('€')``€````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('description')\n                ->required()\n                ->maxLength(255)\n                ->columnSpan('full'),\n            Forms\\Components\\Textarea::make('notes')\n                ->maxLength(65535)\n                ->columnSpan('full'),\n            Forms\\Components\\TextInput::make('price')\n                ->numeric()\n                ->prefix('€')\n                ->maxValue(42949672.95),\n        ]);\n}\n```",
                "level": 5
              },
              {
                "title": "##### #Casting the price to an integer",
                "content": "Filament stores currency values as integers (not floats) to avoid rounding and precision issues — a widely-accepted approach in the Laravel community. However, this requires creating a cast in Laravel that transforms the integer into a float when retrieved and back to an integer when stored in the database. Use the following artisan command to create the cast:\n\n```\nphp artisan make:cast MoneyCast\n```\n\nInside the new app/Casts/MoneyCast.php file, update the get() and set() methods:\n\n`app/Casts/MoneyCast.php``get()``set()````\npublic function get($model, string $key, $value, array $attributes): float\n{\n    // Transform the integer stored in the database into a float.\n    return round(floatval($value) / 100, precision: 2);\n}\n\npublic function set($model, string $key, $value, array $attributes): float\n{\n    // Transform the float into an integer for storage.\n    return round(floatval($value) * 100);\n}\n```\n\nNow, add the MoneyCast to the price attribute in the Treatment model:\n\n`MoneyCast``price``Treatment````\nuse App\\Casts\\MoneyCast;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Treatment extends Model\n{\n    protected $casts = [\n        'price' => MoneyCast::class,\n    ];\n\n    // ...\n}\n```",
                "level": 6
              },
              {
                "title": "### #Setting up the treatments table",
                "content": "When the relation manager was generated previously, the description text column was automatically added. Let’s also add a sortable() column for the price with a currency prefix. Use the Filament money() method to format the price column as money — in this case for EUR (€):\n\n`description``sortable()``price``money()``price``EUR``€````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('description'),\n            Tables\\Columns\\TextColumn::make('price')\n                ->money('EUR')\n                ->sortable(),\n        ]);\n}\n```\n\nLet’s also add a column to indicate when the treatment was administered using the default created_at timestamp. Use the dateTime() method to display the date-time in a human-readable format:\n\n`created_at``dateTime()````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('description'),\n            Tables\\Columns\\TextColumn::make('price')\n                ->money('EUR')\n                ->sortable(),\n            Tables\\Columns\\TextColumn::make('created_at')\n                ->dateTime(),\n        ]);\n}\n```\n\n> You can pass any valid PHP date formatting string to the dateTime() method (e.g. dateTime('m-d-Y h:i A')).\n\nYou can pass any valid PHP date formatting string to the dateTime() method (e.g. dateTime('m-d-Y h:i A')).\n\n`dateTime()``dateTime('m-d-Y h:i A')`## #Introducing widgets\n\nFilament widgets are components that display information on your dashboard, especially statistics. Widgets are typically added to the default Dashboard of the panel, but you can add them to any page, including resource pages. Filament includes built-in widgets like the stats widget, to render important statistics in a simple overview; chart widget, which can render an interactive chart; and table widget, which allows you to easily embed the Table Builder.\n\nLet’s add a stats widget to our default dashboard page that includes a stat for each type of patient and a chart to visualize treatments administered over time.",
                "level": 4
              },
              {
                "title": "### #Creating a stats widget",
                "content": "Create a stats widget to render patient types using the following artisan command:\n\n```\nphp artisan make:filament-widget PatientTypeOverview --stats-overview\n```\n\nWhen prompted, do not specify a resource, and select “admin” for the location.\n\nThis will create a new app/Filament/Widgets/PatientTypeOverview.php file. Open it, and return Stat instances from the getStats() method:\n\n`app/Filament/Widgets/PatientTypeOverview.php``Stat``getStats()````\n<?php\n\nnamespace App\\Filament\\Widgets;\n\nuse App\\Models\\Patient;\nuse Filament\\Widgets\\StatsOverviewWidget as BaseWidget;\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nclass PatientTypeOverview extends BaseWidget\n{\n    protected function getStats(): array\n    {\n        return [\n            Stat::make('Cats', Patient::query()->where('type', 'cat')->count()),\n            Stat::make('Dogs', Patient::query()->where('type', 'dog')->count()),\n            Stat::make('Rabbits', Patient::query()->where('type', 'rabbit')->count()),\n        ];\n    }\n}\n```\n\nOpen your dashboard, and you should see your new widget displayed. Each stat should show the total number of patients for the specified type.",
                "level": 4
              },
              {
                "title": "### #Creating a chart widget",
                "content": "Let’s add a chart to the dashboard to visualize the number of treatments administered over time. Use the following artisan command to create a new chart widget:\n\n```\nphp artisan make:filament-widget TreatmentsChart --chart\n```\n\nWhen prompted, do not specify a resource, select “admin” for the location, and choose “line chart” as the chart type.\n\nOpen app/Filament/Widgets/TreatmentsChart.php and set the $heading of the chart to “Treatments”.\n\n`app/Filament/Widgets/TreatmentsChart.php``$heading`The getData() method returns an array of datasets and labels. Each dataset is a labeled array of points to plot on the chart, and each label is a string. This structure is identical to the Chart.js library, which Filament uses to render charts.\n\n`getData()`To populate chart data from an Eloquent model, Filament recommends that you install the flowframe/laravel-trend package:\n\n```\ncomposer require flowframe/laravel-trend\n```\n\nUpdate the getData() to display the number of treatments per month for the past year:\n\n`getData()````\nuse App\\Models\\Treatment;\nuse Flowframe\\Trend\\Trend;\nuse Flowframe\\Trend\\TrendValue;\n\nprotected function getData(): array\n{\n    $data = Trend::model(Treatment::class)\n        ->between(\n            start: now()->subYear(),\n            end: now(),\n        )\n        ->perMonth()\n        ->count();\n\n    return [\n        'datasets' => [\n            [\n                'label' => 'Treatments',\n                'data' => $data->map(fn (TrendValue $value) => $value->aggregate),\n            ],\n        ],\n        'labels' => $data->map(fn (TrendValue $value) => $value->date),\n    ];\n}\n```\n\nNow, check out your new chart widget in the dashboard!\n\n> You can customize your dashboard page to change the grid and how many widgets are displayed.\n\nYou can customize your dashboard page to change the grid and how many widgets are displayed.",
                "level": 4
              },
              {
                "title": "## #Next steps with the Panel Builder",
                "content": "Congratulations! Now that you know how to build a basic Filament application, here are some suggestions for further learning:\n\n- Create custom pages in the panel that don’t belong to resources.\n- Learn more about adding action buttons to pages and resources, with modals to collect user input or for confirmation.\n- Explore the available fields to collect input from your users.\n- Check out the list of form layout components.\n- Discover how to build complex, responsive table layouts without touching CSS.\n- Add summaries to your tables\n- Write automated tests for your panel using our suite of helper methods.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Prerequisites",
              "The demo project",
              "Setting up the database and models",
              "Defining migrations",
              "Setting up relationships between models",
              "Introducing resources",
              "Setting up the patients table",
              "Introducing relation managers",
              "Setting up the treatment form"
            ],
            "code_examples_count": 68,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "resources": {
          "metadata": {
            "title": "Resources",
            "url": "https://filamentphp.com/docs/3.x/panels/resources",
            "section": "panels",
            "word_count": 2744,
            "character_count": 21356
          },
          "content": {
            "full_text": "\n# Getting started - Panels - Filament\n\nPanels  \n-  Resources\n\n# Getting started\n\n## #Overview\n\nResources are static classes that are used to build CRUD interfaces for your Eloquent models. They describe how administrators should be able to interact with data from your app - using tables and forms.\n\n## #Creating a resource\n\nTo create a resource for the App\\Models\\Customer model:\n\n`App\\Models\\Customer````\nphp artisan make:filament-resource Customer\n```\n\nThis will create several files in the app/Filament/Resources directory:\n\n`app/Filament/Resources````\n.\n+-- CustomerResource.php\n+-- CustomerResource\n|   +-- Pages\n|   |   +-- CreateCustomer.php\n|   |   +-- EditCustomer.php\n|   |   +-- ListCustomers.php\n```\n\nYour new resource class lives in CustomerResource.php.\n\n`CustomerResource.php`The classes in the Pages directory are used to customize the pages in the app that interact with your resource. They’re all full-page Livewire components that you can customize in any way you wish.\n\n`Pages`> Have you created a resource, but it’s not appearing in the navigation menu? If you have a model policy, make sure you return true from the viewAny() method.\n\nHave you created a resource, but it’s not appearing in the navigation menu? If you have a model policy, make sure you return true from the viewAny() method.\n\n`true``viewAny()`### #Simple (modal) resources\n\nSometimes, your models are simple enough that you only want to manage records on one page, using modals to create, edit and delete records. To generate a simple resource with modals:\n\n```\nphp artisan make:filament-resource Customer --simple\n```\n\nYour resource will have a “Manage” page, which is a List page with modals added.\n\nAdditionally, your simple resource will have no getRelations() method, as relation managers are only displayed on the Edit and View pages, which are not present in simple resources. Everything else is the same.\n\n`getRelations()`### #Automatically generating forms and tables\n\nIf you’d like to save time, Filament can automatically generate the form and table for you, based on your model’s database columns, using --generate:\n\n`--generate````\nphp artisan make:filament-resource Customer --generate\n```\n\n### #Handling soft deletes\n\nBy default, you will not be able to interact with deleted records in the app. If you’d like to add functionality to restore, force delete and filter trashed records in your resource, use the --soft-deletes flag when generating the resource:\n\n`--soft-deletes````\nphp artisan make:filament-resource Customer --soft-deletes\n```\n\nYou can find out more about soft deleting here.\n\n### #Generating a View page\n\nBy default, only List, Create and Edit pages are generated for your resource. If you’d also like a View page, use the --view flag:\n\n`--view````\nphp artisan make:filament-resource Customer --view\n```\n\n### #Specifiying a custom model namespace\n\nBy default, Filament will assume that your model exists in the App\\Models directory. You can pass a different namespace for the model using the --model-namespace flag:\n\n`App\\Models``--model-namespace````\nphp artisan make:filament-resource Customer --model-namespace=Custom\\\\Path\\\\Models\n```\n\nIn this example, the model should exist at Custom\\Path\\Models\\Customer. Please note the double backslashes \\\\ in the command that are required.\n\n`Custom\\Path\\Models\\Customer``\\\\`Now when generating the resource, Filament will be able to locate the model and read the database schema.\n\n### #Generating the model, migration and factory at the same name\n\nIf you’d like to save time when scaffolding your resources, Filament can also generate the model, migration and factory for the new resource at the same time using the --model, --migration and --factory flags in any combination:\n\n`--model``--migration``--factory````\nphp artisan make:filament-resource Customer --model --migration --factory\n```\n\n## #Record titles\n\nA $recordTitleAttribute may be set for your resource, which is the name of the column on your model that can be used to identify it from others.\n\n`$recordTitleAttribute`For example, this could be a blog post’s title or a customer’s name:\n\n`title``name````\nprotected static ?string $recordTitleAttribute = 'name';\n```\n\nThis is required for features like global search to work.\n\n> You may specify the name of an Eloquent accessor if just one column is inadequate at identifying a record.\n\nYou may specify the name of an Eloquent accessor if just one column is inadequate at identifying a record.\n\n## #Resource forms\n\nResource classes contain a form() method that is used to build the forms on the Create and Edit pages:\n\n`form()````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic static function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('name')->required(),\n            Forms\\Components\\TextInput::make('email')->email()->required(),\n            // ...\n        ]);\n}\n```\n\nThe schema() method is used to define the structure of your form. It is an array of fields and layout components, in the order they should appear in your form.\n\n`schema()`Check out the Forms docs for a guide on how to build forms with Filament.\n\n### #Hiding components based on the current operation\n\nThe hiddenOn() method of form components allows you to dynamically hide fields based on the current page or action.\n\n`hiddenOn()`In this example, we hide the password field on the edit page:\n\n`password``edit````\nuse Livewire\\Component;\n\nForms\\Components\\TextInput::make('password')\n    ->password()\n    ->required()\n    ->hiddenOn('edit'),\n```\n\nAlternatively, we have a visibleOn() shortcut method for only showing a field on one page or action:\n\n`visibleOn()````\nuse Livewire\\Component;\n\nForms\\Components\\TextInput::make('password')\n    ->password()\n    ->required()\n    ->visibleOn('create'),\n```\n\n## #Resource tables\n\nResource classes contain a table() method that is used to build the table on the List page:\n\n`table()````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('name'),\n            Tables\\Columns\\TextColumn::make('email'),\n            // ...\n        ])\n        ->filters([\n            Tables\\Filters\\Filter::make('verified')\n                ->query(fn (Builder $query): Builder => $query->whereNotNull('email_verified_at')),\n            // ...\n        ])\n        ->actions([\n            Tables\\Actions\\EditAction::make(),\n        ])\n        ->bulkActions([\n            Tables\\Actions\\BulkActionGroup::make([\n                Tables\\Actions\\DeleteBulkAction::make(),\n            ]),\n        ]);\n}\n```\n\nCheck out the tables docs to find out how to add table columns, filters, actions and more.\n\n## #Authorization\n\nFor authorization, Filament will observe any model policies that are registered in your app. The following methods are used:\n\n- viewAny() is used to completely hide resources from the navigation menu, and prevents the user from accessing any pages.\n- create() is used to control creating new records.\n- update() is used to control editing a record.\n- view() is used to control viewing a record.\n- delete() is used to prevent a single record from being deleted. deleteAny() is used to prevent records from being bulk deleted. Filament uses the deleteAny() method because iterating through multiple records and checking the delete() policy is not very performant.\n- forceDelete() is used to prevent a single soft-deleted record from being force-deleted. forceDeleteAny() is used to prevent records from being bulk force-deleted. Filament uses the forceDeleteAny() method because iterating through multiple records and checking the forceDelete() policy is not very performant.\n- restore() is used to prevent a single soft-deleted record from being restored. restoreAny() is used to prevent records from being bulk restored. Filament uses the restoreAny() method because iterating through multiple records and checking the restore() policy is not very performant.\n- reorder() is used to control reordering a record.\n\n`viewAny()``create()``update()``view()``delete()``deleteAny()``deleteAny()``delete()``forceDelete()``forceDeleteAny()``forceDeleteAny()``forceDelete()``restore()``restoreAny()``restoreAny()``restore()``reorder()`### #Skipping authorization\n\nIf you’d like to skip authorization for a resource, you may set the $shouldSkipAuthorization property to true:\n\n`$shouldSkipAuthorization``true````\nprotected static bool $shouldSkipAuthorization = true;\n```\n\n## #Customizing the model label\n\nEach resource has a “model label” which is automatically generated from the model name. For example, an App\\Models\\Customer model will have a customer label.\n\n`App\\Models\\Customer``customer`The label is used in several parts of the UI, and you may customize it using the $modelLabel property:\n\n`$modelLabel````\nprotected static ?string $modelLabel = 'cliente';\n```\n\nAlternatively, you may use the getModelLabel() to define a dynamic label:\n\n`getModelLabel()````\npublic static function getModelLabel(): string\n{\n    return __('filament/resources/customer.label');\n}\n```\n\n### #Customizing the plural model label\n\nResources also have a “plural model label” which is automatically generated from the model label. For example, a customer label will be pluralized into customers.\n\n`customer``customers`You may customize the plural version of the label using the $pluralModelLabel property:\n\n`$pluralModelLabel````\nprotected static ?string $pluralModelLabel = 'clientes';\n```\n\nAlternatively, you may set a dynamic plural label in the getPluralModelLabel() method:\n\n`getPluralModelLabel()````\npublic static function getPluralModelLabel(): string\n{\n    return __('filament/resources/customer.plural_label');\n}\n```\n\n### #Automatic model label capitalization\n\nBy default, Filament will automatically capitalize each word in the model label, for some parts of the UI. For example, in page titles, the navigation menu, and the breadcrumbs.\n\nIf you want to disable this behavior for a resource, you can set $hasTitleCaseModelLabel in the resource:\n\n`$hasTitleCaseModelLabel````\nprotected static bool $hasTitleCaseModelLabel = false;\n```\n\n## #Resource navigation items\n\nFilament will automatically generate a navigation menu item for your resource using the plural label.\n\nIf you’d like to customize the navigation item label, you may use the $navigationLabel property:\n\n`$navigationLabel````\nprotected static ?string $navigationLabel = 'Mis Clientes';\n```\n\nAlternatively, you may set a dynamic navigation label in the getNavigationLabel() method:\n\n`getNavigationLabel()````\npublic static function getNavigationLabel(): string\n{\n    return __('filament/resources/customer.navigation_label');\n}\n```\n\n### #Setting a resource navigation icon\n\nThe $navigationIcon property supports the name of any Blade component. By default, Heroicons are installed. However, you may create your own custom icon components or install an alternative library if you wish.\n\n`$navigationIcon````\nprotected static ?string $navigationIcon = 'heroicon-o-user-group';\n```\n\nAlternatively, you may set a dynamic navigation icon in the getNavigationIcon() method:\n\n`getNavigationIcon()````\nuse Illuminate\\Contracts\\Support\\Htmlable;\n\npublic static function getNavigationIcon(): string | Htmlable | null\n{\n    return 'heroicon-o-user-group';\n}\n```\n\n### #Sorting resource navigation items\n\nThe $navigationSort property allows you to specify the order in which navigation items are listed:\n\n`$navigationSort````\nprotected static ?int $navigationSort = 2;\n```\n\nAlternatively, you may set a dynamic navigation item order in the getNavigationSort() method:\n\n`getNavigationSort()````\npublic static function getNavigationSort(): ?int\n{\n    return 2;\n}\n```\n\n### #Grouping resource navigation items\n\nYou may group navigation items by specifying a $navigationGroup property:\n\n`$navigationGroup````\nprotected static ?string $navigationGroup = 'Shop';\n```\n\nAlternatively, you may use the getNavigationGroup() method to set a dynamic group label:\n\n`getNavigationGroup()````\npublic static function getNavigationGroup(): ?string\n{\n    return __('filament/navigation.groups.shop');\n}\n```\n\n#### #Grouping resource navigation items under other items\n\nYou may group navigation items as children of other items, by passing the label of the parent item as the $navigationParentItem:\n\n`$navigationParentItem````\nprotected static ?string $navigationParentItem = 'Products';\n\nprotected static ?string $navigationGroup = 'Shop';\n```\n\nAs seen above, if the parent item has a navigation group, that navigation group must also be defined, so the correct parent item can be identified.\n\nYou may also use the getNavigationParentItem() method to set a dynamic parent item label:\n\n`getNavigationParentItem()````\npublic static function getNavigationParentItem(): ?string\n{\n    return __('filament/navigation.groups.shop.items.products');\n}\n```\n\n> If you’re reaching for a third level of navigation like this, you should consider using clusters instead, which are a logical grouping of resources and custom pages, which can share their own separate navigation.\n\nIf you’re reaching for a third level of navigation like this, you should consider using clusters instead, which are a logical grouping of resources and custom pages, which can share their own separate navigation.\n\n## #Generating URLs to resource pages\n\nFilament provides getUrl() static method on resource classes to generate URLs to resources and specific pages within them. Traditionally, you would need to construct the URL by hand or by using Laravel’s route() helper, but these methods depend on knowledge of the resource’s slug or route naming conventions.\n\n`getUrl()``route()`The getUrl() method, without any arguments, will generate a URL to the resource’s List page:\n\n`getUrl()````\nuse App\\Filament\\Resources\\CustomerResource;\n\nCustomerResource::getUrl(); // /admin/customers\n```\n\nYou may also generate URLs to specific pages within the resource. The name of each page is the array key in the getPages() array of the resource. For example, to generate a URL to the Create page:\n\n`getPages()````\nuse App\\Filament\\Resources\\CustomerResource;\n\nCustomerResource::getUrl('create'); // /admin/customers/create\n```\n\nSome pages in the getPages() method use URL parameters like record. To generate a URL to these pages and pass in a record, you should use the second argument:\n\n`getPages()``record````\nuse App\\Filament\\Resources\\CustomerResource;\n\nCustomerResource::getUrl('edit', ['record' => $customer]); // /admin/customers/edit/1\n```\n\nIn this example, $customer can be an Eloquent model object, or an ID.\n\n`$customer`### #Generating URLs to resource modals\n\nThis can be especially useful if you are using simple resources with only one page.\n\nTo generate a URL for an action in the resource’s table, you should pass the tableAction and tableActionRecord as URL parameters:\n\n`tableAction``tableActionRecord````\nuse App\\Filament\\Resources\\CustomerResource;\nuse Filament\\Tables\\Actions\\EditAction;\n\nCustomerResource::getUrl(parameters: [\n    'tableAction' => EditAction::getDefaultName(),\n    'tableActionRecord' => $customer,\n]); // /admin/customers?tableAction=edit&tableActionRecord=1\n```\n\nOr if you want to generate a URL for an action on the page like a CreateAction in the header, you can pass it in to the action parameter:\n\n`CreateAction``action````\nuse App\\Filament\\Resources\\CustomerResource;\nuse Filament\\Actions\\CreateAction;\n\nCustomerResource::getUrl(parameters: [\n    'action' => CreateAction::getDefaultName(),\n]); // /admin/customers?action=create\n```\n\n### #Generating URLs to resources in other panels\n\nIf you have multiple panels in your app, getUrl() will generate a URL within the current panel. You can also indicate which panel the resource is associated with, by passing the panel ID to the panel argument:\n\n`getUrl()``panel````\nuse App\\Filament\\Resources\\CustomerResource;\n\nCustomerResource::getUrl(panel: 'marketing');\n```\n\n## #Customizing the resource Eloquent query\n\nWithin Filament, every query to your resource model will start with the getEloquentQuery() method.\n\n`getEloquentQuery()`Because of this, it’s very easy to apply your own query constraints or model scopes that affect the entire resource:\n\n```\npublic static function getEloquentQuery(): Builder\n{\n    return parent::getEloquentQuery()->where('is_active', true);\n}\n```\n\n### #Disabling global scopes\n\nBy default, Filament will observe all global scopes that are registered to your model. However, this may not be ideal if you wish to access, for example, soft deleted records.\n\nTo overcome this, you may override the getEloquentQuery() method that Filament uses:\n\n`getEloquentQuery()````\npublic static function getEloquentQuery(): Builder\n{\n    return parent::getEloquentQuery()->withoutGlobalScopes();\n}\n```\n\nAlternatively, you may remove specific global scopes:\n\n```\npublic static function getEloquentQuery(): Builder\n{\n    return parent::getEloquentQuery()->withoutGlobalScopes([ActiveScope::class]);\n}\n```\n\nMore information about removing global scopes may be found in the Laravel documentation.\n\n## #Customizing the resource URL\n\nBy default, Filament will generate a URL based on the name of the resource. You can customize this by setting the $slug property on the resource:\n\n`$slug````\nprotected static ?string $slug = 'pending-orders';\n```\n\n## #Resource sub-navigation\n\nSub-navigation allows the user to navigate between different pages within a resource. Typically, all pages in the sub-navigation will be related to the same record in the resource. For example, in a Customer resource, you may have a sub-navigation with the following pages:\n\n- View customer, a ViewRecord page that provides a read-only view of the customer’s details.\n- Edit customer, an EditRecord page that allows the user to edit the customer’s details.\n- Edit customer contact, an EditRecord page that allows the user to edit the customer’s contact details. You can learn how to create more than one Edit page.\n- Manage addresses, a ManageRelatedRecords page that allows the user to manage the customer’s addresses.\n- Manage payments, a ManageRelatedRecords page that allows the user to manage the customer’s payments.\n\n`ViewRecord``EditRecord``EditRecord``ManageRelatedRecords``ManageRelatedRecords`To add a sub-navigation to each “singular record” page in the resource, you can add the getRecordSubNavigation() method to the resource class:\n\n`getRecordSubNavigation()````\nuse App\\Filament\\Resources\\CustomerResource\\Pages;\nuse Filament\\Resources\\Pages\\Page;\n\npublic static function getRecordSubNavigation(Page $page): array\n{\n    return $page->generateNavigationItems([\n        Pages\\ViewCustomer::class,\n        Pages\\EditCustomer::class,\n        Pages\\EditCustomerContact::class,\n        Pages\\ManageCustomerAddresses::class,\n        Pages\\ManageCustomerPayments::class,\n    ]);\n}\n```\n\nEach item in the sub-navigation can be customized using the same navigation methods as normal pages.\n\n> If you’re looking to add sub-navigation to switch between entire resources and custom pages, you might be looking for clusters, which are used to group these together. The getRecordSubNavigation() method is intended to construct a navigation between pages that relate to a particular record inside a resource.\n\nIf you’re looking to add sub-navigation to switch between entire resources and custom pages, you might be looking for clusters, which are used to group these together. The getRecordSubNavigation() method is intended to construct a navigation between pages that relate to a particular record inside a resource.\n\n`getRecordSubNavigation()`### #Sub-navigation position\n\nThe sub-navigation is rendered at the start of the page by default. You may change the position by setting the $subNavigationPosition property on the resource. The value may be SubNavigationPosition::Start, SubNavigationPosition::End, or SubNavigationPosition::Top to render the sub-navigation as tabs:\n\n`$subNavigationPosition``SubNavigationPosition::Start``SubNavigationPosition::End``SubNavigationPosition::Top````\nuse Filament\\Pages\\SubNavigationPosition;\n\nprotected static SubNavigationPosition $subNavigationPosition = SubNavigationPosition::End;\n```\n\n## #Deleting resource pages\n\nIf you’d like to delete a page from your resource, you can just delete the page file from the Pages directory of your resource, and its entry in the getPages() method.\n\n`Pages``getPages()`For example, you may have a resource with records that may not be created by anyone. Delete the Create page file, and then remove it from getPages():\n\n`Create``getPages()````\npublic static function getPages(): array\n{\n    return [\n        'index' => Pages\\ListCustomers::route('/'),\n        'edit' => Pages\\EditCustomer::route('/{record}/edit'),\n    ];\n}\n```\n\nDeleting a page will not delete any actions that link to that page. Any actions will open a modal instead of sending the user to the non-existent page. For instance, the CreateAction on the List page, the EditAction on the table or View page, or the ViewAction on the table or Edit page. If you want to remove those buttons, you must delete the actions as well.\n\n`CreateAction``EditAction``ViewAction`Still need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Panels - Filament",
                "content": "Panels  \n-  Resources",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Resources are static classes that are used to build CRUD interfaces for your Eloquent models. They describe how administrators should be able to interact with data from your app - using tables and forms.",
                "level": 3
              },
              {
                "title": "## #Creating a resource",
                "content": "To create a resource for the App\\Models\\Customer model:\n\n`App\\Models\\Customer````\nphp artisan make:filament-resource Customer\n```\n\nThis will create several files in the app/Filament/Resources directory:\n\n`app/Filament/Resources````\n.\n+-- CustomerResource.php\n+-- CustomerResource\n|   +-- Pages\n|   |   +-- CreateCustomer.php\n|   |   +-- EditCustomer.php\n|   |   +-- ListCustomers.php\n```\n\nYour new resource class lives in CustomerResource.php.\n\n`CustomerResource.php`The classes in the Pages directory are used to customize the pages in the app that interact with your resource. They’re all full-page Livewire components that you can customize in any way you wish.\n\n`Pages`> Have you created a resource, but it’s not appearing in the navigation menu? If you have a model policy, make sure you return true from the viewAny() method.\n\nHave you created a resource, but it’s not appearing in the navigation menu? If you have a model policy, make sure you return true from the viewAny() method.\n\n`true``viewAny()`### #Simple (modal) resources\n\nSometimes, your models are simple enough that you only want to manage records on one page, using modals to create, edit and delete records. To generate a simple resource with modals:\n\n```\nphp artisan make:filament-resource Customer --simple\n```\n\nYour resource will have a “Manage” page, which is a List page with modals added.\n\nAdditionally, your simple resource will have no getRelations() method, as relation managers are only displayed on the Edit and View pages, which are not present in simple resources. Everything else is the same.\n\n`getRelations()`### #Automatically generating forms and tables\n\nIf you’d like to save time, Filament can automatically generate the form and table for you, based on your model’s database columns, using --generate:\n\n`--generate````\nphp artisan make:filament-resource Customer --generate\n```",
                "level": 3
              },
              {
                "title": "### #Handling soft deletes",
                "content": "By default, you will not be able to interact with deleted records in the app. If you’d like to add functionality to restore, force delete and filter trashed records in your resource, use the --soft-deletes flag when generating the resource:\n\n`--soft-deletes````\nphp artisan make:filament-resource Customer --soft-deletes\n```\n\nYou can find out more about soft deleting here.",
                "level": 4
              },
              {
                "title": "### #Generating a View page",
                "content": "By default, only List, Create and Edit pages are generated for your resource. If you’d also like a View page, use the --view flag:\n\n`--view````\nphp artisan make:filament-resource Customer --view\n```",
                "level": 4
              },
              {
                "title": "### #Specifiying a custom model namespace",
                "content": "By default, Filament will assume that your model exists in the App\\Models directory. You can pass a different namespace for the model using the --model-namespace flag:\n\n`App\\Models``--model-namespace````\nphp artisan make:filament-resource Customer --model-namespace=Custom\\\\Path\\\\Models\n```\n\nIn this example, the model should exist at Custom\\Path\\Models\\Customer. Please note the double backslashes \\\\ in the command that are required.\n\n`Custom\\Path\\Models\\Customer``\\\\`Now when generating the resource, Filament will be able to locate the model and read the database schema.",
                "level": 4
              },
              {
                "title": "### #Generating the model, migration and factory at the same name",
                "content": "If you’d like to save time when scaffolding your resources, Filament can also generate the model, migration and factory for the new resource at the same time using the --model, --migration and --factory flags in any combination:\n\n`--model``--migration``--factory````\nphp artisan make:filament-resource Customer --model --migration --factory\n```",
                "level": 4
              },
              {
                "title": "## #Record titles",
                "content": "A $recordTitleAttribute may be set for your resource, which is the name of the column on your model that can be used to identify it from others.\n\n`$recordTitleAttribute`For example, this could be a blog post’s title or a customer’s name:\n\n`title``name````\nprotected static ?string $recordTitleAttribute = 'name';\n```\n\nThis is required for features like global search to work.\n\n> You may specify the name of an Eloquent accessor if just one column is inadequate at identifying a record.\n\nYou may specify the name of an Eloquent accessor if just one column is inadequate at identifying a record.",
                "level": 3
              },
              {
                "title": "## #Resource forms",
                "content": "Resource classes contain a form() method that is used to build the forms on the Create and Edit pages:\n\n`form()````\nuse Filament\\Forms;\nuse Filament\\Forms\\Form;\n\npublic static function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            Forms\\Components\\TextInput::make('name')->required(),\n            Forms\\Components\\TextInput::make('email')->email()->required(),\n            // ...\n        ]);\n}\n```\n\nThe schema() method is used to define the structure of your form. It is an array of fields and layout components, in the order they should appear in your form.\n\n`schema()`Check out the Forms docs for a guide on how to build forms with Filament.",
                "level": 3
              },
              {
                "title": "### #Hiding components based on the current operation",
                "content": "The hiddenOn() method of form components allows you to dynamically hide fields based on the current page or action.\n\n`hiddenOn()`In this example, we hide the password field on the edit page:\n\n`password``edit````\nuse Livewire\\Component;\n\nForms\\Components\\TextInput::make('password')\n    ->password()\n    ->required()\n    ->hiddenOn('edit'),\n```\n\nAlternatively, we have a visibleOn() shortcut method for only showing a field on one page or action:\n\n`visibleOn()````\nuse Livewire\\Component;\n\nForms\\Components\\TextInput::make('password')\n    ->password()\n    ->required()\n    ->visibleOn('create'),\n```",
                "level": 4
              },
              {
                "title": "## #Resource tables",
                "content": "Resource classes contain a table() method that is used to build the table on the List page:\n\n`table()````\nuse Filament\\Tables;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Tables\\Columns\\TextColumn::make('name'),\n            Tables\\Columns\\TextColumn::make('email'),\n            // ...\n        ])\n        ->filters([\n            Tables\\Filters\\Filter::make('verified')\n                ->query(fn (Builder $query): Builder => $query->whereNotNull('email_verified_at')),\n            // ...\n        ])\n        ->actions([\n            Tables\\Actions\\EditAction::make(),\n        ])\n        ->bulkActions([\n            Tables\\Actions\\BulkActionGroup::make([\n                Tables\\Actions\\DeleteBulkAction::make(),\n            ]),\n        ]);\n}\n```\n\nCheck out the tables docs to find out how to add table columns, filters, actions and more.",
                "level": 3
              },
              {
                "title": "## #Authorization",
                "content": "For authorization, Filament will observe any model policies that are registered in your app. The following methods are used:\n\n- viewAny() is used to completely hide resources from the navigation menu, and prevents the user from accessing any pages.\n- create() is used to control creating new records.\n- update() is used to control editing a record.\n- view() is used to control viewing a record.\n- delete() is used to prevent a single record from being deleted. deleteAny() is used to prevent records from being bulk deleted. Filament uses the deleteAny() method because iterating through multiple records and checking the delete() policy is not very performant.\n- forceDelete() is used to prevent a single soft-deleted record from being force-deleted. forceDeleteAny() is used to prevent records from being bulk force-deleted. Filament uses the forceDeleteAny() method because iterating through multiple records and checking the forceDelete() policy is not very performant.\n- restore() is used to prevent a single soft-deleted record from being restored. restoreAny() is used to prevent records from being bulk restored. Filament uses the restoreAny() method because iterating through multiple records and checking the restore() policy is not very performant.\n- reorder() is used to control reordering a record.\n\n`viewAny()``create()``update()``view()``delete()``deleteAny()``deleteAny()``delete()``forceDelete()``forceDeleteAny()``forceDeleteAny()``forceDelete()``restore()``restoreAny()``restoreAny()``restore()``reorder()`### #Skipping authorization\n\nIf you’d like to skip authorization for a resource, you may set the $shouldSkipAuthorization property to true:\n\n`$shouldSkipAuthorization``true````\nprotected static bool $shouldSkipAuthorization = true;\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the model label",
                "content": "Each resource has a “model label” which is automatically generated from the model name. For example, an App\\Models\\Customer model will have a customer label.\n\n`App\\Models\\Customer``customer`The label is used in several parts of the UI, and you may customize it using the $modelLabel property:\n\n`$modelLabel````\nprotected static ?string $modelLabel = 'cliente';\n```\n\nAlternatively, you may use the getModelLabel() to define a dynamic label:\n\n`getModelLabel()````\npublic static function getModelLabel(): string\n{\n    return __('filament/resources/customer.label');\n}\n```",
                "level": 3
              },
              {
                "title": "### #Customizing the plural model label",
                "content": "Resources also have a “plural model label” which is automatically generated from the model label. For example, a customer label will be pluralized into customers.\n\n`customer``customers`You may customize the plural version of the label using the $pluralModelLabel property:\n\n`$pluralModelLabel````\nprotected static ?string $pluralModelLabel = 'clientes';\n```\n\nAlternatively, you may set a dynamic plural label in the getPluralModelLabel() method:\n\n`getPluralModelLabel()````\npublic static function getPluralModelLabel(): string\n{\n    return __('filament/resources/customer.plural_label');\n}\n```",
                "level": 4
              },
              {
                "title": "### #Automatic model label capitalization",
                "content": "By default, Filament will automatically capitalize each word in the model label, for some parts of the UI. For example, in page titles, the navigation menu, and the breadcrumbs.\n\nIf you want to disable this behavior for a resource, you can set $hasTitleCaseModelLabel in the resource:\n\n`$hasTitleCaseModelLabel````\nprotected static bool $hasTitleCaseModelLabel = false;\n```",
                "level": 4
              },
              {
                "title": "## #Resource navigation items",
                "content": "Filament will automatically generate a navigation menu item for your resource using the plural label.\n\nIf you’d like to customize the navigation item label, you may use the $navigationLabel property:\n\n`$navigationLabel````\nprotected static ?string $navigationLabel = 'Mis Clientes';\n```\n\nAlternatively, you may set a dynamic navigation label in the getNavigationLabel() method:\n\n`getNavigationLabel()````\npublic static function getNavigationLabel(): string\n{\n    return __('filament/resources/customer.navigation_label');\n}\n```",
                "level": 3
              },
              {
                "title": "### #Setting a resource navigation icon",
                "content": "The $navigationIcon property supports the name of any Blade component. By default, Heroicons are installed. However, you may create your own custom icon components or install an alternative library if you wish.\n\n`$navigationIcon````\nprotected static ?string $navigationIcon = 'heroicon-o-user-group';\n```\n\nAlternatively, you may set a dynamic navigation icon in the getNavigationIcon() method:\n\n`getNavigationIcon()````\nuse Illuminate\\Contracts\\Support\\Htmlable;\n\npublic static function getNavigationIcon(): string | Htmlable | null\n{\n    return 'heroicon-o-user-group';\n}\n```",
                "level": 4
              },
              {
                "title": "### #Sorting resource navigation items",
                "content": "The $navigationSort property allows you to specify the order in which navigation items are listed:\n\n`$navigationSort````\nprotected static ?int $navigationSort = 2;\n```\n\nAlternatively, you may set a dynamic navigation item order in the getNavigationSort() method:\n\n`getNavigationSort()````\npublic static function getNavigationSort(): ?int\n{\n    return 2;\n}\n```",
                "level": 4
              },
              {
                "title": "### #Grouping resource navigation items",
                "content": "You may group navigation items by specifying a $navigationGroup property:\n\n`$navigationGroup````\nprotected static ?string $navigationGroup = 'Shop';\n```\n\nAlternatively, you may use the getNavigationGroup() method to set a dynamic group label:\n\n`getNavigationGroup()````\npublic static function getNavigationGroup(): ?string\n{\n    return __('filament/navigation.groups.shop');\n}\n```",
                "level": 4
              },
              {
                "title": "#### #Grouping resource navigation items under other items",
                "content": "You may group navigation items as children of other items, by passing the label of the parent item as the $navigationParentItem:\n\n`$navigationParentItem````\nprotected static ?string $navigationParentItem = 'Products';\n\nprotected static ?string $navigationGroup = 'Shop';\n```\n\nAs seen above, if the parent item has a navigation group, that navigation group must also be defined, so the correct parent item can be identified.\n\nYou may also use the getNavigationParentItem() method to set a dynamic parent item label:\n\n`getNavigationParentItem()````\npublic static function getNavigationParentItem(): ?string\n{\n    return __('filament/navigation.groups.shop.items.products');\n}\n```\n\n> If you’re reaching for a third level of navigation like this, you should consider using clusters instead, which are a logical grouping of resources and custom pages, which can share their own separate navigation.\n\nIf you’re reaching for a third level of navigation like this, you should consider using clusters instead, which are a logical grouping of resources and custom pages, which can share their own separate navigation.",
                "level": 5
              },
              {
                "title": "## #Generating URLs to resource pages",
                "content": "Filament provides getUrl() static method on resource classes to generate URLs to resources and specific pages within them. Traditionally, you would need to construct the URL by hand or by using Laravel’s route() helper, but these methods depend on knowledge of the resource’s slug or route naming conventions.\n\n`getUrl()``route()`The getUrl() method, without any arguments, will generate a URL to the resource’s List page:\n\n`getUrl()````\nuse App\\Filament\\Resources\\CustomerResource;\n\nCustomerResource::getUrl(); // /admin/customers\n```\n\nYou may also generate URLs to specific pages within the resource. The name of each page is the array key in the getPages() array of the resource. For example, to generate a URL to the Create page:\n\n`getPages()````\nuse App\\Filament\\Resources\\CustomerResource;\n\nCustomerResource::getUrl('create'); // /admin/customers/create\n```\n\nSome pages in the getPages() method use URL parameters like record. To generate a URL to these pages and pass in a record, you should use the second argument:\n\n`getPages()``record````\nuse App\\Filament\\Resources\\CustomerResource;\n\nCustomerResource::getUrl('edit', ['record' => $customer]); // /admin/customers/edit/1\n```\n\nIn this example, $customer can be an Eloquent model object, or an ID.\n\n`$customer`### #Generating URLs to resource modals\n\nThis can be especially useful if you are using simple resources with only one page.\n\nTo generate a URL for an action in the resource’s table, you should pass the tableAction and tableActionRecord as URL parameters:\n\n`tableAction``tableActionRecord````\nuse App\\Filament\\Resources\\CustomerResource;\nuse Filament\\Tables\\Actions\\EditAction;\n\nCustomerResource::getUrl(parameters: [\n    'tableAction' => EditAction::getDefaultName(),\n    'tableActionRecord' => $customer,\n]); // /admin/customers?tableAction=edit&tableActionRecord=1\n```\n\nOr if you want to generate a URL for an action on the page like a CreateAction in the header, you can pass it in to the action parameter:\n\n`CreateAction``action````\nuse App\\Filament\\Resources\\CustomerResource;\nuse Filament\\Actions\\CreateAction;\n\nCustomerResource::getUrl(parameters: [\n    'action' => CreateAction::getDefaultName(),\n]); // /admin/customers?action=create\n```",
                "level": 3
              },
              {
                "title": "### #Generating URLs to resources in other panels",
                "content": "If you have multiple panels in your app, getUrl() will generate a URL within the current panel. You can also indicate which panel the resource is associated with, by passing the panel ID to the panel argument:\n\n`getUrl()``panel````\nuse App\\Filament\\Resources\\CustomerResource;\n\nCustomerResource::getUrl(panel: 'marketing');\n```",
                "level": 4
              },
              {
                "title": "## #Customizing the resource Eloquent query",
                "content": "Within Filament, every query to your resource model will start with the getEloquentQuery() method.\n\n`getEloquentQuery()`Because of this, it’s very easy to apply your own query constraints or model scopes that affect the entire resource:\n\n```\npublic static function getEloquentQuery(): Builder\n{\n    return parent::getEloquentQuery()->where('is_active', true);\n}\n```",
                "level": 3
              },
              {
                "title": "### #Disabling global scopes",
                "content": "By default, Filament will observe all global scopes that are registered to your model. However, this may not be ideal if you wish to access, for example, soft deleted records.\n\nTo overcome this, you may override the getEloquentQuery() method that Filament uses:\n\n`getEloquentQuery()````\npublic static function getEloquentQuery(): Builder\n{\n    return parent::getEloquentQuery()->withoutGlobalScopes();\n}\n```\n\nAlternatively, you may remove specific global scopes:\n\n```\npublic static function getEloquentQuery(): Builder\n{\n    return parent::getEloquentQuery()->withoutGlobalScopes([ActiveScope::class]);\n}\n```\n\nMore information about removing global scopes may be found in the Laravel documentation.",
                "level": 4
              },
              {
                "title": "## #Customizing the resource URL",
                "content": "By default, Filament will generate a URL based on the name of the resource. You can customize this by setting the $slug property on the resource:\n\n`$slug````\nprotected static ?string $slug = 'pending-orders';\n```",
                "level": 3
              },
              {
                "title": "## #Resource sub-navigation",
                "content": "Sub-navigation allows the user to navigate between different pages within a resource. Typically, all pages in the sub-navigation will be related to the same record in the resource. For example, in a Customer resource, you may have a sub-navigation with the following pages:\n\n- View customer, a ViewRecord page that provides a read-only view of the customer’s details.\n- Edit customer, an EditRecord page that allows the user to edit the customer’s details.\n- Edit customer contact, an EditRecord page that allows the user to edit the customer’s contact details. You can learn how to create more than one Edit page.\n- Manage addresses, a ManageRelatedRecords page that allows the user to manage the customer’s addresses.\n- Manage payments, a ManageRelatedRecords page that allows the user to manage the customer’s payments.\n\n`ViewRecord``EditRecord``EditRecord``ManageRelatedRecords``ManageRelatedRecords`To add a sub-navigation to each “singular record” page in the resource, you can add the getRecordSubNavigation() method to the resource class:\n\n`getRecordSubNavigation()````\nuse App\\Filament\\Resources\\CustomerResource\\Pages;\nuse Filament\\Resources\\Pages\\Page;\n\npublic static function getRecordSubNavigation(Page $page): array\n{\n    return $page->generateNavigationItems([\n        Pages\\ViewCustomer::class,\n        Pages\\EditCustomer::class,\n        Pages\\EditCustomerContact::class,\n        Pages\\ManageCustomerAddresses::class,\n        Pages\\ManageCustomerPayments::class,\n    ]);\n}\n```\n\nEach item in the sub-navigation can be customized using the same navigation methods as normal pages.\n\n> If you’re looking to add sub-navigation to switch between entire resources and custom pages, you might be looking for clusters, which are used to group these together. The getRecordSubNavigation() method is intended to construct a navigation between pages that relate to a particular record inside a resource.\n\nIf you’re looking to add sub-navigation to switch between entire resources and custom pages, you might be looking for clusters, which are used to group these together. The getRecordSubNavigation() method is intended to construct a navigation between pages that relate to a particular record inside a resource.\n\n`getRecordSubNavigation()`### #Sub-navigation position\n\nThe sub-navigation is rendered at the start of the page by default. You may change the position by setting the $subNavigationPosition property on the resource. The value may be SubNavigationPosition::Start, SubNavigationPosition::End, or SubNavigationPosition::Top to render the sub-navigation as tabs:\n\n`$subNavigationPosition``SubNavigationPosition::Start``SubNavigationPosition::End``SubNavigationPosition::Top````\nuse Filament\\Pages\\SubNavigationPosition;\n\nprotected static SubNavigationPosition $subNavigationPosition = SubNavigationPosition::End;\n```",
                "level": 3
              },
              {
                "title": "## #Deleting resource pages",
                "content": "If you’d like to delete a page from your resource, you can just delete the page file from the Pages directory of your resource, and its entry in the getPages() method.\n\n`Pages``getPages()`For example, you may have a resource with records that may not be created by anyone. Delete the Create page file, and then remove it from getPages():\n\n`Create``getPages()````\npublic static function getPages(): array\n{\n    return [\n        'index' => Pages\\ListCustomers::route('/'),\n        'edit' => Pages\\EditCustomer::route('/{record}/edit'),\n    ];\n}\n```\n\nDeleting a page will not delete any actions that link to that page. Any actions will open a modal instead of sending the user to the non-existent page. For instance, the CreateAction on the List page, the EditAction on the table or View page, or the ViewAction on the table or Edit page. If you want to remove those buttons, you must delete the actions as well.\n\n`CreateAction``EditAction``ViewAction`Still need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Creating a resource",
              "Handling soft deletes",
              "Generating a View page",
              "Specifiying a custom model namespace",
              "Generating the model, migration and factory at the same name",
              "Record titles",
              "Resource forms",
              "Hiding components based on the current operation",
              "Resource tables"
            ],
            "code_examples_count": 84,
            "has_installation_info": true,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "pages": {
          "metadata": {
            "title": "Pages",
            "url": "https://filamentphp.com/docs/3.x/panels/pages",
            "section": "panels",
            "word_count": 1542,
            "character_count": 11912
          },
          "content": {
            "full_text": "\n# Pages - Panels - Filament\n\nPanels\n\n# Pages\n\n## #Overview\n\nFilament allows you to create completely custom pages for the app.\n\n## #Creating a page\n\nTo create a new page, you can use:\n\n```\nphp artisan make:filament-page Settings\n```\n\nThis command will create two files - a page class in the /Pages directory of the Filament directory, and a view in the /pages directory of the Filament views directory.\n\n`/Pages``/pages`Page classes are all full-page Livewire components with a few extra utilities you can use with the panel.\n\n## #Authorization\n\nYou can prevent pages from appearing in the menu by overriding the canAccess() method in your Page class. This is useful if you want to control which users can see the page in the navigation, and also which users can visit the page directly:\n\n`canAccess()````\npublic static function canAccess(): bool\n{\n    return auth()->user()->canManageSettings();\n}\n```\n\n## #Adding actions to pages\n\nActions are buttons that can perform tasks on the page, or visit a URL. You can read more about their capabilities here.\n\nSince all pages are Livewire components, you can add actions anywhere. Pages already have the InteractsWithActions trait, HasActions interface, and <x-filament-actions::modals /> Blade component all set up for you.\n\n`InteractsWithActions``HasActions``<x-filament-actions::modals />`### #Header actions\n\nYou can also easily add actions to the header of any page, including resource pages. You don’t need to worry about adding anything to the Blade template, we handle that for you. Just return your actions from the getHeaderActions() method of the page class:\n\n`getHeaderActions()````\nuse Filament\\Actions\\Action;\n\nprotected function getHeaderActions(): array\n{\n    return [\n        Action::make('edit')\n            ->url(route('posts.edit', ['post' => $this->post])),\n        Action::make('delete')\n            ->requiresConfirmation()\n            ->action(fn () => $this->post->delete()),\n    ];\n}\n```\n\n### #Opening an action modal when a page loads\n\nYou can also open an action when a page loads by setting the $defaultAction property to the name of the action you want to open:\n\n`$defaultAction````\nuse Filament\\Actions\\Action;\n\npublic $defaultAction = 'onboarding';\n\npublic function onboardingAction(): Action\n{\n    return Action::make('onboarding')\n        ->modalHeading('Welcome')\n        ->visible(fn (): bool => ! auth()->user()->isOnBoarded());\n}\n```\n\nYou can also pass an array of arguments to the default action using the $defaultActionArguments property:\n\n`$defaultActionArguments````\npublic $defaultActionArguments = ['step' => 2];\n```\n\nAlternatively, you can open an action modal when a page loads by specifying the action as a query string parameter to the page:\n\n`action````\n/admin/products/edit/932510?action=onboarding\n```\n\n### #Refreshing form data\n\nIf you’re using actions on an Edit or View resource page, you can refresh data within the main form using the refreshFormData() method:\n\n`refreshFormData()````\nuse App\\Models\\Post;\nuse Filament\\Actions\\Action;\n\nAction::make('approve')\n    ->action(function (Post $record) {\n        $record->approve();\n\n        $this->refreshFormData([\n            'status',\n        ]);\n    })\n```\n\nThis method accepts an array of model attributes that you wish to refresh in the form.\n\n## #Adding widgets to pages\n\nFilament allows you to display widgets inside pages, below the header and above the footer.\n\nTo add a widget to a page, use the getHeaderWidgets() or getFooterWidgets() methods:\n\n`getHeaderWidgets()``getFooterWidgets()````\nuse App\\Filament\\Widgets\\StatsOverviewWidget;\n\nprotected function getHeaderWidgets(): array\n{\n    return [\n        StatsOverviewWidget::class\n    ];\n}\n```\n\ngetHeaderWidgets() returns an array of widgets to display above the page content, whereas getFooterWidgets() are displayed below.\n\n`getHeaderWidgets()``getFooterWidgets()`If you’d like to learn how to build and customize widgets, check out the Dashboard documentation section.\n\n### #Customizing the widgets’ grid\n\nYou may change how many grid columns are used to display widgets.\n\nYou may override the getHeaderWidgetsColumns() or getFooterWidgetsColumns() methods to return a number of grid columns to use:\n\n`getHeaderWidgetsColumns()``getFooterWidgetsColumns()````\npublic function getHeaderWidgetsColumns(): int | array\n{\n    return 3;\n}\n```\n\n#### #Responsive widgets grid\n\nYou may wish to change the number of widget grid columns based on the responsive breakpoint of the browser. You can do this using an array that contains the number of columns that should be used at each breakpoint:\n\n```\npublic function getHeaderWidgetsColumns(): int | array\n{\n    return [\n        'md' => 4,\n        'xl' => 5,\n    ];\n}\n```\n\nThis pairs well with responsive widget widths.\n\n#### #Passing data to widgets from the page\n\nYou may pass data to widgets from the page using the getWidgetsData() method:\n\n`getWidgetsData()````\npublic function getWidgetData(): array\n{\n    return [\n        'stats' => [\n            'total' => 100,\n        ],\n    ];\n}\n```\n\nNow, you can define a corresponding public $stats array property on the widget class, which will be automatically filled:\n\n`$stats````\npublic $stats = [];\n```\n\n### #Passing properties to widgets on pages\n\nWhen registering a widget on a page, you can use the make() method to pass an array of Livewire properties to it:\n\n`make()````\nuse App\\Filament\\Widgets\\StatsOverviewWidget;\n\nprotected function getHeaderWidgets(): array\n{\n    return [\n        StatsOverviewWidget::make([\n            'status' => 'active',\n        ]),\n    ];\n}\n```\n\nThis array of properties gets mapped to public Livewire properties on the widget class:\n\n```\nuse Filament\\Widgets\\Widget;\n\nclass StatsOverviewWidget extends Widget\n{\n    public string $status;\n\n    // ...\n}\n```\n\nNow, you can access the status in the widget class using $this->status.\n\n`status``$this->status`## #Customizing the page title\n\nBy default, Filament will automatically generate a title for your page based on its name. You may override this by defining a $title property on your page class:\n\n`$title````\nprotected static ?string $title = 'Custom Page Title';\n```\n\nAlternatively, you may return a string from the getTitle() method:\n\n`getTitle()````\nuse Illuminate\\Contracts\\Support\\Htmlable;\n\npublic function getTitle(): string | Htmlable\n{\n    return __('Custom Page Title');\n}\n```\n\n## #Customizing the page navigation label\n\nBy default, Filament will use the page’s title as its navigation item label. You may override this by defining a $navigationLabel property on your page class:\n\n`$navigationLabel````\nprotected static ?string $navigationLabel = 'Custom Navigation Label';\n```\n\nAlternatively, you may return a string from the getNavigationLabel() method:\n\n`getNavigationLabel()````\npublic static function getNavigationLabel(): string\n{\n    return __('Custom Navigation Label');\n}\n```\n\n## #Customizing the page URL\n\nBy default, Filament will automatically generate a URL (slug) for your page based on its name. You may override this by defining a $slug property on your page class:\n\n`$slug````\nprotected static ?string $slug = 'custom-url-slug';\n```\n\n## #Customizing the page heading\n\nBy default, Filament will use the page’s title as its heading. You may override this by defining a $heading property on your page class:\n\n`$heading````\nprotected ?string $heading = 'Custom Page Heading';\n```\n\nAlternatively, you may return a string from the getHeading() method:\n\n`getHeading()````\npublic function getHeading(): string\n{\n    return __('Custom Page Heading');\n}\n```\n\n### #Adding a page subheading\n\nYou may also add a subheading to your page by defining a $subheading property on your page class:\n\n`$subheading````\nprotected ?string $subheading = 'Custom Page Subheading';\n```\n\nAlternatively, you may return a string from the getSubheading() method:\n\n`getSubheading()````\npublic function getSubheading(): ?string\n{\n    return __('Custom Page Subheading');\n}\n```\n\n## #Replacing the page header with a custom view\n\nYou may replace the default heading, subheading and actions with a custom header view for any page. You may return it from the getHeader() method:\n\n`getHeader()````\nuse Illuminate\\Contracts\\View\\View;\n\npublic function getHeader(): ?View\n{\n    return view('filament.settings.custom-header');\n}\n```\n\nThis example assumes you have a Blade view at resources/views/filament/settings/custom-header.blade.php.\n\n`resources/views/filament/settings/custom-header.blade.php`## #Rendering a custom view in the footer of the page\n\nYou may also add a footer to any page, below its content. You may return it from the getFooter() method:\n\n`getFooter()````\nuse Illuminate\\Contracts\\View\\View;\n\npublic function getFooter(): ?View\n{\n    return view('filament.settings.custom-footer');\n}\n```\n\nThis example assumes you have a Blade view at resources/views/filament/settings/custom-footer.blade.php.\n\n`resources/views/filament/settings/custom-footer.blade.php`## #Customizing the maximum content width\n\nBy default, Filament will restrict the width of the content on the page, so it doesn’t become too wide on large screens. To change this, you may override the getMaxContentWidth() method. Options correspond to Tailwind’s max-width scale. The options are ExtraSmall, Small, Medium, Large, ExtraLarge, TwoExtraLarge, ThreeExtraLarge, FourExtraLarge, FiveExtraLarge, SixExtraLarge, SevenExtraLarge, Full, MinContent, MaxContent, FitContent,  Prose, ScreenSmall, ScreenMedium, ScreenLarge, ScreenExtraLarge and ScreenTwoExtraLarge. The default is SevenExtraLarge:\n\n`getMaxContentWidth()``ExtraSmall``Small``Medium``Large``ExtraLarge``TwoExtraLarge``ThreeExtraLarge``FourExtraLarge``FiveExtraLarge``SixExtraLarge``SevenExtraLarge``Full``MinContent``MaxContent``FitContent``Prose``ScreenSmall``ScreenMedium``ScreenLarge``ScreenExtraLarge``ScreenTwoExtraLarge``SevenExtraLarge````\nuse Filament\\Support\\Enums\\MaxWidth;\n\npublic function getMaxContentWidth(): MaxWidth\n{\n    return MaxWidth::Full;\n}\n```\n\n## #Generating URLs to pages\n\nFilament provides getUrl() static method on page classes to generate URLs to them. Traditionally, you would need to construct the URL by hand or by using Laravel’s route() helper, but these methods depend on knowledge of the page’s slug or route naming conventions.\n\n`getUrl()``route()`The getUrl() method, without any arguments, will generate a URL:\n\n`getUrl()````\nuse App\\Filament\\Pages\\Settings;\n\nSettings::getUrl(); // /admin/settings\n```\n\nIf your page uses URL / query parameters, you should use the argument:\n\n```\nuse App\\Filament\\Pages\\Settings;\n\nSettings::getUrl(['section' => 'notifications']); // /admin/settings?section=notifications\n```\n\n### #Generating URLs to pages in other panels\n\nIf you have multiple panels in your app, getUrl() will generate a URL within the current panel. You can also indicate which panel the page is associated with, by passing the panel ID to the panel argument:\n\n`getUrl()``panel````\nuse App\\Filament\\Pages\\Settings;\n\nSettings::getUrl(panel: 'marketing');\n```\n\n## #Adding sub-navigation between pages\n\nYou may want to add a common sub-navigation to multiple pages, to allow users to quickly navigate between them. You can do this by defining a cluster. Clusters can also contain resources, and you can switch between multiple pages or resources within a cluster.\n\n## #Adding extra attributes to the body tag of a page\n\nYou may wish to add extra attributes to the <body> tag of a page. To do this, you can set an array of attributes in $extraBodyAttributes:\n\n`<body>``$extraBodyAttributes````\nprotected array $extraBodyAttributes = [];\n```\n\nOr, you can return an array of attributes and their values from the getExtraBodyAttributes() method:\n\n`getExtraBodyAttributes()````\npublic function getExtraBodyAttributes(): array\n{\n    return [\n        'class' => 'settings-page',\n    ];\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Pages - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Pages",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament allows you to create completely custom pages for the app.",
                "level": 3
              },
              {
                "title": "## #Creating a page",
                "content": "To create a new page, you can use:\n\n```\nphp artisan make:filament-page Settings\n```\n\nThis command will create two files - a page class in the /Pages directory of the Filament directory, and a view in the /pages directory of the Filament views directory.\n\n`/Pages``/pages`Page classes are all full-page Livewire components with a few extra utilities you can use with the panel.",
                "level": 3
              },
              {
                "title": "## #Authorization",
                "content": "You can prevent pages from appearing in the menu by overriding the canAccess() method in your Page class. This is useful if you want to control which users can see the page in the navigation, and also which users can visit the page directly:\n\n`canAccess()````\npublic static function canAccess(): bool\n{\n    return auth()->user()->canManageSettings();\n}\n```",
                "level": 3
              },
              {
                "title": "## #Adding actions to pages",
                "content": "Actions are buttons that can perform tasks on the page, or visit a URL. You can read more about their capabilities here.\n\nSince all pages are Livewire components, you can add actions anywhere. Pages already have the InteractsWithActions trait, HasActions interface, and <x-filament-actions::modals /> Blade component all set up for you.\n\n`InteractsWithActions``HasActions``<x-filament-actions::modals />`### #Header actions\n\nYou can also easily add actions to the header of any page, including resource pages. You don’t need to worry about adding anything to the Blade template, we handle that for you. Just return your actions from the getHeaderActions() method of the page class:\n\n`getHeaderActions()````\nuse Filament\\Actions\\Action;\n\nprotected function getHeaderActions(): array\n{\n    return [\n        Action::make('edit')\n            ->url(route('posts.edit', ['post' => $this->post])),\n        Action::make('delete')\n            ->requiresConfirmation()\n            ->action(fn () => $this->post->delete()),\n    ];\n}\n```",
                "level": 3
              },
              {
                "title": "### #Opening an action modal when a page loads",
                "content": "You can also open an action when a page loads by setting the $defaultAction property to the name of the action you want to open:\n\n`$defaultAction````\nuse Filament\\Actions\\Action;\n\npublic $defaultAction = 'onboarding';\n\npublic function onboardingAction(): Action\n{\n    return Action::make('onboarding')\n        ->modalHeading('Welcome')\n        ->visible(fn (): bool => ! auth()->user()->isOnBoarded());\n}\n```\n\nYou can also pass an array of arguments to the default action using the $defaultActionArguments property:\n\n`$defaultActionArguments````\npublic $defaultActionArguments = ['step' => 2];\n```\n\nAlternatively, you can open an action modal when a page loads by specifying the action as a query string parameter to the page:\n\n`action````\n/admin/products/edit/932510?action=onboarding\n```",
                "level": 4
              },
              {
                "title": "### #Refreshing form data",
                "content": "If you’re using actions on an Edit or View resource page, you can refresh data within the main form using the refreshFormData() method:\n\n`refreshFormData()````\nuse App\\Models\\Post;\nuse Filament\\Actions\\Action;\n\nAction::make('approve')\n    ->action(function (Post $record) {\n        $record->approve();\n\n        $this->refreshFormData([\n            'status',\n        ]);\n    })\n```\n\nThis method accepts an array of model attributes that you wish to refresh in the form.",
                "level": 4
              },
              {
                "title": "## #Adding widgets to pages",
                "content": "Filament allows you to display widgets inside pages, below the header and above the footer.\n\nTo add a widget to a page, use the getHeaderWidgets() or getFooterWidgets() methods:\n\n`getHeaderWidgets()``getFooterWidgets()````\nuse App\\Filament\\Widgets\\StatsOverviewWidget;\n\nprotected function getHeaderWidgets(): array\n{\n    return [\n        StatsOverviewWidget::class\n    ];\n}\n```\n\ngetHeaderWidgets() returns an array of widgets to display above the page content, whereas getFooterWidgets() are displayed below.\n\n`getHeaderWidgets()``getFooterWidgets()`If you’d like to learn how to build and customize widgets, check out the Dashboard documentation section.",
                "level": 3
              },
              {
                "title": "### #Customizing the widgets’ grid",
                "content": "You may change how many grid columns are used to display widgets.\n\nYou may override the getHeaderWidgetsColumns() or getFooterWidgetsColumns() methods to return a number of grid columns to use:\n\n`getHeaderWidgetsColumns()``getFooterWidgetsColumns()````\npublic function getHeaderWidgetsColumns(): int | array\n{\n    return 3;\n}\n```",
                "level": 4
              },
              {
                "title": "#### #Responsive widgets grid",
                "content": "You may wish to change the number of widget grid columns based on the responsive breakpoint of the browser. You can do this using an array that contains the number of columns that should be used at each breakpoint:\n\n```\npublic function getHeaderWidgetsColumns(): int | array\n{\n    return [\n        'md' => 4,\n        'xl' => 5,\n    ];\n}\n```\n\nThis pairs well with responsive widget widths.",
                "level": 5
              },
              {
                "title": "#### #Passing data to widgets from the page",
                "content": "You may pass data to widgets from the page using the getWidgetsData() method:\n\n`getWidgetsData()````\npublic function getWidgetData(): array\n{\n    return [\n        'stats' => [\n            'total' => 100,\n        ],\n    ];\n}\n```\n\nNow, you can define a corresponding public $stats array property on the widget class, which will be automatically filled:\n\n`$stats````\npublic $stats = [];\n```",
                "level": 5
              },
              {
                "title": "### #Passing properties to widgets on pages",
                "content": "When registering a widget on a page, you can use the make() method to pass an array of Livewire properties to it:\n\n`make()````\nuse App\\Filament\\Widgets\\StatsOverviewWidget;\n\nprotected function getHeaderWidgets(): array\n{\n    return [\n        StatsOverviewWidget::make([\n            'status' => 'active',\n        ]),\n    ];\n}\n```\n\nThis array of properties gets mapped to public Livewire properties on the widget class:\n\n```\nuse Filament\\Widgets\\Widget;\n\nclass StatsOverviewWidget extends Widget\n{\n    public string $status;\n\n    // ...\n}\n```\n\nNow, you can access the status in the widget class using $this->status.\n\n`status``$this->status`## #Customizing the page title\n\nBy default, Filament will automatically generate a title for your page based on its name. You may override this by defining a $title property on your page class:\n\n`$title````\nprotected static ?string $title = 'Custom Page Title';\n```\n\nAlternatively, you may return a string from the getTitle() method:\n\n`getTitle()````\nuse Illuminate\\Contracts\\Support\\Htmlable;\n\npublic function getTitle(): string | Htmlable\n{\n    return __('Custom Page Title');\n}\n```",
                "level": 4
              },
              {
                "title": "## #Customizing the page navigation label",
                "content": "By default, Filament will use the page’s title as its navigation item label. You may override this by defining a $navigationLabel property on your page class:\n\n`$navigationLabel````\nprotected static ?string $navigationLabel = 'Custom Navigation Label';\n```\n\nAlternatively, you may return a string from the getNavigationLabel() method:\n\n`getNavigationLabel()````\npublic static function getNavigationLabel(): string\n{\n    return __('Custom Navigation Label');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the page URL",
                "content": "By default, Filament will automatically generate a URL (slug) for your page based on its name. You may override this by defining a $slug property on your page class:\n\n`$slug````\nprotected static ?string $slug = 'custom-url-slug';\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the page heading",
                "content": "By default, Filament will use the page’s title as its heading. You may override this by defining a $heading property on your page class:\n\n`$heading````\nprotected ?string $heading = 'Custom Page Heading';\n```\n\nAlternatively, you may return a string from the getHeading() method:\n\n`getHeading()````\npublic function getHeading(): string\n{\n    return __('Custom Page Heading');\n}\n```",
                "level": 3
              },
              {
                "title": "### #Adding a page subheading",
                "content": "You may also add a subheading to your page by defining a $subheading property on your page class:\n\n`$subheading````\nprotected ?string $subheading = 'Custom Page Subheading';\n```\n\nAlternatively, you may return a string from the getSubheading() method:\n\n`getSubheading()````\npublic function getSubheading(): ?string\n{\n    return __('Custom Page Subheading');\n}\n```",
                "level": 4
              },
              {
                "title": "## #Replacing the page header with a custom view",
                "content": "You may replace the default heading, subheading and actions with a custom header view for any page. You may return it from the getHeader() method:\n\n`getHeader()````\nuse Illuminate\\Contracts\\View\\View;\n\npublic function getHeader(): ?View\n{\n    return view('filament.settings.custom-header');\n}\n```\n\nThis example assumes you have a Blade view at resources/views/filament/settings/custom-header.blade.php.\n\n`resources/views/filament/settings/custom-header.blade.php`## #Rendering a custom view in the footer of the page\n\nYou may also add a footer to any page, below its content. You may return it from the getFooter() method:\n\n`getFooter()````\nuse Illuminate\\Contracts\\View\\View;\n\npublic function getFooter(): ?View\n{\n    return view('filament.settings.custom-footer');\n}\n```\n\nThis example assumes you have a Blade view at resources/views/filament/settings/custom-footer.blade.php.\n\n`resources/views/filament/settings/custom-footer.blade.php`## #Customizing the maximum content width\n\nBy default, Filament will restrict the width of the content on the page, so it doesn’t become too wide on large screens. To change this, you may override the getMaxContentWidth() method. Options correspond to Tailwind’s max-width scale. The options are ExtraSmall, Small, Medium, Large, ExtraLarge, TwoExtraLarge, ThreeExtraLarge, FourExtraLarge, FiveExtraLarge, SixExtraLarge, SevenExtraLarge, Full, MinContent, MaxContent, FitContent,  Prose, ScreenSmall, ScreenMedium, ScreenLarge, ScreenExtraLarge and ScreenTwoExtraLarge. The default is SevenExtraLarge:\n\n`getMaxContentWidth()``ExtraSmall``Small``Medium``Large``ExtraLarge``TwoExtraLarge``ThreeExtraLarge``FourExtraLarge``FiveExtraLarge``SixExtraLarge``SevenExtraLarge``Full``MinContent``MaxContent``FitContent``Prose``ScreenSmall``ScreenMedium``ScreenLarge``ScreenExtraLarge``ScreenTwoExtraLarge``SevenExtraLarge````\nuse Filament\\Support\\Enums\\MaxWidth;\n\npublic function getMaxContentWidth(): MaxWidth\n{\n    return MaxWidth::Full;\n}\n```",
                "level": 3
              },
              {
                "title": "## #Generating URLs to pages",
                "content": "Filament provides getUrl() static method on page classes to generate URLs to them. Traditionally, you would need to construct the URL by hand or by using Laravel’s route() helper, but these methods depend on knowledge of the page’s slug or route naming conventions.\n\n`getUrl()``route()`The getUrl() method, without any arguments, will generate a URL:\n\n`getUrl()````\nuse App\\Filament\\Pages\\Settings;\n\nSettings::getUrl(); // /admin/settings\n```\n\nIf your page uses URL / query parameters, you should use the argument:\n\n```\nuse App\\Filament\\Pages\\Settings;\n\nSettings::getUrl(['section' => 'notifications']); // /admin/settings?section=notifications\n```",
                "level": 3
              },
              {
                "title": "### #Generating URLs to pages in other panels",
                "content": "If you have multiple panels in your app, getUrl() will generate a URL within the current panel. You can also indicate which panel the page is associated with, by passing the panel ID to the panel argument:\n\n`getUrl()``panel````\nuse App\\Filament\\Pages\\Settings;\n\nSettings::getUrl(panel: 'marketing');\n```",
                "level": 4
              },
              {
                "title": "## #Adding sub-navigation between pages",
                "content": "You may want to add a common sub-navigation to multiple pages, to allow users to quickly navigate between them. You can do this by defining a cluster. Clusters can also contain resources, and you can switch between multiple pages or resources within a cluster.",
                "level": 3
              },
              {
                "title": "## #Adding extra attributes to the body tag of a page",
                "content": "You may wish to add extra attributes to the <body> tag of a page. To do this, you can set an array of attributes in $extraBodyAttributes:\n\n`<body>``$extraBodyAttributes````\nprotected array $extraBodyAttributes = [];\n```\n\nOr, you can return an array of attributes and their values from the getExtraBodyAttributes() method:\n\n`getExtraBodyAttributes()````\npublic function getExtraBodyAttributes(): array\n{\n    return [\n        'class' => 'settings-page',\n    ];\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Creating a page",
              "Authorization",
              "Adding actions to pages",
              "Opening an action modal when a page loads",
              "Refreshing form data",
              "Adding widgets to pages",
              "Customizing the widgets’ grid",
              "Passing properties to widgets on pages",
              "Customizing the page navigation label"
            ],
            "code_examples_count": 62,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "dashboard": {
          "metadata": {
            "title": "Dashboard",
            "url": "https://filamentphp.com/docs/3.x/panels/dashboard",
            "section": "panels",
            "word_count": 1373,
            "character_count": 10509
          },
          "content": {
            "full_text": "\n# Dashboard - Panels - Filament\n\nPanels\n\n# Dashboard\n\n## #Overview\n\nFilament allows you to build dynamic dashboards, comprised of “widgets”, very easily.\n\nThe following document will explain how to use these widgets to assemble a dashboard using the panel.\n\n## #Available widgets\n\nFilament ships with these widgets:\n\n- Stats overview widgets display any data, often numeric data, as stats in a row.\n- Chart widgets display numeric data in a visual chart.\n- Table widgets which display a table on your dashboard.\n\nYou may also create your own custom widgets which can then have a consistent design with Filament’s prebuilt widgets.\n\n## #Sorting widgets\n\nEach widget class contains a $sort property that may be used to change its order on the page, relative to other widgets:\n\n`$sort````\nprotected static ?int $sort = 2;\n```\n\n## #Customizing widget width\n\nYou may customize the width of a widget using the $columnSpan property. You may use a number between 1 and 12 to indicate how many columns the widget should span, or full to make it occupy the full width of the page:\n\n`$columnSpan``full````\nprotected int | string | array $columnSpan = 'full';\n```\n\n### #Responsive widget widths\n\nYou may wish to change the widget width based on the responsive breakpoint of the browser. You can do this using an array that contains the number of columns that the widget should occupy at each breakpoint:\n\n```\nprotected int | string | array $columnSpan = [\n    'md' => 2,\n    'xl' => 3,\n];\n```\n\nThis is especially useful when using a responsive widgets grid.\n\n## #Customizing the widgets’ grid\n\nYou may change how many grid columns are used to display widgets.\n\nFirstly, you must replace the original Dashboard page.\n\nNow, in your new app/Filament/Pages/Dashboard.php file, you may override the getColumns() method to return a number of grid columns to use:\n\n`app/Filament/Pages/Dashboard.php``getColumns()````\npublic function getColumns(): int | string | array\n{\n    return 2;\n}\n```\n\n### #Responsive widgets grid\n\nYou may wish to change the number of widget grid columns based on the responsive breakpoint of the browser. You can do this using an array that contains the number of columns that should be used at each breakpoint:\n\n```\npublic function getColumns(): int | string | array\n{\n    return [\n        'md' => 4,\n        'xl' => 5,\n    ];\n}\n```\n\nThis pairs well with responsive widget widths.\n\n## #Conditionally hiding widgets\n\nYou may override the static canView() method on widgets to conditionally hide them:\n\n`canView()````\npublic static function canView(): bool\n{\n    return auth()->user()->isAdmin();\n}\n```\n\n## #Table widgets\n\nYou may easily add tables to your dashboard. Start by creating a widget with the command:\n\n```\nphp artisan make:filament-widget LatestOrders --table\n```\n\nYou may now customize the table by editing the widget file.\n\n## #Custom widgets\n\nTo get started building a BlogPostsOverview widget:\n\n`BlogPostsOverview````\nphp artisan make:filament-widget BlogPostsOverview\n```\n\nThis command will create two files - a widget class in the /Widgets directory of the Filament directory, and a view in the /widgets directory of the Filament views directory.\n\n`/Widgets``/widgets`## #Filtering widget data\n\nYou may add a form to the dashboard that allows the user to filter the data displayed across all widgets. When the filters are updated, the widgets will be reloaded with the new data.\n\nFirstly, you must replace the original Dashboard page.\n\nNow, in your new app/Filament/Pages/Dashboard.php file, you may add the HasFiltersForm trait, and add the filtersForm() method to return form components:\n\n`app/Filament/Pages/Dashboard.php``HasFiltersForm``filtersForm()````\nuse Filament\\Forms\\Components\\DatePicker;\nuse Filament\\Forms\\Components\\Section;\nuse Filament\\Forms\\Form;\nuse Filament\\Pages\\Dashboard as BaseDashboard;\nuse Filament\\Pages\\Dashboard\\Concerns\\HasFiltersForm;\n\nclass Dashboard extends BaseDashboard\n{\n    use HasFiltersForm;\n\n    public function filtersForm(Form $form): Form\n    {\n        return $form\n            ->schema([\n                Section::make()\n                    ->schema([\n                        DatePicker::make('startDate'),\n                        DatePicker::make('endDate'),\n                        // ...\n                    ])\n                    ->columns(3),\n            ]);\n    }\n}\n```\n\nIn widget classes that require data from the filters, you need to add the InteractsWithPageFilters trait, which will allow you to use the $this->filters property to access the raw data from the filters form:\n\n`InteractsWithPageFilters``$this->filters````\nuse App\\Models\\BlogPost;\nuse Carbon\\CarbonImmutable;\nuse Filament\\Widgets\\StatsOverviewWidget;\nuse Filament\\Widgets\\Concerns\\InteractsWithPageFilters;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nclass BlogPostsOverview extends StatsOverviewWidget\n{\n    use InteractsWithPageFilters;\n\n    public function getStats(): array\n    {\n        $startDate = $this->filters['startDate'] ?? null;\n        $endDate = $this->filters['endDate'] ?? null;\n\n        return [\n            StatsOverviewWidget\\Stat::make(\n                label: 'Total posts',\n                value: BlogPost::query()\n                    ->when($startDate, fn (Builder $query) => $query->whereDate('created_at', '>=', $startDate))\n                    ->when($endDate, fn (Builder $query) => $query->whereDate('created_at', '<=', $endDate))\n                    ->count(),\n            ),\n            // ...\n        ];\n    }\n}\n```\n\nThe $this->filters array will always reflect the current form data. Please note that this data is not validated, as it is available live and not intended to be used for anything other than querying the database. You must ensure that the data is valid before using it. In this example, we check if the start date is set before using it in the query.\n\n`$this->filters`### #Filtering widget data using an action modal\n\nAlternatively, you can swap out the filters form for an action modal, that can be opened by clicking a button in the header of the page. There are many benefits to using this approach:\n\n- The filters form is not always visible, which allows you to use the full height of the page for widgets.\n- The filters do not update the widgets until the user clicks the “Apply” button, which means that the widgets are not reloaded until the user is ready. This can improve performance if the widgets are expensive to load.\n- Validation can be performed on the filters form, which means that the widgets can rely on the fact that the data is valid - the user cannot submit the form until it is. Canceling the modal will discard the user’s changes.\n\nTo use an action modal instead of a filters form, you can use the HasFiltersAction trait instead of HasFiltersForm. Then, register the FilterAction class as an action in getHeaderActions():\n\n`HasFiltersAction``HasFiltersForm``FilterAction``getHeaderActions()````\nuse Filament\\Forms\\Components\\DatePicker;\nuse Filament\\Forms\\Form;\nuse Filament\\Pages\\Dashboard as BaseDashboard;\nuse Filament\\Pages\\Dashboard\\Actions\\FilterAction;\nuse Filament\\Pages\\Dashboard\\Concerns\\HasFiltersAction;\n\nclass Dashboard extends BaseDashboard\n{\n    use HasFiltersAction;\n    \n    protected function getHeaderActions(): array\n    {\n        return [\n            FilterAction::make()\n                ->form([\n                    DatePicker::make('startDate'),\n                    DatePicker::make('endDate'),\n                    // ...\n                ]),\n        ];\n    }\n}\n```\n\nHandling data from the filter action is the same as handling data from the filters header form, except that the data is validated before being passed to the widget. The InteractsWithPageFilters trait still applies.\n\n`InteractsWithPageFilters`### #Persisting widget filters in the user’s session\n\nBy default, the dashboard filters applied will persist in the user’s session between page loads. To disable this, override the $persistsFiltersInSession property in the dashboard page class:\n\n`$persistsFiltersInSession````\nuse Filament\\Pages\\Dashboard as BaseDashboard;\nuse Filament\\Pages\\Dashboard\\Concerns\\HasFiltersForm;\n\nclass Dashboard extends BaseDashboard\n{\n    use HasFiltersForm;\n\n    protected bool $persistsFiltersInSession = false;\n}\n```\n\nAlternatively, override the persistsFiltersInSession() method in the dashboard page class:\n\n`persistsFiltersInSession()````\nuse Filament\\Pages\\Dashboard as BaseDashboard;\nuse Filament\\Pages\\Dashboard\\Concerns\\HasFiltersForm;\n\nclass Dashboard extends BaseDashboard\n{\n    use HasFiltersForm;\n\n    public function persistsFiltersInSession(): bool\n    {\n        return false;\n    }\n}\n```\n\n## #Disabling the default widgets\n\nBy default, two widgets are displayed on the dashboard. These widgets can be disabled by updating the widgets() array of the configuration:\n\n`widgets()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->widgets([]);\n}\n```\n\n## #Customizing the dashboard page\n\nIf you want to customize the dashboard class, for example, to change the number of widget columns, create a new file at app/Filament/Pages/Dashboard.php:\n\n`app/Filament/Pages/Dashboard.php````\n<?php\n\nnamespace App\\Filament\\Pages;\n\nclass Dashboard extends \\Filament\\Pages\\Dashboard\n{\n    // ...\n}\n```\n\nFinally, remove the original Dashboard class from configuration file:\n\n`Dashboard````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->pages([]);\n}\n```\n\n### #Creating multiple dashboards\n\nIf you want to create multiple dashboards, you can do so by repeating the process described above. Creating new pages that extend the Dashboard class will allow you to create as many dashboards as you need.\n\n`Dashboard`You will also need to define the URL path to the extra dashboard, otherwise it will be at /:\n\n`/````\nprotected static string $routePath = 'finance';\n```\n\nYou may also customize the title of the dashboard by overriding the $title property:\n\n`$title````\nprotected static ?string $title = 'Finance dashboard';\n```\n\nThe primary dashboard shown to a user is the first one they have access to (controlled by canAccess() method), according to the defined navigation sort order.\n\n`canAccess()`The default sort order for dashboards is -2. You can control the sort order of custom dashboards with $navigationSort:\n\n`-2``$navigationSort````\nprotected static ?int $navigationSort = 15;\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Dashboard - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Dashboard",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament allows you to build dynamic dashboards, comprised of “widgets”, very easily.\n\nThe following document will explain how to use these widgets to assemble a dashboard using the panel.",
                "level": 3
              },
              {
                "title": "## #Available widgets",
                "content": "Filament ships with these widgets:\n\n- Stats overview widgets display any data, often numeric data, as stats in a row.\n- Chart widgets display numeric data in a visual chart.\n- Table widgets which display a table on your dashboard.\n\nYou may also create your own custom widgets which can then have a consistent design with Filament’s prebuilt widgets.",
                "level": 3
              },
              {
                "title": "## #Sorting widgets",
                "content": "Each widget class contains a $sort property that may be used to change its order on the page, relative to other widgets:\n\n`$sort````\nprotected static ?int $sort = 2;\n```",
                "level": 3
              },
              {
                "title": "## #Customizing widget width",
                "content": "You may customize the width of a widget using the $columnSpan property. You may use a number between 1 and 12 to indicate how many columns the widget should span, or full to make it occupy the full width of the page:\n\n`$columnSpan``full````\nprotected int | string | array $columnSpan = 'full';\n```",
                "level": 3
              },
              {
                "title": "### #Responsive widget widths",
                "content": "You may wish to change the widget width based on the responsive breakpoint of the browser. You can do this using an array that contains the number of columns that the widget should occupy at each breakpoint:\n\n```\nprotected int | string | array $columnSpan = [\n    'md' => 2,\n    'xl' => 3,\n];\n```\n\nThis is especially useful when using a responsive widgets grid.",
                "level": 4
              },
              {
                "title": "## #Customizing the widgets’ grid",
                "content": "You may change how many grid columns are used to display widgets.\n\nFirstly, you must replace the original Dashboard page.\n\nNow, in your new app/Filament/Pages/Dashboard.php file, you may override the getColumns() method to return a number of grid columns to use:\n\n`app/Filament/Pages/Dashboard.php``getColumns()````\npublic function getColumns(): int | string | array\n{\n    return 2;\n}\n```",
                "level": 3
              },
              {
                "title": "### #Responsive widgets grid",
                "content": "You may wish to change the number of widget grid columns based on the responsive breakpoint of the browser. You can do this using an array that contains the number of columns that should be used at each breakpoint:\n\n```\npublic function getColumns(): int | string | array\n{\n    return [\n        'md' => 4,\n        'xl' => 5,\n    ];\n}\n```\n\nThis pairs well with responsive widget widths.",
                "level": 4
              },
              {
                "title": "## #Conditionally hiding widgets",
                "content": "You may override the static canView() method on widgets to conditionally hide them:\n\n`canView()````\npublic static function canView(): bool\n{\n    return auth()->user()->isAdmin();\n}\n```",
                "level": 3
              },
              {
                "title": "## #Table widgets",
                "content": "You may easily add tables to your dashboard. Start by creating a widget with the command:\n\n```\nphp artisan make:filament-widget LatestOrders --table\n```\n\nYou may now customize the table by editing the widget file.",
                "level": 3
              },
              {
                "title": "## #Custom widgets",
                "content": "To get started building a BlogPostsOverview widget:\n\n`BlogPostsOverview````\nphp artisan make:filament-widget BlogPostsOverview\n```\n\nThis command will create two files - a widget class in the /Widgets directory of the Filament directory, and a view in the /widgets directory of the Filament views directory.\n\n`/Widgets``/widgets`## #Filtering widget data\n\nYou may add a form to the dashboard that allows the user to filter the data displayed across all widgets. When the filters are updated, the widgets will be reloaded with the new data.\n\nFirstly, you must replace the original Dashboard page.\n\nNow, in your new app/Filament/Pages/Dashboard.php file, you may add the HasFiltersForm trait, and add the filtersForm() method to return form components:\n\n`app/Filament/Pages/Dashboard.php``HasFiltersForm``filtersForm()````\nuse Filament\\Forms\\Components\\DatePicker;\nuse Filament\\Forms\\Components\\Section;\nuse Filament\\Forms\\Form;\nuse Filament\\Pages\\Dashboard as BaseDashboard;\nuse Filament\\Pages\\Dashboard\\Concerns\\HasFiltersForm;\n\nclass Dashboard extends BaseDashboard\n{\n    use HasFiltersForm;\n\n    public function filtersForm(Form $form): Form\n    {\n        return $form\n            ->schema([\n                Section::make()\n                    ->schema([\n                        DatePicker::make('startDate'),\n                        DatePicker::make('endDate'),\n                        // ...\n                    ])\n                    ->columns(3),\n            ]);\n    }\n}\n```\n\nIn widget classes that require data from the filters, you need to add the InteractsWithPageFilters trait, which will allow you to use the $this->filters property to access the raw data from the filters form:\n\n`InteractsWithPageFilters``$this->filters````\nuse App\\Models\\BlogPost;\nuse Carbon\\CarbonImmutable;\nuse Filament\\Widgets\\StatsOverviewWidget;\nuse Filament\\Widgets\\Concerns\\InteractsWithPageFilters;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nclass BlogPostsOverview extends StatsOverviewWidget\n{\n    use InteractsWithPageFilters;\n\n    public function getStats(): array\n    {\n        $startDate = $this->filters['startDate'] ?? null;\n        $endDate = $this->filters['endDate'] ?? null;\n\n        return [\n            StatsOverviewWidget\\Stat::make(\n                label: 'Total posts',\n                value: BlogPost::query()\n                    ->when($startDate, fn (Builder $query) => $query->whereDate('created_at', '>=', $startDate))\n                    ->when($endDate, fn (Builder $query) => $query->whereDate('created_at', '<=', $endDate))\n                    ->count(),\n            ),\n            // ...\n        ];\n    }\n}\n```\n\nThe $this->filters array will always reflect the current form data. Please note that this data is not validated, as it is available live and not intended to be used for anything other than querying the database. You must ensure that the data is valid before using it. In this example, we check if the start date is set before using it in the query.\n\n`$this->filters`### #Filtering widget data using an action modal\n\nAlternatively, you can swap out the filters form for an action modal, that can be opened by clicking a button in the header of the page. There are many benefits to using this approach:\n\n- The filters form is not always visible, which allows you to use the full height of the page for widgets.\n- The filters do not update the widgets until the user clicks the “Apply” button, which means that the widgets are not reloaded until the user is ready. This can improve performance if the widgets are expensive to load.\n- Validation can be performed on the filters form, which means that the widgets can rely on the fact that the data is valid - the user cannot submit the form until it is. Canceling the modal will discard the user’s changes.\n\nTo use an action modal instead of a filters form, you can use the HasFiltersAction trait instead of HasFiltersForm. Then, register the FilterAction class as an action in getHeaderActions():\n\n`HasFiltersAction``HasFiltersForm``FilterAction``getHeaderActions()````\nuse Filament\\Forms\\Components\\DatePicker;\nuse Filament\\Forms\\Form;\nuse Filament\\Pages\\Dashboard as BaseDashboard;\nuse Filament\\Pages\\Dashboard\\Actions\\FilterAction;\nuse Filament\\Pages\\Dashboard\\Concerns\\HasFiltersAction;\n\nclass Dashboard extends BaseDashboard\n{\n    use HasFiltersAction;\n    \n    protected function getHeaderActions(): array\n    {\n        return [\n            FilterAction::make()\n                ->form([\n                    DatePicker::make('startDate'),\n                    DatePicker::make('endDate'),\n                    // ...\n                ]),\n        ];\n    }\n}\n```\n\nHandling data from the filter action is the same as handling data from the filters header form, except that the data is validated before being passed to the widget. The InteractsWithPageFilters trait still applies.\n\n`InteractsWithPageFilters`### #Persisting widget filters in the user’s session\n\nBy default, the dashboard filters applied will persist in the user’s session between page loads. To disable this, override the $persistsFiltersInSession property in the dashboard page class:\n\n`$persistsFiltersInSession````\nuse Filament\\Pages\\Dashboard as BaseDashboard;\nuse Filament\\Pages\\Dashboard\\Concerns\\HasFiltersForm;\n\nclass Dashboard extends BaseDashboard\n{\n    use HasFiltersForm;\n\n    protected bool $persistsFiltersInSession = false;\n}\n```\n\nAlternatively, override the persistsFiltersInSession() method in the dashboard page class:\n\n`persistsFiltersInSession()````\nuse Filament\\Pages\\Dashboard as BaseDashboard;\nuse Filament\\Pages\\Dashboard\\Concerns\\HasFiltersForm;\n\nclass Dashboard extends BaseDashboard\n{\n    use HasFiltersForm;\n\n    public function persistsFiltersInSession(): bool\n    {\n        return false;\n    }\n}\n```",
                "level": 3
              },
              {
                "title": "## #Disabling the default widgets",
                "content": "By default, two widgets are displayed on the dashboard. These widgets can be disabled by updating the widgets() array of the configuration:\n\n`widgets()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->widgets([]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the dashboard page",
                "content": "If you want to customize the dashboard class, for example, to change the number of widget columns, create a new file at app/Filament/Pages/Dashboard.php:\n\n`app/Filament/Pages/Dashboard.php````\n<?php\n\nnamespace App\\Filament\\Pages;\n\nclass Dashboard extends \\Filament\\Pages\\Dashboard\n{\n    // ...\n}\n```\n\nFinally, remove the original Dashboard class from configuration file:\n\n`Dashboard````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->pages([]);\n}\n```",
                "level": 3
              },
              {
                "title": "### #Creating multiple dashboards",
                "content": "If you want to create multiple dashboards, you can do so by repeating the process described above. Creating new pages that extend the Dashboard class will allow you to create as many dashboards as you need.\n\n`Dashboard`You will also need to define the URL path to the extra dashboard, otherwise it will be at /:\n\n`/````\nprotected static string $routePath = 'finance';\n```\n\nYou may also customize the title of the dashboard by overriding the $title property:\n\n`$title````\nprotected static ?string $title = 'Finance dashboard';\n```\n\nThe primary dashboard shown to a user is the first one they have access to (controlled by canAccess() method), according to the defined navigation sort order.\n\n`canAccess()`The default sort order for dashboards is -2. You can control the sort order of custom dashboards with $navigationSort:\n\n`-2``$navigationSort````\nprotected static ?int $navigationSort = 15;\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Available widgets",
              "Sorting widgets",
              "Customizing widget width",
              "Responsive widget widths",
              "Customizing the widgets’ grid",
              "Responsive widgets grid",
              "Conditionally hiding widgets",
              "Table widgets",
              "Custom widgets"
            ],
            "code_examples_count": 38,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "navigation": {
          "metadata": {
            "title": "Navigation",
            "url": "https://filamentphp.com/docs/3.x/panels/navigation",
            "section": "panels",
            "word_count": 2119,
            "character_count": 18199
          },
          "content": {
            "full_text": "\n# Navigation - Panels - Filament\n\nPanels\n\n# Navigation\n\n## #Overview\n\nBy default, Filament will register navigation items for each of your resources, custom pages, and clusters. These classes contain static properties and methods that you can override, to configure that navigation item.\n\nIf you’re looking to add a second layer of navigation to your app, you can use clusters. These are useful for grouping resources and pages together.\n\n## #Customizing a navigation item’s label\n\nBy default, the navigation label is generated from the resource or page’s name. You may customize this using the $navigationLabel property:\n\n`$navigationLabel````\nprotected static ?string $navigationLabel = 'Custom Navigation Label';\n```\n\nAlternatively, you may override the getNavigationLabel() method:\n\n`getNavigationLabel()````\npublic static function getNavigationLabel(): string\n{\n    return 'Custom Navigation Label';\n}\n```\n\n## #Customizing a navigation item’s icon\n\nTo customize a navigation item’s icon, you may override the $navigationIcon property on the resource or page class:\n\n`$navigationIcon````\nprotected static ?string $navigationIcon = 'heroicon-o-document-text';\n```\n\nIf you set $navigationIcon = null on all items within the same navigation group, those items will be joined with a vertical bar below the group label.\n\n`$navigationIcon = null`### #Switching navigation item icon when it is active\n\nYou may assign a navigation icon which will only be used for active items using the $activeNavigationIcon property:\n\n`$activeNavigationIcon````\nprotected static ?string $activeNavigationIcon = 'heroicon-o-document-text';\n```\n\n## #Sorting navigation items\n\nBy default, navigation items are sorted alphabetically. You may customize this using the $navigationSort property:\n\n`$navigationSort````\nprotected static ?int $navigationSort = 3;\n```\n\nNow, navigation items with a lower sort value will appear before those with a higher sort value - the order is ascending.\n\n## #Adding a badge to a navigation item\n\nTo add a badge next to the navigation item, you can use the getNavigationBadge() method and return the content of the badge:\n\n`getNavigationBadge()````\npublic static function getNavigationBadge(): ?string\n{\n    return static::getModel()::count();\n}\n```\n\nIf a badge value is returned by getNavigationBadge(), it will display using the primary color by default. To style the badge contextually, return either danger, gray, info, primary, success or warning from the getNavigationBadgeColor() method:\n\n`getNavigationBadge()``danger``gray``info``primary``success``warning``getNavigationBadgeColor()````\npublic static function getNavigationBadgeColor(): ?string\n{\n    return static::getModel()::count() > 10 ? 'warning' : 'primary';\n}\n```\n\nA custom tooltip for the navigation badge can be set in $navigationBadgeTooltip:\n\n`$navigationBadgeTooltip````\nprotected static ?string $navigationBadgeTooltip = 'The number of users';\n```\n\nOr it can be returned from getNavigationBadgeTooltip():\n\n`getNavigationBadgeTooltip()````\npublic static function getNavigationBadgeTooltip(): ?string\n{\n    return 'The number of users';\n}\n```\n\n## #Grouping navigation items\n\nYou may group navigation items by specifying a $navigationGroup property on a resource and custom page:\n\n`$navigationGroup````\nprotected static ?string $navigationGroup = 'Settings';\n```\n\nAll items in the same navigation group will be displayed together under the same group label, “Settings” in this case. Ungrouped items will remain at the start of the navigation.\n\n### #Grouping navigation items under other items\n\nYou may group navigation items as children of other items, by passing the label of the parent item as the $navigationParentItem:\n\n`$navigationParentItem````\nprotected static ?string $navigationParentItem = 'Notifications';\n\nprotected static ?string $navigationGroup = 'Settings';\n```\n\nYou may also use the getNavigationParentItem() method to set a dynamic parent item label:\n\n`getNavigationParentItem()````\npublic static function getNavigationParentItem(): ?string\n{\n    return __('filament/navigation.groups.settings.items.notifications');\n}\n```\n\nAs seen above, if the parent item has a navigation group, that navigation group must also be defined, so the correct parent item can be identified.\n\n> If you’re reaching for a third level of navigation like this, you should consider using clusters instead, which are a logical grouping of resources and custom pages, which can share their own separate navigation.\n\nIf you’re reaching for a third level of navigation like this, you should consider using clusters instead, which are a logical grouping of resources and custom pages, which can share their own separate navigation.\n\n### #Customizing navigation groups\n\nYou may customize navigation groups by calling navigationGroups() in the configuration, and passing NavigationGroup objects in order:\n\n`navigationGroups()``NavigationGroup````\nuse Filament\\Navigation\\NavigationGroup;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->navigationGroups([\n            NavigationGroup::make()\n                 ->label('Shop')\n                 ->icon('heroicon-o-shopping-cart'),\n            NavigationGroup::make()\n                ->label('Blog')\n                ->icon('heroicon-o-pencil'),\n            NavigationGroup::make()\n                ->label(fn (): string => __('navigation.settings'))\n                ->icon('heroicon-o-cog-6-tooth')\n                ->collapsed(),\n        ]);\n}\n```\n\nIn this example, we pass in a custom icon() for the groups, and make one collapsed() by default.\n\n`icon()``collapsed()`#### #Ordering navigation groups\n\nBy using navigationGroups(), you are defining a new order for the navigation groups. If you just want to reorder the groups and not define an entire NavigationGroup object, you may just pass the labels of the groups in the new order:\n\n`navigationGroups()``NavigationGroup````\n$panel\n    ->navigationGroups([\n        'Shop',\n        'Blog',\n        'Settings',\n    ])\n```\n\n#### #Making navigation groups not collapsible\n\nBy default, navigation groups are collapsible.\n\nYou may disable this behavior by calling collapsible(false) on the NavigationGroup object:\n\n`collapsible(false)``NavigationGroup````\nuse Filament\\Navigation\\NavigationGroup;\n\nNavigationGroup::make()\n    ->label('Settings')\n    ->icon('heroicon-o-cog-6-tooth')\n    ->collapsible(false);\n```\n\nOr, you can do it globally for all groups in the configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->collapsibleNavigationGroups(false);\n}\n```\n\n#### #Adding extra HTML attributes to navigation groups\n\nYou can pass extra HTML attributes to the navigation group, which will be merged onto the outer DOM element. Pass an array of attributes to the extraSidebarAttributes() or extraTopbarAttributes() method, where the key is the attribute name and the value is the attribute value:\n\n`extraSidebarAttributes()``extraTopbarAttributes()````\nNavigationGroup::make()\n    ->extraSidebarAttributes(['class' => 'featured-sidebar-group']),\n    ->extraTopbarAttributes(['class' => 'featured-topbar-group']),\n```\n\nThe extraSidebarAttributes() will be applied to navigation group elements contained in the sidebar, and the extraTopbarAttributes() will only be applied to topbar navigation group dropdowns when using top navigation.\n\n`extraSidebarAttributes()``extraTopbarAttributes()`## #Collapsible sidebar on desktop\n\nTo make the sidebar collapsible on desktop as well as mobile, you can use the configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->sidebarCollapsibleOnDesktop();\n}\n```\n\nBy default, when you collapse the sidebar on desktop, the navigation icons still show. You can fully collapse the sidebar using the sidebarFullyCollapsibleOnDesktop() method:\n\n`sidebarFullyCollapsibleOnDesktop()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->sidebarFullyCollapsibleOnDesktop();\n}\n```\n\n### #Navigation groups in a collapsible sidebar on desktop\n\n> This section only applies to sidebarCollapsibleOnDesktop(), not sidebarFullyCollapsibleOnDesktop(), since the fully collapsible UI just hides the entire sidebar instead of changing its design.\n\nThis section only applies to sidebarCollapsibleOnDesktop(), not sidebarFullyCollapsibleOnDesktop(), since the fully collapsible UI just hides the entire sidebar instead of changing its design.\n\n`sidebarCollapsibleOnDesktop()``sidebarFullyCollapsibleOnDesktop()`When using a collapsible sidebar on desktop, you will also often be using navigation groups. By default, the labels of each navigation group will be hidden when the sidebar is collapsed, since there is no space to display them. Even if the navigation group itself is collapsible, all items will still be visible in the collapsed sidebar, since there is no group label to click on to expand the group.\n\nThese issues can be solved, to achieve a very minimal sidebar design, by passing an icon() to the navigation group objects. When an icon is defined, the icon will be displayed in the collapsed sidebar instead of the items at all times. When the icon is clicked, a dropdown will open to the side of the icon, revealing the items in the group.\n\n`icon()`When passing an icon to a navigation group, even if the items also have icons, the expanded sidebar UI will not show the item icons. This is to keep the navigation hierarchy clear, and the design minimal. However, the icons for the items will be shown in the collapsed sidebar’s dropdowns though, since the hierarchy is already clear from the fact that the dropdown is open.\n\n## #Registering custom navigation items\n\nTo register new navigation items, you can use the configuration:\n\n```\nuse Filament\\Navigation\\NavigationItem;\nuse Filament\\Pages\\Dashboard;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->navigationItems([\n            NavigationItem::make('Analytics')\n                ->url('https://filament.pirsch.io', shouldOpenInNewTab: true)\n                ->icon('heroicon-o-presentation-chart-line')\n                ->group('Reports')\n                ->sort(3),\n            NavigationItem::make('dashboard')\n                ->label(fn (): string => __('filament-panels::pages/dashboard.title'))\n                ->url(fn (): string => Dashboard::getUrl())\n                ->isActiveWhen(fn () => request()->routeIs('filament.admin.pages.dashboard')),\n            // ...\n        ]);\n}\n```\n\n## #Conditionally hiding navigation items\n\nYou can also conditionally hide a navigation item by using the visible() or hidden() methods, passing in a condition to check:\n\n`visible()``hidden()````\nuse Filament\\Navigation\\NavigationItem;\n\nNavigationItem::make('Analytics')\n    ->visible(fn(): bool => auth()->user()->can('view-analytics'))\n    // or\n    ->hidden(fn(): bool => ! auth()->user()->can('view-analytics')),\n```\n\n## #Disabling resource or page navigation items\n\nTo prevent resources or pages from showing up in navigation, you may use:\n\n```\nprotected static bool $shouldRegisterNavigation = false;\n```\n\nOr, you may override the shouldRegisterNavigation() method:\n\n`shouldRegisterNavigation()````\npublic static function shouldRegisterNavigation(): bool\n{\n    return false;\n}\n```\n\nPlease note that these methods do not control direct access to the resource or page. They only control whether the resource or page will show up in the navigation. If you want to also control access, then you should use resource authorization or page authorization.\n\n## #Using top navigation\n\nBy default, Filament will use a sidebar navigation. You may use a top navigation instead by using the configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->topNavigation();\n}\n```\n\n## #Customizing the width of the sidebar\n\nYou can customize the width of the sidebar by passing it to the sidebarWidth() method in the configuration:\n\n`sidebarWidth()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->sidebarWidth('40rem');\n}\n```\n\nAdditionally, if you are using the sidebarCollapsibleOnDesktop() method, you can customize width of the collapsed icons by using the collapsedSidebarWidth() method in the configuration:\n\n`sidebarCollapsibleOnDesktop()``collapsedSidebarWidth()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->sidebarCollapsibleOnDesktop()\n        ->collapsedSidebarWidth('9rem');\n}\n```\n\n## #Advanced navigation customization\n\nThe navigation() method can be called from the configuration. It allows you to build a custom navigation that overrides Filament’s automatically generated items. This API is designed to give you complete control over the navigation.\n\n`navigation()`### #Registering custom navigation items\n\nTo register navigation items, call the items() method:\n\n`items()````\nuse App\\Filament\\Pages\\Settings;\nuse App\\Filament\\Resources\\UserResource;\nuse Filament\\Navigation\\NavigationBuilder;\nuse Filament\\Navigation\\NavigationItem;\nuse Filament\\Pages\\Dashboard;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->navigation(function (NavigationBuilder $builder): NavigationBuilder {\n            return $builder->items([\n                NavigationItem::make('Dashboard')\n                    ->icon('heroicon-o-home')\n                    ->isActiveWhen(fn (): bool => request()->routeIs('filament.admin.pages.dashboard'))\n                    ->url(fn (): string => Dashboard::getUrl()),\n                ...UserResource::getNavigationItems(),\n                ...Settings::getNavigationItems(),\n            ]);\n        });\n}\n```\n\n### #Registering custom navigation groups\n\nIf you want to register groups, you can call the groups() method:\n\n`groups()````\nuse App\\Filament\\Pages\\HomePageSettings;\nuse App\\Filament\\Resources\\CategoryResource;\nuse App\\Filament\\Resources\\PageResource;\nuse Filament\\Navigation\\NavigationBuilder;\nuse Filament\\Navigation\\NavigationGroup;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->navigation(function (NavigationBuilder $builder): NavigationBuilder {\n            return $builder->groups([\n                NavigationGroup::make('Website')\n                    ->items([\n                        ...PageResource::getNavigationItems(),\n                        ...CategoryResource::getNavigationItems(),\n                        ...HomePageSettings::getNavigationItems(),\n                    ]),\n            ]);\n        });\n}\n```\n\n### #Disabling navigation\n\nYou may disable navigation entirely by passing false to the navigation() method:\n\n`false``navigation()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->navigation(false);\n}\n```\n\n### #Disabling the topbar\n\nYou may disable topbar entirely by passing false to the topbar() method:\n\n`false``topbar()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->topbar(false);\n}\n```\n\n## #Customizing the user menu\n\nThe user menu is featured in the top right corner of the admin layout. It’s fully customizable.\n\nTo register new items to the user menu, you can use the configuration:\n\n```\nuse App\\Filament\\Pages\\Settings;\nuse Filament\\Navigation\\MenuItem;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->userMenuItems([\n            MenuItem::make()\n                ->label('Settings')\n                ->url(fn (): string => Settings::getUrl())\n                ->icon('heroicon-o-cog-6-tooth'),\n            // ...\n        ]);\n}\n```\n\n### #Customizing the profile link\n\nTo customize the user profile link at the start of the user menu, register a new item with the profile array key:\n\n`profile````\nuse Filament\\Navigation\\MenuItem;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->userMenuItems([\n            'profile' => MenuItem::make()->label('Edit profile'),\n            // ...\n        ]);\n}\n```\n\nFor more information on creating a profile page, check out the authentication features documentation.\n\n### #Customizing the logout link\n\nTo customize the user logout link at the end of the user menu, register a new item with the logout array key:\n\n`logout````\nuse Filament\\Navigation\\MenuItem;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->userMenuItems([\n            'logout' => MenuItem::make()->label('Log out'),\n            // ...\n        ]);\n}\n```\n\n### #Conditionally hiding user menu items\n\nYou can also conditionally hide a user menu item by using the visible() or hidden() methods, passing in a condition to check. Passing a function will defer condition evaluation until the menu is actually being rendered:\n\n`visible()``hidden()````\nuse App\\Models\\Payment;\nuse Filament\\Navigation\\MenuItem;\n\nMenuItem::make()\n    ->label('Payments')\n    ->visible(fn (): bool => auth()->user()->can('viewAny', Payment::class))\n    // or\n    ->hidden(fn (): bool => ! auth()->user()->can('viewAny', Payment::class))\n```\n\n### #Sending a POST HTTP request from a user menu item\n\n`POST`You can send a POST HTTP request from a user menu item by passing a URL to the postAction() method:\n\n`POST``postAction()````\nuse Filament\\Navigation\\MenuItem;\n\nMenuItem::make()\n    ->label('Lock session')\n    ->postAction(fn (): string => route('lock-session'))\n```\n\n## #Disabling breadcrumbs\n\nThe default layout will show breadcrumbs to indicate the location of the current page within the hierarchy of the app.\n\nYou may disable breadcrumbs in your configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->breadcrumbs(false);\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Navigation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Navigation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "By default, Filament will register navigation items for each of your resources, custom pages, and clusters. These classes contain static properties and methods that you can override, to configure that navigation item.\n\nIf you’re looking to add a second layer of navigation to your app, you can use clusters. These are useful for grouping resources and pages together.",
                "level": 3
              },
              {
                "title": "## #Customizing a navigation item’s label",
                "content": "By default, the navigation label is generated from the resource or page’s name. You may customize this using the $navigationLabel property:\n\n`$navigationLabel````\nprotected static ?string $navigationLabel = 'Custom Navigation Label';\n```\n\nAlternatively, you may override the getNavigationLabel() method:\n\n`getNavigationLabel()````\npublic static function getNavigationLabel(): string\n{\n    return 'Custom Navigation Label';\n}\n```",
                "level": 3
              },
              {
                "title": "## #Customizing a navigation item’s icon",
                "content": "To customize a navigation item’s icon, you may override the $navigationIcon property on the resource or page class:\n\n`$navigationIcon````\nprotected static ?string $navigationIcon = 'heroicon-o-document-text';\n```\n\nIf you set $navigationIcon = null on all items within the same navigation group, those items will be joined with a vertical bar below the group label.\n\n`$navigationIcon = null`### #Switching navigation item icon when it is active\n\nYou may assign a navigation icon which will only be used for active items using the $activeNavigationIcon property:\n\n`$activeNavigationIcon````\nprotected static ?string $activeNavigationIcon = 'heroicon-o-document-text';\n```",
                "level": 3
              },
              {
                "title": "## #Sorting navigation items",
                "content": "By default, navigation items are sorted alphabetically. You may customize this using the $navigationSort property:\n\n`$navigationSort````\nprotected static ?int $navigationSort = 3;\n```\n\nNow, navigation items with a lower sort value will appear before those with a higher sort value - the order is ascending.",
                "level": 3
              },
              {
                "title": "## #Adding a badge to a navigation item",
                "content": "To add a badge next to the navigation item, you can use the getNavigationBadge() method and return the content of the badge:\n\n`getNavigationBadge()````\npublic static function getNavigationBadge(): ?string\n{\n    return static::getModel()::count();\n}\n```\n\nIf a badge value is returned by getNavigationBadge(), it will display using the primary color by default. To style the badge contextually, return either danger, gray, info, primary, success or warning from the getNavigationBadgeColor() method:\n\n`getNavigationBadge()``danger``gray``info``primary``success``warning``getNavigationBadgeColor()````\npublic static function getNavigationBadgeColor(): ?string\n{\n    return static::getModel()::count() > 10 ? 'warning' : 'primary';\n}\n```\n\nA custom tooltip for the navigation badge can be set in $navigationBadgeTooltip:\n\n`$navigationBadgeTooltip````\nprotected static ?string $navigationBadgeTooltip = 'The number of users';\n```\n\nOr it can be returned from getNavigationBadgeTooltip():\n\n`getNavigationBadgeTooltip()````\npublic static function getNavigationBadgeTooltip(): ?string\n{\n    return 'The number of users';\n}\n```",
                "level": 3
              },
              {
                "title": "## #Grouping navigation items",
                "content": "You may group navigation items by specifying a $navigationGroup property on a resource and custom page:\n\n`$navigationGroup````\nprotected static ?string $navigationGroup = 'Settings';\n```\n\nAll items in the same navigation group will be displayed together under the same group label, “Settings” in this case. Ungrouped items will remain at the start of the navigation.",
                "level": 3
              },
              {
                "title": "### #Grouping navigation items under other items",
                "content": "You may group navigation items as children of other items, by passing the label of the parent item as the $navigationParentItem:\n\n`$navigationParentItem````\nprotected static ?string $navigationParentItem = 'Notifications';\n\nprotected static ?string $navigationGroup = 'Settings';\n```\n\nYou may also use the getNavigationParentItem() method to set a dynamic parent item label:\n\n`getNavigationParentItem()````\npublic static function getNavigationParentItem(): ?string\n{\n    return __('filament/navigation.groups.settings.items.notifications');\n}\n```\n\nAs seen above, if the parent item has a navigation group, that navigation group must also be defined, so the correct parent item can be identified.\n\n> If you’re reaching for a third level of navigation like this, you should consider using clusters instead, which are a logical grouping of resources and custom pages, which can share their own separate navigation.\n\nIf you’re reaching for a third level of navigation like this, you should consider using clusters instead, which are a logical grouping of resources and custom pages, which can share their own separate navigation.",
                "level": 4
              },
              {
                "title": "### #Customizing navigation groups",
                "content": "You may customize navigation groups by calling navigationGroups() in the configuration, and passing NavigationGroup objects in order:\n\n`navigationGroups()``NavigationGroup````\nuse Filament\\Navigation\\NavigationGroup;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->navigationGroups([\n            NavigationGroup::make()\n                 ->label('Shop')\n                 ->icon('heroicon-o-shopping-cart'),\n            NavigationGroup::make()\n                ->label('Blog')\n                ->icon('heroicon-o-pencil'),\n            NavigationGroup::make()\n                ->label(fn (): string => __('navigation.settings'))\n                ->icon('heroicon-o-cog-6-tooth')\n                ->collapsed(),\n        ]);\n}\n```\n\nIn this example, we pass in a custom icon() for the groups, and make one collapsed() by default.\n\n`icon()``collapsed()`#### #Ordering navigation groups\n\nBy using navigationGroups(), you are defining a new order for the navigation groups. If you just want to reorder the groups and not define an entire NavigationGroup object, you may just pass the labels of the groups in the new order:\n\n`navigationGroups()``NavigationGroup````\n$panel\n    ->navigationGroups([\n        'Shop',\n        'Blog',\n        'Settings',\n    ])\n```",
                "level": 4
              },
              {
                "title": "#### #Making navigation groups not collapsible",
                "content": "By default, navigation groups are collapsible.\n\nYou may disable this behavior by calling collapsible(false) on the NavigationGroup object:\n\n`collapsible(false)``NavigationGroup````\nuse Filament\\Navigation\\NavigationGroup;\n\nNavigationGroup::make()\n    ->label('Settings')\n    ->icon('heroicon-o-cog-6-tooth')\n    ->collapsible(false);\n```\n\nOr, you can do it globally for all groups in the configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->collapsibleNavigationGroups(false);\n}\n```",
                "level": 5
              },
              {
                "title": "#### #Adding extra HTML attributes to navigation groups",
                "content": "You can pass extra HTML attributes to the navigation group, which will be merged onto the outer DOM element. Pass an array of attributes to the extraSidebarAttributes() or extraTopbarAttributes() method, where the key is the attribute name and the value is the attribute value:\n\n`extraSidebarAttributes()``extraTopbarAttributes()````\nNavigationGroup::make()\n    ->extraSidebarAttributes(['class' => 'featured-sidebar-group']),\n    ->extraTopbarAttributes(['class' => 'featured-topbar-group']),\n```\n\nThe extraSidebarAttributes() will be applied to navigation group elements contained in the sidebar, and the extraTopbarAttributes() will only be applied to topbar navigation group dropdowns when using top navigation.\n\n`extraSidebarAttributes()``extraTopbarAttributes()`## #Collapsible sidebar on desktop\n\nTo make the sidebar collapsible on desktop as well as mobile, you can use the configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->sidebarCollapsibleOnDesktop();\n}\n```\n\nBy default, when you collapse the sidebar on desktop, the navigation icons still show. You can fully collapse the sidebar using the sidebarFullyCollapsibleOnDesktop() method:\n\n`sidebarFullyCollapsibleOnDesktop()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->sidebarFullyCollapsibleOnDesktop();\n}\n```",
                "level": 5
              },
              {
                "title": "### #Navigation groups in a collapsible sidebar on desktop",
                "content": "> This section only applies to sidebarCollapsibleOnDesktop(), not sidebarFullyCollapsibleOnDesktop(), since the fully collapsible UI just hides the entire sidebar instead of changing its design.\n\nThis section only applies to sidebarCollapsibleOnDesktop(), not sidebarFullyCollapsibleOnDesktop(), since the fully collapsible UI just hides the entire sidebar instead of changing its design.\n\n`sidebarCollapsibleOnDesktop()``sidebarFullyCollapsibleOnDesktop()`When using a collapsible sidebar on desktop, you will also often be using navigation groups. By default, the labels of each navigation group will be hidden when the sidebar is collapsed, since there is no space to display them. Even if the navigation group itself is collapsible, all items will still be visible in the collapsed sidebar, since there is no group label to click on to expand the group.\n\nThese issues can be solved, to achieve a very minimal sidebar design, by passing an icon() to the navigation group objects. When an icon is defined, the icon will be displayed in the collapsed sidebar instead of the items at all times. When the icon is clicked, a dropdown will open to the side of the icon, revealing the items in the group.\n\n`icon()`When passing an icon to a navigation group, even if the items also have icons, the expanded sidebar UI will not show the item icons. This is to keep the navigation hierarchy clear, and the design minimal. However, the icons for the items will be shown in the collapsed sidebar’s dropdowns though, since the hierarchy is already clear from the fact that the dropdown is open.",
                "level": 4
              },
              {
                "title": "## #Registering custom navigation items",
                "content": "To register new navigation items, you can use the configuration:\n\n```\nuse Filament\\Navigation\\NavigationItem;\nuse Filament\\Pages\\Dashboard;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->navigationItems([\n            NavigationItem::make('Analytics')\n                ->url('https://filament.pirsch.io', shouldOpenInNewTab: true)\n                ->icon('heroicon-o-presentation-chart-line')\n                ->group('Reports')\n                ->sort(3),\n            NavigationItem::make('dashboard')\n                ->label(fn (): string => __('filament-panels::pages/dashboard.title'))\n                ->url(fn (): string => Dashboard::getUrl())\n                ->isActiveWhen(fn () => request()->routeIs('filament.admin.pages.dashboard')),\n            // ...\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Conditionally hiding navigation items",
                "content": "You can also conditionally hide a navigation item by using the visible() or hidden() methods, passing in a condition to check:\n\n`visible()``hidden()````\nuse Filament\\Navigation\\NavigationItem;\n\nNavigationItem::make('Analytics')\n    ->visible(fn(): bool => auth()->user()->can('view-analytics'))\n    // or\n    ->hidden(fn(): bool => ! auth()->user()->can('view-analytics')),\n```",
                "level": 3
              },
              {
                "title": "## #Disabling resource or page navigation items",
                "content": "To prevent resources or pages from showing up in navigation, you may use:\n\n```\nprotected static bool $shouldRegisterNavigation = false;\n```\n\nOr, you may override the shouldRegisterNavigation() method:\n\n`shouldRegisterNavigation()````\npublic static function shouldRegisterNavigation(): bool\n{\n    return false;\n}\n```\n\nPlease note that these methods do not control direct access to the resource or page. They only control whether the resource or page will show up in the navigation. If you want to also control access, then you should use resource authorization or page authorization.",
                "level": 3
              },
              {
                "title": "## #Using top navigation",
                "content": "By default, Filament will use a sidebar navigation. You may use a top navigation instead by using the configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->topNavigation();\n}\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the width of the sidebar",
                "content": "You can customize the width of the sidebar by passing it to the sidebarWidth() method in the configuration:\n\n`sidebarWidth()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->sidebarWidth('40rem');\n}\n```\n\nAdditionally, if you are using the sidebarCollapsibleOnDesktop() method, you can customize width of the collapsed icons by using the collapsedSidebarWidth() method in the configuration:\n\n`sidebarCollapsibleOnDesktop()``collapsedSidebarWidth()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->sidebarCollapsibleOnDesktop()\n        ->collapsedSidebarWidth('9rem');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Advanced navigation customization",
                "content": "The navigation() method can be called from the configuration. It allows you to build a custom navigation that overrides Filament’s automatically generated items. This API is designed to give you complete control over the navigation.\n\n`navigation()`### #Registering custom navigation items\n\nTo register navigation items, call the items() method:\n\n`items()````\nuse App\\Filament\\Pages\\Settings;\nuse App\\Filament\\Resources\\UserResource;\nuse Filament\\Navigation\\NavigationBuilder;\nuse Filament\\Navigation\\NavigationItem;\nuse Filament\\Pages\\Dashboard;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->navigation(function (NavigationBuilder $builder): NavigationBuilder {\n            return $builder->items([\n                NavigationItem::make('Dashboard')\n                    ->icon('heroicon-o-home')\n                    ->isActiveWhen(fn (): bool => request()->routeIs('filament.admin.pages.dashboard'))\n                    ->url(fn (): string => Dashboard::getUrl()),\n                ...UserResource::getNavigationItems(),\n                ...Settings::getNavigationItems(),\n            ]);\n        });\n}\n```",
                "level": 3
              },
              {
                "title": "### #Registering custom navigation groups",
                "content": "If you want to register groups, you can call the groups() method:\n\n`groups()````\nuse App\\Filament\\Pages\\HomePageSettings;\nuse App\\Filament\\Resources\\CategoryResource;\nuse App\\Filament\\Resources\\PageResource;\nuse Filament\\Navigation\\NavigationBuilder;\nuse Filament\\Navigation\\NavigationGroup;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->navigation(function (NavigationBuilder $builder): NavigationBuilder {\n            return $builder->groups([\n                NavigationGroup::make('Website')\n                    ->items([\n                        ...PageResource::getNavigationItems(),\n                        ...CategoryResource::getNavigationItems(),\n                        ...HomePageSettings::getNavigationItems(),\n                    ]),\n            ]);\n        });\n}\n```",
                "level": 4
              },
              {
                "title": "### #Disabling navigation",
                "content": "You may disable navigation entirely by passing false to the navigation() method:\n\n`false``navigation()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->navigation(false);\n}\n```",
                "level": 4
              },
              {
                "title": "### #Disabling the topbar",
                "content": "You may disable topbar entirely by passing false to the topbar() method:\n\n`false``topbar()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->topbar(false);\n}\n```",
                "level": 4
              },
              {
                "title": "## #Customizing the user menu",
                "content": "The user menu is featured in the top right corner of the admin layout. It’s fully customizable.\n\nTo register new items to the user menu, you can use the configuration:\n\n```\nuse App\\Filament\\Pages\\Settings;\nuse Filament\\Navigation\\MenuItem;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->userMenuItems([\n            MenuItem::make()\n                ->label('Settings')\n                ->url(fn (): string => Settings::getUrl())\n                ->icon('heroicon-o-cog-6-tooth'),\n            // ...\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "### #Customizing the profile link",
                "content": "To customize the user profile link at the start of the user menu, register a new item with the profile array key:\n\n`profile````\nuse Filament\\Navigation\\MenuItem;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->userMenuItems([\n            'profile' => MenuItem::make()->label('Edit profile'),\n            // ...\n        ]);\n}\n```\n\nFor more information on creating a profile page, check out the authentication features documentation.",
                "level": 4
              },
              {
                "title": "### #Customizing the logout link",
                "content": "To customize the user logout link at the end of the user menu, register a new item with the logout array key:\n\n`logout````\nuse Filament\\Navigation\\MenuItem;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->userMenuItems([\n            'logout' => MenuItem::make()->label('Log out'),\n            // ...\n        ]);\n}\n```",
                "level": 4
              },
              {
                "title": "### #Conditionally hiding user menu items",
                "content": "You can also conditionally hide a user menu item by using the visible() or hidden() methods, passing in a condition to check. Passing a function will defer condition evaluation until the menu is actually being rendered:\n\n`visible()``hidden()````\nuse App\\Models\\Payment;\nuse Filament\\Navigation\\MenuItem;\n\nMenuItem::make()\n    ->label('Payments')\n    ->visible(fn (): bool => auth()->user()->can('viewAny', Payment::class))\n    // or\n    ->hidden(fn (): bool => ! auth()->user()->can('viewAny', Payment::class))\n```",
                "level": 4
              },
              {
                "title": "### #Sending a POST HTTP request from a user menu item",
                "content": "`POST`You can send a POST HTTP request from a user menu item by passing a URL to the postAction() method:\n\n`POST``postAction()````\nuse Filament\\Navigation\\MenuItem;\n\nMenuItem::make()\n    ->label('Lock session')\n    ->postAction(fn (): string => route('lock-session'))\n```",
                "level": 4
              },
              {
                "title": "## #Disabling breadcrumbs",
                "content": "The default layout will show breadcrumbs to indicate the location of the current page within the hierarchy of the app.\n\nYou may disable breadcrumbs in your configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->breadcrumbs(false);\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Customizing a navigation item’s label",
              "Customizing a navigation item’s icon",
              "Sorting navigation items",
              "Adding a badge to a navigation item",
              "Grouping navigation items",
              "Grouping navigation items under other items",
              "Customizing navigation groups",
              "Navigation groups in a collapsible sidebar on desktop",
              "Registering custom navigation items"
            ],
            "code_examples_count": 72,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "notifications": {
          "metadata": {
            "title": "Notifications",
            "url": "https://filamentphp.com/docs/3.x/panels/notifications",
            "section": "panels",
            "word_count": 290,
            "character_count": 2119
          },
          "content": {
            "full_text": "\n# Notifications - Panels - Filament\n\nPanels\n\n# Notifications\n\n## #Overview\n\nThe Panel Builder uses the Notifications package to send messages to users. Please read the documentation to discover how to send notifications easily.\n\nIf you’d like to receive database notifications, you can enable them in the configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->databaseNotifications();\n}\n```\n\nYou may also control database notification polling:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->databaseNotifications()\n        ->databaseNotificationsPolling('30s');\n}\n```\n\n## #Setting up websockets in a panel\n\nThe Panel Builder comes with a level of inbuilt support for real-time broadcast and database notifications. However there are a number of areas you will need to install and configure to wire everything up and get it working.\n\n- If you haven’t already, read up on broadcasting in the Laravel documentation.\n- Install and configure broadcasting to use a server-side websockets integration like Pusher.\n- If you haven’t already, you will need to publish the Filament package configuration:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n- Edit the configuration at config/filament.php and uncomment the broadcasting.echo section - ensuring the settings are correctly configured according to your broadcasting installation.\n- Ensure the relevant VITE_* entries exist in your .env file.\n- Clear relevant caches with php artisan route:clear and php artisan config:clear to ensure your new configuration takes effect.\n\n`config/filament.php``broadcasting.echo``VITE_*``.env``php artisan route:clear``php artisan config:clear`Your panel should now be connecting to your broadcasting service. For example, if you log into the Pusher debug console you should see an incoming connection each time you load a page.\n\nTo send a real-time notification, see the broadcast notifications documentation.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Notifications - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Notifications",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "The Panel Builder uses the Notifications package to send messages to users. Please read the documentation to discover how to send notifications easily.\n\nIf you’d like to receive database notifications, you can enable them in the configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->databaseNotifications();\n}\n```\n\nYou may also control database notification polling:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->databaseNotifications()\n        ->databaseNotificationsPolling('30s');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Setting up websockets in a panel",
                "content": "The Panel Builder comes with a level of inbuilt support for real-time broadcast and database notifications. However there are a number of areas you will need to install and configure to wire everything up and get it working.\n\n- If you haven’t already, read up on broadcasting in the Laravel documentation.\n- Install and configure broadcasting to use a server-side websockets integration like Pusher.\n- If you haven’t already, you will need to publish the Filament package configuration:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n- Edit the configuration at config/filament.php and uncomment the broadcasting.echo section - ensuring the settings are correctly configured according to your broadcasting installation.\n- Ensure the relevant VITE_* entries exist in your .env file.\n- Clear relevant caches with php artisan route:clear and php artisan config:clear to ensure your new configuration takes effect.\n\n`config/filament.php``broadcasting.echo``VITE_*``.env``php artisan route:clear``php artisan config:clear`Your panel should now be connecting to your broadcasting service. For example, if you log into the Pusher debug console you should see an incoming connection each time you load a page.\n\nTo send a real-time notification, see the broadcast notifications documentation.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Setting up websockets in a panel"
            ],
            "code_examples_count": 6,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "users": {
          "metadata": {
            "title": "Users",
            "url": "https://filamentphp.com/docs/3.x/panels/users",
            "section": "panels",
            "word_count": 1353,
            "character_count": 11978
          },
          "content": {
            "full_text": "\n# Users - Panels - Filament\n\nPanels\n\n# Users\n\n## #Overview\n\nBy default, all App\\Models\\Users can access Filament locally. To allow them to access Filament in production, you must take a few extra steps to ensure that only the correct users have access to the app.\n\n`App\\Models\\User`## #Authorizing access to the panel\n\nTo set up your App\\Models\\User to access Filament in non-local environments, you must implement the FilamentUser contract:\n\n`App\\Models\\User``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\nThe canAccessPanel() method returns true or false depending on whether the user is allowed to access the $panel. In this example, we check if the user’s email ends with @yourdomain.com and if they have verified their email address.\n\n`canAccessPanel()``true``false``$panel``@yourdomain.com`Since you have access to the current $panel, you can write conditional checks for separate panels. For example, only restricting access to the admin panel while allowing all users to access the other panels of your app:\n\n`$panel````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        if ($panel->getId() === 'admin') {\n            return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n        }\n\n        return true;\n    }\n}\n```\n\n## #Authorizing access to Resources\n\nSee the Authorization section in the Resource documentation for controlling access to Resource pages and their data records.\n\n## #Setting up user avatars\n\nOut of the box, Filament uses ui-avatars.com to generate avatars based on a user’s name. However, if your user model has an avatar_url attribute, that will be used instead. To customize how Filament gets a user’s avatar URL, you can implement the HasAvatar contract:\n\n`avatar_url``HasAvatar````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Models\\Contracts\\HasAvatar;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser, HasAvatar\n{\n    // ...\n\n    public function getFilamentAvatarUrl(): ?string\n    {\n        return $this->avatar_url;\n    }\n}\n```\n\nThe getFilamentAvatarUrl() method is used to retrieve the avatar of the current user. If null is returned from this method, Filament will fall back to ui-avatars.com.\n\n`getFilamentAvatarUrl()``null`### #Using a different avatar provider\n\nYou can easily swap out ui-avatars.com for a different service, by creating a new avatar provider.\n\nIn this example, we create a new file at app/Filament/AvatarProviders/BoringAvatarsProvider.php for boringavatars.com. The get() method accepts a user model instance and returns an avatar URL for that user:\n\n`app/Filament/AvatarProviders/BoringAvatarsProvider.php``get()````\n<?php\n\nnamespace App\\Filament\\AvatarProviders;\n\nuse Filament\\AvatarProviders\\Contracts;\nuse Filament\\Facades\\Filament;\nuse Illuminate\\Contracts\\Auth\\Authenticatable;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass BoringAvatarsProvider implements Contracts\\AvatarProvider\n{\n    public function get(Model | Authenticatable $record): string\n    {\n        $name = str(Filament::getNameForDefaultAvatar($record))\n            ->trim()\n            ->explode(' ')\n            ->map(fn (string $segment): string => filled($segment) ? mb_substr($segment, 0, 1) : '')\n            ->join(' ');\n\n        return 'https://source.boringavatars.com/beam/120/' . urlencode($name);\n    }\n}\n```\n\nNow, register this new avatar provider in the configuration:\n\n```\nuse App\\Filament\\AvatarProviders\\BoringAvatarsProvider;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->defaultAvatarProvider(BoringAvatarsProvider::class);\n}\n```\n\n## #Configuring the user’s name attribute\n\nBy default, Filament will use the name attribute of the user to display their name in the app. To change this, you can implement the HasName contract:\n\n`name``HasName````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Models\\Contracts\\HasName;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser, HasName\n{\n    // ...\n\n    public function getFilamentName(): string\n    {\n        return \"{$this->first_name} {$this->last_name}\";\n    }\n}\n```\n\nThe getFilamentName() method is used to retrieve the name of the current user.\n\n`getFilamentName()`## #Authentication features\n\nYou can easily enable authentication features for a panel in the configuration file:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->login()\n        ->registration()\n        ->passwordReset()\n        ->emailVerification()\n        ->profile();\n}\n```\n\n### #Customizing the authentication features\n\nIf you’d like to replace these pages with your own, you can pass in any Filament page class to these methods.\n\nMost people will be able to make their desired customizations by extending the base page class from the Filament codebase, overriding methods like form(), and then passing the new page class in to the configuration:\n\n`form()````\nuse App\\Filament\\Pages\\Auth\\EditProfile;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->profile(EditProfile::class);\n}\n```\n\nIn this example, we will customize the profile page. We need to create a new PHP class at app/Filament/Pages/Auth/EditProfile.php:\n\n`app/Filament/Pages/Auth/EditProfile.php````\n<?php\n\nnamespace App\\Filament\\Pages\\Auth;\n\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Form;\nuse Filament\\Pages\\Auth\\EditProfile as BaseEditProfile;\n\nclass EditProfile extends BaseEditProfile\n{\n    public function form(Form $form): Form\n    {\n        return $form\n            ->schema([\n                TextInput::make('username')\n                    ->required()\n                    ->maxLength(255),\n                $this->getNameFormComponent(),\n                $this->getEmailFormComponent(),\n                $this->getPasswordFormComponent(),\n                $this->getPasswordConfirmationFormComponent(),\n            ]);\n    }\n}\n```\n\nThis class extends the base profile page class from the Filament codebase. Other page classes you could extend include:\n\n- Filament\\Pages\\Auth\\Login\n- Filament\\Pages\\Auth\\Register\n- Filament\\Pages\\Auth\\EmailVerification\\EmailVerificationPrompt\n- Filament\\Pages\\Auth\\PasswordReset\\RequestPasswordReset\n- Filament\\Pages\\Auth\\PasswordReset\\ResetPassword\n\n`Filament\\Pages\\Auth\\Login``Filament\\Pages\\Auth\\Register``Filament\\Pages\\Auth\\EmailVerification\\EmailVerificationPrompt``Filament\\Pages\\Auth\\PasswordReset\\RequestPasswordReset``Filament\\Pages\\Auth\\PasswordReset\\ResetPassword`In the form() method of the example, we call methods like getNameFormComponent() to get the default form components for the page. You can customize these components as required. For all the available customization options, see the base EditProfile page class in the Filament codebase - it contains all the methods that you can override to make changes.\n\n`form()``getNameFormComponent()``EditProfile`#### #Customizing an authentication field without needing to re-define the form\n\nIf you’d like to customize a field in an authentication form without needing to define a new form() method, you could extend the specific field method and chain your customizations:\n\n`form()````\nuse Filament\\Forms\\Components\\Component;\n\nprotected function getPasswordFormComponent(): Component\n{\n    return parent::getPasswordFormComponent()\n        ->revealable(false);\n}\n```\n\n### #Using a sidebar on the profile page\n\nBy default, the profile page does not use the standard page layout with a sidebar. This is so that it works with the tenancy feature, otherwise it would not be accessible if the user had no tenants, since the sidebar links are routed to the current tenant.\n\nIf you aren’t using tenancy in your panel, and you’d like the profile page to use the standard page layout with a sidebar, you can pass the isSimple: false parameter to $panel->profile() when registering the page:\n\n`isSimple: false``$panel->profile()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->profile(isSimple: false);\n}\n```\n\n### #Customizing the authentication route slugs\n\nYou can customize the URL slugs used for the authentication routes in the configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->loginRouteSlug('login')\n        ->registrationRouteSlug('register')\n        ->passwordResetRoutePrefix('password-reset')\n        ->passwordResetRequestRouteSlug('request')\n        ->passwordResetRouteSlug('reset')\n        ->emailVerificationRoutePrefix('email-verification')\n        ->emailVerificationPromptRouteSlug('prompt')\n        ->emailVerificationRouteSlug('verify');\n}\n```\n\n### #Setting the authentication guard\n\nTo set the authentication guard that Filament uses, you can pass in the guard name to the authGuard() configuration method:\n\n`authGuard()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->authGuard('web');\n}\n```\n\n### #Setting the password broker\n\nTo set the password broker that Filament uses, you can pass in the broker name to the authPasswordBroker() configuration method:\n\n`authPasswordBroker()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->authPasswordBroker('users');\n}\n```\n\n### #Disabling revealable password inputs\n\nBy default, all password inputs in authentication forms are revealable(). This allows the user can see a plain text version of the password they’re typing by clicking a button. To disable this feature, you can pass false to the revealablePasswords() configuration method:\n\n`revealable()``false``revealablePasswords()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->revealablePasswords(false);\n}\n```\n\nYou could also disable this feature on a per-field basis by calling ->revealable(false) on the field object when extending the base page class.\n\n`->revealable(false)`## #Setting up guest access to a panel\n\nBy default, Filament expects to work with authenticated users only. To allow guests to access a panel, you need to avoid using components which expect a signed-in user (such as profiles, avatars), and remove the built-in Authentication middleware:\n\n- Remove the default Authenticate::class from the authMiddleware() array in the panel configuration.\n- Remove ->login() and any other authentication features from the panel.\n- Remove the default AccountWidget from the widgets() array, because it reads the current user’s data.\n\n`Authenticate::class``authMiddleware()``->login()``AccountWidget``widgets()`### #Authorizing guests in policies\n\nWhen present, Filament relies on Laravel Model Policies for access control. To give read-access for guest users in a model policy, create the Policy and update the viewAny() and view() methods, changing the User $user param to ?User $user so that it’s optional, and return true;. Alternatively, you can remove those methods from the policy entirely.\n\n`viewAny()``view()``User $user``?User $user``return true;`Still need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Users - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Users",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "By default, all App\\Models\\Users can access Filament locally. To allow them to access Filament in production, you must take a few extra steps to ensure that only the correct users have access to the app.\n\n`App\\Models\\User`## #Authorizing access to the panel\n\nTo set up your App\\Models\\User to access Filament in non-local environments, you must implement the FilamentUser contract:\n\n`App\\Models\\User``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\nThe canAccessPanel() method returns true or false depending on whether the user is allowed to access the $panel. In this example, we check if the user’s email ends with @yourdomain.com and if they have verified their email address.\n\n`canAccessPanel()``true``false``$panel``@yourdomain.com`Since you have access to the current $panel, you can write conditional checks for separate panels. For example, only restricting access to the admin panel while allowing all users to access the other panels of your app:\n\n`$panel````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        if ($panel->getId() === 'admin') {\n            return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n        }\n\n        return true;\n    }\n}\n```",
                "level": 3
              },
              {
                "title": "## #Authorizing access to Resources",
                "content": "See the Authorization section in the Resource documentation for controlling access to Resource pages and their data records.",
                "level": 3
              },
              {
                "title": "## #Setting up user avatars",
                "content": "Out of the box, Filament uses ui-avatars.com to generate avatars based on a user’s name. However, if your user model has an avatar_url attribute, that will be used instead. To customize how Filament gets a user’s avatar URL, you can implement the HasAvatar contract:\n\n`avatar_url``HasAvatar````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Models\\Contracts\\HasAvatar;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser, HasAvatar\n{\n    // ...\n\n    public function getFilamentAvatarUrl(): ?string\n    {\n        return $this->avatar_url;\n    }\n}\n```\n\nThe getFilamentAvatarUrl() method is used to retrieve the avatar of the current user. If null is returned from this method, Filament will fall back to ui-avatars.com.\n\n`getFilamentAvatarUrl()``null`### #Using a different avatar provider\n\nYou can easily swap out ui-avatars.com for a different service, by creating a new avatar provider.\n\nIn this example, we create a new file at app/Filament/AvatarProviders/BoringAvatarsProvider.php for boringavatars.com. The get() method accepts a user model instance and returns an avatar URL for that user:\n\n`app/Filament/AvatarProviders/BoringAvatarsProvider.php``get()````\n<?php\n\nnamespace App\\Filament\\AvatarProviders;\n\nuse Filament\\AvatarProviders\\Contracts;\nuse Filament\\Facades\\Filament;\nuse Illuminate\\Contracts\\Auth\\Authenticatable;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass BoringAvatarsProvider implements Contracts\\AvatarProvider\n{\n    public function get(Model | Authenticatable $record): string\n    {\n        $name = str(Filament::getNameForDefaultAvatar($record))\n            ->trim()\n            ->explode(' ')\n            ->map(fn (string $segment): string => filled($segment) ? mb_substr($segment, 0, 1) : '')\n            ->join(' ');\n\n        return 'https://source.boringavatars.com/beam/120/' . urlencode($name);\n    }\n}\n```\n\nNow, register this new avatar provider in the configuration:\n\n```\nuse App\\Filament\\AvatarProviders\\BoringAvatarsProvider;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->defaultAvatarProvider(BoringAvatarsProvider::class);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Configuring the user’s name attribute",
                "content": "By default, Filament will use the name attribute of the user to display their name in the app. To change this, you can implement the HasName contract:\n\n`name``HasName````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Models\\Contracts\\HasName;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser, HasName\n{\n    // ...\n\n    public function getFilamentName(): string\n    {\n        return \"{$this->first_name} {$this->last_name}\";\n    }\n}\n```\n\nThe getFilamentName() method is used to retrieve the name of the current user.\n\n`getFilamentName()`## #Authentication features\n\nYou can easily enable authentication features for a panel in the configuration file:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->login()\n        ->registration()\n        ->passwordReset()\n        ->emailVerification()\n        ->profile();\n}\n```",
                "level": 3
              },
              {
                "title": "### #Customizing the authentication features",
                "content": "If you’d like to replace these pages with your own, you can pass in any Filament page class to these methods.\n\nMost people will be able to make their desired customizations by extending the base page class from the Filament codebase, overriding methods like form(), and then passing the new page class in to the configuration:\n\n`form()````\nuse App\\Filament\\Pages\\Auth\\EditProfile;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->profile(EditProfile::class);\n}\n```\n\nIn this example, we will customize the profile page. We need to create a new PHP class at app/Filament/Pages/Auth/EditProfile.php:\n\n`app/Filament/Pages/Auth/EditProfile.php````\n<?php\n\nnamespace App\\Filament\\Pages\\Auth;\n\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Form;\nuse Filament\\Pages\\Auth\\EditProfile as BaseEditProfile;\n\nclass EditProfile extends BaseEditProfile\n{\n    public function form(Form $form): Form\n    {\n        return $form\n            ->schema([\n                TextInput::make('username')\n                    ->required()\n                    ->maxLength(255),\n                $this->getNameFormComponent(),\n                $this->getEmailFormComponent(),\n                $this->getPasswordFormComponent(),\n                $this->getPasswordConfirmationFormComponent(),\n            ]);\n    }\n}\n```\n\nThis class extends the base profile page class from the Filament codebase. Other page classes you could extend include:\n\n- Filament\\Pages\\Auth\\Login\n- Filament\\Pages\\Auth\\Register\n- Filament\\Pages\\Auth\\EmailVerification\\EmailVerificationPrompt\n- Filament\\Pages\\Auth\\PasswordReset\\RequestPasswordReset\n- Filament\\Pages\\Auth\\PasswordReset\\ResetPassword\n\n`Filament\\Pages\\Auth\\Login``Filament\\Pages\\Auth\\Register``Filament\\Pages\\Auth\\EmailVerification\\EmailVerificationPrompt``Filament\\Pages\\Auth\\PasswordReset\\RequestPasswordReset``Filament\\Pages\\Auth\\PasswordReset\\ResetPassword`In the form() method of the example, we call methods like getNameFormComponent() to get the default form components for the page. You can customize these components as required. For all the available customization options, see the base EditProfile page class in the Filament codebase - it contains all the methods that you can override to make changes.\n\n`form()``getNameFormComponent()``EditProfile`#### #Customizing an authentication field without needing to re-define the form\n\nIf you’d like to customize a field in an authentication form without needing to define a new form() method, you could extend the specific field method and chain your customizations:\n\n`form()````\nuse Filament\\Forms\\Components\\Component;\n\nprotected function getPasswordFormComponent(): Component\n{\n    return parent::getPasswordFormComponent()\n        ->revealable(false);\n}\n```",
                "level": 4
              },
              {
                "title": "### #Using a sidebar on the profile page",
                "content": "By default, the profile page does not use the standard page layout with a sidebar. This is so that it works with the tenancy feature, otherwise it would not be accessible if the user had no tenants, since the sidebar links are routed to the current tenant.\n\nIf you aren’t using tenancy in your panel, and you’d like the profile page to use the standard page layout with a sidebar, you can pass the isSimple: false parameter to $panel->profile() when registering the page:\n\n`isSimple: false``$panel->profile()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->profile(isSimple: false);\n}\n```",
                "level": 4
              },
              {
                "title": "### #Customizing the authentication route slugs",
                "content": "You can customize the URL slugs used for the authentication routes in the configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->loginRouteSlug('login')\n        ->registrationRouteSlug('register')\n        ->passwordResetRoutePrefix('password-reset')\n        ->passwordResetRequestRouteSlug('request')\n        ->passwordResetRouteSlug('reset')\n        ->emailVerificationRoutePrefix('email-verification')\n        ->emailVerificationPromptRouteSlug('prompt')\n        ->emailVerificationRouteSlug('verify');\n}\n```",
                "level": 4
              },
              {
                "title": "### #Setting the authentication guard",
                "content": "To set the authentication guard that Filament uses, you can pass in the guard name to the authGuard() configuration method:\n\n`authGuard()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->authGuard('web');\n}\n```",
                "level": 4
              },
              {
                "title": "### #Setting the password broker",
                "content": "To set the password broker that Filament uses, you can pass in the broker name to the authPasswordBroker() configuration method:\n\n`authPasswordBroker()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->authPasswordBroker('users');\n}\n```",
                "level": 4
              },
              {
                "title": "### #Disabling revealable password inputs",
                "content": "By default, all password inputs in authentication forms are revealable(). This allows the user can see a plain text version of the password they’re typing by clicking a button. To disable this feature, you can pass false to the revealablePasswords() configuration method:\n\n`revealable()``false``revealablePasswords()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->revealablePasswords(false);\n}\n```\n\nYou could also disable this feature on a per-field basis by calling ->revealable(false) on the field object when extending the base page class.\n\n`->revealable(false)`## #Setting up guest access to a panel\n\nBy default, Filament expects to work with authenticated users only. To allow guests to access a panel, you need to avoid using components which expect a signed-in user (such as profiles, avatars), and remove the built-in Authentication middleware:\n\n- Remove the default Authenticate::class from the authMiddleware() array in the panel configuration.\n- Remove ->login() and any other authentication features from the panel.\n- Remove the default AccountWidget from the widgets() array, because it reads the current user’s data.\n\n`Authenticate::class``authMiddleware()``->login()``AccountWidget``widgets()`### #Authorizing guests in policies\n\nWhen present, Filament relies on Laravel Model Policies for access control. To give read-access for guest users in a model policy, create the Policy and update the viewAny() and view() methods, changing the User $user param to ?User $user so that it’s optional, and return true;. Alternatively, you can remove those methods from the policy entirely.\n\n`viewAny()``view()``User $user``?User $user``return true;`Still need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Authorizing access to Resources",
              "Setting up user avatars",
              "Configuring the user’s name attribute",
              "Customizing the authentication features",
              "Using a sidebar on the profile page",
              "Customizing the authentication route slugs",
              "Setting the authentication guard",
              "Setting the password broker",
              "Disabling revealable password inputs"
            ],
            "code_examples_count": 30,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "configuration": {
          "metadata": {
            "title": "Configuration",
            "url": "https://filamentphp.com/docs/3.x/panels/configuration",
            "section": "panels",
            "word_count": 1772,
            "character_count": 13542
          },
          "content": {
            "full_text": "\n# Configuration - Panels - Filament\n\nPanels\n\n# Configuration\n\n## #Overview\n\nBy default, the configuration file is located at app/Providers/Filament/AdminPanelProvider.php. Keep reading to learn more about panels and how each has its own configuration file.\n\n`app/Providers/Filament/AdminPanelProvider.php`## #Introducing panels\n\nBy default, when you install the package, there is one panel that has been set up for you - and it lives on /admin. All the resources, custom pages, and dashboard widgets you create get registered to this panel.\n\n`/admin`However, you can create as many panels as you want, and each can have its own set of resources, pages and widgets.\n\nFor example, you could build a panel where users can log in at /app and access their dashboard, and admins can log in at /admin and manage the app. The /app panel and the /admin panel have their own resources, since each group of users has different requirements. Filament allows you to do that by providing you with the ability to create multiple panels.\n\n`/app``/admin``/app``/admin`### #The default admin panel\n\nWhen you run filament:install, a new file is created in app/Providers/Filament - AdminPanelProvider.php. This file contains the configuration for the /admin panel.\n\n`filament:install``app/Providers/Filament``AdminPanelProvider.php``/admin`When this documentation refers to the “configuration”, this is the file you need to edit. It allows you to completely customize the app.\n\n### #Creating a new panel\n\nTo create a new panel, you can use the make:filament-panel command, passing in the unique name of the new panel:\n\n`make:filament-panel````\nphp artisan make:filament-panel app\n```\n\nThis command will create a new panel called “app”. A configuration file will be created at app/Providers/Filament/AppPanelProvider.php. You can access this panel at /app, but you can customize the path if you don’t want that.\n\n`app/Providers/Filament/AppPanelProvider.php``/app`Since this configuration file is also a Laravel service provider, it needs to be registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). Filament will attempt to do this for you, but if you get an error while trying to access your panel then this process has probably failed.\n\n`bootstrap/providers.php``config/app.php`## #Changing the path\n\nIn a panel configuration file, you can change the path that the app is accessible at using the path() method:\n\n`path()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->path('app');\n}\n```\n\nIf you want the app to be accessible without any prefix, you can set this to be an empty string:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->path('');\n}\n```\n\nMake sure your routes/web.php file doesn’t already define the '' or '/' route, as it will take precedence.\n\n`routes/web.php``''``'/'`## #Render hooks\n\nRender hooks allow you to render Blade content at various points in the framework views. You can register global render hooks in a service provider or middleware, but it also allows you to register render hooks that are specific to a panel. To do that, you can use the renderHook() method on the panel configuration object. Here’s an example, integrating wire-elements/modal with Filament:\n\n`renderHook()``wire-elements/modal````\nuse Filament\\Panel;\nuse Filament\\View\\PanelsRenderHook;\nuse Illuminate\\Support\\Facades\\Blade;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->renderHook(\n            PanelsRenderHook::BODY_START,\n            fn (): string => Blade::render('@livewire(\\'livewire-ui-modal\\')'),\n        );\n}\n```\n\nA full list of available render hooks can be found here.\n\n## #Setting a domain\n\nBy default, Filament will respond to requests from all domains. If you’d like to scope it to a specific domain, you can use the domain() method, similar to Route::domain() in Laravel:\n\n`domain()``Route::domain()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->domain('admin.example.com');\n}\n```\n\n## #Customizing the maximum content width\n\nBy default, Filament will restrict the width of the content on the page, so it doesn’t become too wide on large screens. To change this, you may use the maxContentWidth() method. Options correspond to Tailwind’s max-width scale. The options are ExtraSmall, Small, Medium, Large, ExtraLarge, TwoExtraLarge, ThreeExtraLarge, FourExtraLarge, FiveExtraLarge, SixExtraLarge, SevenExtraLarge, Full, MinContent, MaxContent, FitContent,  Prose, ScreenSmall, ScreenMedium, ScreenLarge, ScreenExtraLarge and ScreenTwoExtraLarge. The default is SevenExtraLarge:\n\n`maxContentWidth()``ExtraSmall``Small``Medium``Large``ExtraLarge``TwoExtraLarge``ThreeExtraLarge``FourExtraLarge``FiveExtraLarge``SixExtraLarge``SevenExtraLarge``Full``MinContent``MaxContent``FitContent``Prose``ScreenSmall``ScreenMedium``ScreenLarge``ScreenExtraLarge``ScreenTwoExtraLarge``SevenExtraLarge````\nuse Filament\\Panel;\nuse Filament\\Support\\Enums\\MaxWidth;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->maxContentWidth(MaxWidth::Full);\n}\n```\n\nIf you’d like to set the max content width for pages of the type SimplePage, like login and registration pages, you may do so using the simplePageMaxContentWidth() method. The default is Large:\n\n`SimplePage``simplePageMaxContentWidth()``Large````\nuse Filament\\Panel;\nuse Filament\\Support\\Enums\\MaxWidth;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->simplePageMaxContentWidth(MaxWidth::Small);\n}\n```\n\n## #Lifecycle hooks\n\nHooks may be used to execute code during a panel’s lifecycle. bootUsing() is a hook that gets run on every request that takes place within that panel. If you have multiple panels, only the current panel’s bootUsing() will be run. The function gets run from middleware, after all service providers have been booted:\n\n`bootUsing()``bootUsing()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->bootUsing(function (Panel $panel) {\n            // ...\n        });\n}\n```\n\n## #SPA mode\n\nSPA mode utilizes Livewire’s wire:navigate feature to make your server-rendered panel feel like a single-page-application, with less delay between page loads and a loading bar for longer requests. To enable SPA mode on a panel, you can use the spa() method:\n\n`wire:navigate``spa()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->spa();\n}\n```\n\n### #Disabling SPA navigation for specific URLs\n\nBy default, when enabling SPA mode, any URL that lives on the same domain as the current request will be navigated to using Livewire’s wire:navigate feature. If you want to disable this for specific URLs, you can use the spaUrlExceptions() method:\n\n`wire:navigate``spaUrlExceptions()````\nuse App\\Filament\\Resources\\PostResource;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->spa()\n        ->spaUrlExceptions(fn (): array => [\n            url('/admin'),\n            PostResource::getUrl(),\n        ]);\n}\n```\n\n> In this example, we are using getUrl() on a resource to get the URL to the resource’s index page. This feature requires the panel to already be registered though, and the configuration is too early in the request lifecycle to do that. You can use a function to return the URLs instead, which will be resolved when the panel has been registered.\n\nIn this example, we are using getUrl() on a resource to get the URL to the resource’s index page. This feature requires the panel to already be registered though, and the configuration is too early in the request lifecycle to do that. You can use a function to return the URLs instead, which will be resolved when the panel has been registered.\n\n`getUrl()`These URLs need to exactly match the URL that the user is navigating to, including the domain and protocol. If you’d like to use a pattern to match multiple URLs, you can use an asterisk (*) as a wildcard character:\n\n`*````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->spa()\n        ->spaUrlExceptions([\n            '*/admin/posts/*',\n        ]);\n}\n```\n\n## #Unsaved changes alerts\n\nYou may alert users if they attempt to navigate away from a page without saving their changes. This is applied on Create and Edit pages of a resource, as well as any open action modals. To enable this feature, you can use the unsavedChangesAlerts() method:\n\n`unsavedChangesAlerts()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->unsavedChangesAlerts();\n}\n```\n\n## #Enabling database transactions\n\nBy default, Filament does not wrap operations in database transactions, and allows the user to enable this themselves when they have tested to ensure that their operations are safe to be wrapped in a transaction. However, you can enable database transactions at once for all operations by using the databaseTransactions() method:\n\n`databaseTransactions()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->databaseTransactions();\n}\n```\n\nFor any actions you do not want to be wrapped in a transaction, you can use the databaseTransaction(false) method:\n\n`databaseTransaction(false)````\nCreateAction::make()\n    ->databaseTransaction(false)\n```\n\nAnd for any pages like Create resource and Edit resource, you can define the $hasDatabaseTransactions property to false on the page class:\n\n`$hasDatabaseTransactions``false````\nuse Filament\\Resources\\Pages\\CreateRecord;\n\nclass CreatePost extends CreateRecord\n{\n    protected ?bool $hasDatabaseTransactions = false;\n\n    // ...\n}\n```\n\n### #Opting in to database transactions for specific actions and pages\n\nInstead of enabling database transactions everywhere and opting out of them for specific actions and pages, you can opt in to database transactions for specific actions and pages.\n\nFor actions, you can use the databaseTransaction() method:\n\n`databaseTransaction()````\nCreateAction::make()\n    ->databaseTransaction()\n```\n\nFor pages like Create resource and Edit resource, you can define the $hasDatabaseTransactions property to true on the page class:\n\n`$hasDatabaseTransactions``true````\nuse Filament\\Resources\\Pages\\CreateRecord;\n\nclass CreatePost extends CreateRecord\n{\n    protected ?bool $hasDatabaseTransactions = true;\n\n    // ...\n}\n```\n\n## #Registering assets for a panel\n\nYou can register assets that will only be loaded on pages within a specific panel, and not in the rest of the app. To do that, pass an array of assets to the assets() method:\n\n`assets()````\nuse Filament\\Panel;\nuse Filament\\Support\\Assets\\Css;\nuse Filament\\Support\\Assets\\Js;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->assets([\n            Css::make('custom-stylesheet', resource_path('css/custom.css')),\n            Js::make('custom-script', resource_path('js/custom.js')),\n        ]);\n}\n```\n\nBefore these assets can be used, you’ll need to run php artisan filament:assets.\n\n`php artisan filament:assets`## #Applying middleware\n\nYou can apply extra middleware to all routes by passing an array of middleware classes to the middleware() method in the configuration:\n\n`middleware()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->middleware([\n            // ...\n        ]);\n}\n```\n\nBy default, middleware will be run when the page is first loaded, but not on subsequent Livewire AJAX requests. If you want to run middleware on every request, you can make it persistent by passing true as the second argument to the middleware() method:\n\n`true``middleware()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->middleware([\n            // ...\n        ], isPersistent: true);\n}\n```\n\n### #Applying middleware to authenticated routes\n\nYou can apply middleware to all authenticated routes by passing an array of middleware classes to the authMiddleware() method in the configuration:\n\n`authMiddleware()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->authMiddleware([\n            // ...\n        ]);\n}\n```\n\nBy default, middleware will be run when the page is first loaded, but not on subsequent Livewire AJAX requests. If you want to run middleware on every request, you can make it persistent by passing true as the second argument to the authMiddleware() method:\n\n`true``authMiddleware()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->authMiddleware([\n            // ...\n        ], isPersistent: true);\n}\n```\n\n## #Disabling broadcasting\n\nBy default, Laravel Echo will automatically connect for every panel, if credentials have been set up in the published config/filament.php configuration file. To disable this automatic connection in a panel, you can use the broadcasting(false) method:\n\n`config/filament.php``broadcasting(false)````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->broadcasting(false);\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Configuration - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Configuration",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "By default, the configuration file is located at app/Providers/Filament/AdminPanelProvider.php. Keep reading to learn more about panels and how each has its own configuration file.\n\n`app/Providers/Filament/AdminPanelProvider.php`## #Introducing panels\n\nBy default, when you install the package, there is one panel that has been set up for you - and it lives on /admin. All the resources, custom pages, and dashboard widgets you create get registered to this panel.\n\n`/admin`However, you can create as many panels as you want, and each can have its own set of resources, pages and widgets.\n\nFor example, you could build a panel where users can log in at /app and access their dashboard, and admins can log in at /admin and manage the app. The /app panel and the /admin panel have their own resources, since each group of users has different requirements. Filament allows you to do that by providing you with the ability to create multiple panels.\n\n`/app``/admin``/app``/admin`### #The default admin panel\n\nWhen you run filament:install, a new file is created in app/Providers/Filament - AdminPanelProvider.php. This file contains the configuration for the /admin panel.\n\n`filament:install``app/Providers/Filament``AdminPanelProvider.php``/admin`When this documentation refers to the “configuration”, this is the file you need to edit. It allows you to completely customize the app.",
                "level": 3
              },
              {
                "title": "### #Creating a new panel",
                "content": "To create a new panel, you can use the make:filament-panel command, passing in the unique name of the new panel:\n\n`make:filament-panel````\nphp artisan make:filament-panel app\n```\n\nThis command will create a new panel called “app”. A configuration file will be created at app/Providers/Filament/AppPanelProvider.php. You can access this panel at /app, but you can customize the path if you don’t want that.\n\n`app/Providers/Filament/AppPanelProvider.php``/app`Since this configuration file is also a Laravel service provider, it needs to be registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). Filament will attempt to do this for you, but if you get an error while trying to access your panel then this process has probably failed.\n\n`bootstrap/providers.php``config/app.php`## #Changing the path\n\nIn a panel configuration file, you can change the path that the app is accessible at using the path() method:\n\n`path()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->path('app');\n}\n```\n\nIf you want the app to be accessible without any prefix, you can set this to be an empty string:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->path('');\n}\n```\n\nMake sure your routes/web.php file doesn’t already define the '' or '/' route, as it will take precedence.\n\n`routes/web.php``''``'/'`## #Render hooks\n\nRender hooks allow you to render Blade content at various points in the framework views. You can register global render hooks in a service provider or middleware, but it also allows you to register render hooks that are specific to a panel. To do that, you can use the renderHook() method on the panel configuration object. Here’s an example, integrating wire-elements/modal with Filament:\n\n`renderHook()``wire-elements/modal````\nuse Filament\\Panel;\nuse Filament\\View\\PanelsRenderHook;\nuse Illuminate\\Support\\Facades\\Blade;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->renderHook(\n            PanelsRenderHook::BODY_START,\n            fn (): string => Blade::render('@livewire(\\'livewire-ui-modal\\')'),\n        );\n}\n```\n\nA full list of available render hooks can be found here.",
                "level": 4
              },
              {
                "title": "## #Setting a domain",
                "content": "By default, Filament will respond to requests from all domains. If you’d like to scope it to a specific domain, you can use the domain() method, similar to Route::domain() in Laravel:\n\n`domain()``Route::domain()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->domain('admin.example.com');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the maximum content width",
                "content": "By default, Filament will restrict the width of the content on the page, so it doesn’t become too wide on large screens. To change this, you may use the maxContentWidth() method. Options correspond to Tailwind’s max-width scale. The options are ExtraSmall, Small, Medium, Large, ExtraLarge, TwoExtraLarge, ThreeExtraLarge, FourExtraLarge, FiveExtraLarge, SixExtraLarge, SevenExtraLarge, Full, MinContent, MaxContent, FitContent,  Prose, ScreenSmall, ScreenMedium, ScreenLarge, ScreenExtraLarge and ScreenTwoExtraLarge. The default is SevenExtraLarge:\n\n`maxContentWidth()``ExtraSmall``Small``Medium``Large``ExtraLarge``TwoExtraLarge``ThreeExtraLarge``FourExtraLarge``FiveExtraLarge``SixExtraLarge``SevenExtraLarge``Full``MinContent``MaxContent``FitContent``Prose``ScreenSmall``ScreenMedium``ScreenLarge``ScreenExtraLarge``ScreenTwoExtraLarge``SevenExtraLarge````\nuse Filament\\Panel;\nuse Filament\\Support\\Enums\\MaxWidth;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->maxContentWidth(MaxWidth::Full);\n}\n```\n\nIf you’d like to set the max content width for pages of the type SimplePage, like login and registration pages, you may do so using the simplePageMaxContentWidth() method. The default is Large:\n\n`SimplePage``simplePageMaxContentWidth()``Large````\nuse Filament\\Panel;\nuse Filament\\Support\\Enums\\MaxWidth;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->simplePageMaxContentWidth(MaxWidth::Small);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Lifecycle hooks",
                "content": "Hooks may be used to execute code during a panel’s lifecycle. bootUsing() is a hook that gets run on every request that takes place within that panel. If you have multiple panels, only the current panel’s bootUsing() will be run. The function gets run from middleware, after all service providers have been booted:\n\n`bootUsing()``bootUsing()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->bootUsing(function (Panel $panel) {\n            // ...\n        });\n}\n```",
                "level": 3
              },
              {
                "title": "## #SPA mode",
                "content": "SPA mode utilizes Livewire’s wire:navigate feature to make your server-rendered panel feel like a single-page-application, with less delay between page loads and a loading bar for longer requests. To enable SPA mode on a panel, you can use the spa() method:\n\n`wire:navigate``spa()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->spa();\n}\n```",
                "level": 3
              },
              {
                "title": "### #Disabling SPA navigation for specific URLs",
                "content": "By default, when enabling SPA mode, any URL that lives on the same domain as the current request will be navigated to using Livewire’s wire:navigate feature. If you want to disable this for specific URLs, you can use the spaUrlExceptions() method:\n\n`wire:navigate``spaUrlExceptions()````\nuse App\\Filament\\Resources\\PostResource;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->spa()\n        ->spaUrlExceptions(fn (): array => [\n            url('/admin'),\n            PostResource::getUrl(),\n        ]);\n}\n```\n\n> In this example, we are using getUrl() on a resource to get the URL to the resource’s index page. This feature requires the panel to already be registered though, and the configuration is too early in the request lifecycle to do that. You can use a function to return the URLs instead, which will be resolved when the panel has been registered.\n\nIn this example, we are using getUrl() on a resource to get the URL to the resource’s index page. This feature requires the panel to already be registered though, and the configuration is too early in the request lifecycle to do that. You can use a function to return the URLs instead, which will be resolved when the panel has been registered.\n\n`getUrl()`These URLs need to exactly match the URL that the user is navigating to, including the domain and protocol. If you’d like to use a pattern to match multiple URLs, you can use an asterisk (*) as a wildcard character:\n\n`*````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->spa()\n        ->spaUrlExceptions([\n            '*/admin/posts/*',\n        ]);\n}\n```",
                "level": 4
              },
              {
                "title": "## #Unsaved changes alerts",
                "content": "You may alert users if they attempt to navigate away from a page without saving their changes. This is applied on Create and Edit pages of a resource, as well as any open action modals. To enable this feature, you can use the unsavedChangesAlerts() method:\n\n`unsavedChangesAlerts()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->unsavedChangesAlerts();\n}\n```",
                "level": 3
              },
              {
                "title": "## #Enabling database transactions",
                "content": "By default, Filament does not wrap operations in database transactions, and allows the user to enable this themselves when they have tested to ensure that their operations are safe to be wrapped in a transaction. However, you can enable database transactions at once for all operations by using the databaseTransactions() method:\n\n`databaseTransactions()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->databaseTransactions();\n}\n```\n\nFor any actions you do not want to be wrapped in a transaction, you can use the databaseTransaction(false) method:\n\n`databaseTransaction(false)````\nCreateAction::make()\n    ->databaseTransaction(false)\n```\n\nAnd for any pages like Create resource and Edit resource, you can define the $hasDatabaseTransactions property to false on the page class:\n\n`$hasDatabaseTransactions``false````\nuse Filament\\Resources\\Pages\\CreateRecord;\n\nclass CreatePost extends CreateRecord\n{\n    protected ?bool $hasDatabaseTransactions = false;\n\n    // ...\n}\n```",
                "level": 3
              },
              {
                "title": "### #Opting in to database transactions for specific actions and pages",
                "content": "Instead of enabling database transactions everywhere and opting out of them for specific actions and pages, you can opt in to database transactions for specific actions and pages.\n\nFor actions, you can use the databaseTransaction() method:\n\n`databaseTransaction()````\nCreateAction::make()\n    ->databaseTransaction()\n```\n\nFor pages like Create resource and Edit resource, you can define the $hasDatabaseTransactions property to true on the page class:\n\n`$hasDatabaseTransactions``true````\nuse Filament\\Resources\\Pages\\CreateRecord;\n\nclass CreatePost extends CreateRecord\n{\n    protected ?bool $hasDatabaseTransactions = true;\n\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "## #Registering assets for a panel",
                "content": "You can register assets that will only be loaded on pages within a specific panel, and not in the rest of the app. To do that, pass an array of assets to the assets() method:\n\n`assets()````\nuse Filament\\Panel;\nuse Filament\\Support\\Assets\\Css;\nuse Filament\\Support\\Assets\\Js;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->assets([\n            Css::make('custom-stylesheet', resource_path('css/custom.css')),\n            Js::make('custom-script', resource_path('js/custom.js')),\n        ]);\n}\n```\n\nBefore these assets can be used, you’ll need to run php artisan filament:assets.\n\n`php artisan filament:assets`## #Applying middleware\n\nYou can apply extra middleware to all routes by passing an array of middleware classes to the middleware() method in the configuration:\n\n`middleware()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->middleware([\n            // ...\n        ]);\n}\n```\n\nBy default, middleware will be run when the page is first loaded, but not on subsequent Livewire AJAX requests. If you want to run middleware on every request, you can make it persistent by passing true as the second argument to the middleware() method:\n\n`true``middleware()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->middleware([\n            // ...\n        ], isPersistent: true);\n}\n```",
                "level": 3
              },
              {
                "title": "### #Applying middleware to authenticated routes",
                "content": "You can apply middleware to all authenticated routes by passing an array of middleware classes to the authMiddleware() method in the configuration:\n\n`authMiddleware()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->authMiddleware([\n            // ...\n        ]);\n}\n```\n\nBy default, middleware will be run when the page is first loaded, but not on subsequent Livewire AJAX requests. If you want to run middleware on every request, you can make it persistent by passing true as the second argument to the authMiddleware() method:\n\n`true``authMiddleware()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->authMiddleware([\n            // ...\n        ], isPersistent: true);\n}\n```",
                "level": 4
              },
              {
                "title": "## #Disabling broadcasting",
                "content": "By default, Laravel Echo will automatically connect for every panel, if credentials have been set up in the published config/filament.php configuration file. To disable this automatic connection in a panel, you can use the broadcasting(false) method:\n\n`config/filament.php``broadcasting(false)````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->broadcasting(false);\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Creating a new panel",
              "Setting a domain",
              "Customizing the maximum content width",
              "Lifecycle hooks",
              "SPA mode",
              "Disabling SPA navigation for specific URLs",
              "Unsaved changes alerts",
              "Enabling database transactions",
              "Opting in to database transactions for specific actions and pages"
            ],
            "code_examples_count": 46,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "clusters": {
          "metadata": {
            "title": "Clusters",
            "url": "https://filamentphp.com/docs/3.x/panels/clusters",
            "section": "panels",
            "word_count": 719,
            "character_count": 5102
          },
          "content": {
            "full_text": "\n# Clusters - Panels - Filament\n\nPanels\n\n# Clusters\n\n## #Overview\n\nClusters are a hierarchical structure in panels that allow you to group resources and custom pages together. They are useful for organizing your panel into logical sections, and can help reduce the size of your panel’s sidebar.\n\nWhen using a cluster, a few things happen:\n\n- A new navigation item is added to the navigation, which is a link to the first resource or page in the cluster.\n- The individual navigation items for the resources or pages are no longer visible in the main navigation.\n- A new sub-navigation UI is added to each resource or page in the cluster, which contains the navigation items for the resources or pages in the cluster.\n- Resources and pages in the cluster get a new URL, prefixed with the name of the cluster. If you are generating URLs to resources and pages correctly, then this change should be handled for you automatically.\n- The cluster’s name is in the breadcrumbs of all resources and pages in the cluster. When clicking it, you are taken to the first resource or page in the cluster.\n\n## #Creating a cluster\n\nBefore creating your first cluster, you must tell the panel where cluster classes should be located. Alongside methods like discoverResources() and discoverPages() in the configuration, you can use discoverClusters():\n\n`discoverResources()``discoverPages()``discoverClusters()````\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->discoverResources(in: app_path('Filament/Resources'), for: 'App\\\\Filament\\\\Resources')\n        ->discoverPages(in: app_path('Filament/Pages'), for: 'App\\\\Filament\\\\Pages')\n        ->discoverClusters(in: app_path('Filament/Clusters'), for: 'App\\\\Filament\\\\Clusters');\n}\n```\n\nNow, you can create a cluster with the php artisan make:filament-cluster command:\n\n`php artisan make:filament-cluster````\nphp artisan make:filament-cluster Settings\n```\n\nThis will create a new cluster class in the app/Filament/Clusters directory:\n\n`app/Filament/Clusters````\n<?php\n\nnamespace App\\Filament\\Clusters;\n\nuse Filament\\Clusters\\Cluster;\n\nclass Settings extends Cluster\n{\n    protected static ?string $navigationIcon = 'heroicon-o-squares-2x2';\n}\n```\n\nThe $navigationIcon property is defined by default since you will most likely want to customize this immediately. All other navigation properties and methods are also available to use, including $navigationLabel, $navigationSort and $navigationGroup. These are used to customize the cluster’s main navigation item, in the same way you would customize the item for a resource or page.\n\n`$navigationIcon``$navigationLabel``$navigationSort``$navigationGroup`## #Adding resources and pages to a cluster\n\nTo add resources and pages to a cluster, you just need to define the $cluster property on the resource or page class, and set it to the cluster class you created:\n\n`$cluster````\nuse App\\Filament\\Clusters\\Settings;\n\nprotected static ?string $cluster = Settings::class;\n```\n\n## #Code structure recommendations for panels using clusters\n\nWhen using clusters, it is recommended that you move all of your resources and pages into a directory with the same name as the cluster. For example, here is a directory structure for a panel that uses a cluster called Settings, containing a ColorResource and two custom pages:\n\n`Settings``ColorResource````\n.\n+-- Clusters\n|   +-- Settings.php\n|   +-- Settings\n|   |   +-- Pages\n|   |   |   +-- ManageBranding.php\n|   |   |   +-- ManageNotifications.php\n|   |   +-- Resources\n|   |   |   +-- ColorResource.php\n|   |   |   +-- ColorResource\n|   |   |   |   +-- Pages\n|   |   |   |   |   +-- CreateColor.php\n|   |   |   |   |   +-- EditColor.php\n|   |   |   |   |   +-- ListColors.php\n```\n\nThis is a recommendation, not a requirement. You can structure your panel however you like, as long as the resources and pages in your cluster use the $cluster property. This is just a suggestion to help you keep your panel organized.\n\n`$cluster`When a cluster exists in your panel, and you generate new resources or pages with the make:filament-resource or make:filament-page commands, you will be asked if you want to create them inside a cluster directory, according to these guidelines. If you choose to, then Filament will also assign the correct $cluster property to the resource or page class for you. If you do not, you will need to define the $cluster property yourself.\n\n`make:filament-resource``make:filament-page``$cluster``$cluster`## #Customizing the cluster breadcrumb\n\nThe cluster’s name is in the breadcrumbs of all resources and pages in the cluster.\n\nYou may customize the breadcrumb name using the $clusterBreadcrumb property in the cluster class:\n\n`$clusterBreadcrumb````\nprotected static ?string $clusterBreadcrumb = 'cluster';\n```\n\nAlternatively, you may use the getClusterBreadcrumb() to define a dynamic breadcrumb name:\n\n`getClusterBreadcrumb()````\npublic static function getClusterBreadcrumb(): string\n{\n    return __('filament/clusters/cluster.name');\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Clusters - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Clusters",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Clusters are a hierarchical structure in panels that allow you to group resources and custom pages together. They are useful for organizing your panel into logical sections, and can help reduce the size of your panel’s sidebar.\n\nWhen using a cluster, a few things happen:\n\n- A new navigation item is added to the navigation, which is a link to the first resource or page in the cluster.\n- The individual navigation items for the resources or pages are no longer visible in the main navigation.\n- A new sub-navigation UI is added to each resource or page in the cluster, which contains the navigation items for the resources or pages in the cluster.\n- Resources and pages in the cluster get a new URL, prefixed with the name of the cluster. If you are generating URLs to resources and pages correctly, then this change should be handled for you automatically.\n- The cluster’s name is in the breadcrumbs of all resources and pages in the cluster. When clicking it, you are taken to the first resource or page in the cluster.",
                "level": 3
              },
              {
                "title": "## #Creating a cluster",
                "content": "Before creating your first cluster, you must tell the panel where cluster classes should be located. Alongside methods like discoverResources() and discoverPages() in the configuration, you can use discoverClusters():\n\n`discoverResources()``discoverPages()``discoverClusters()````\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->discoverResources(in: app_path('Filament/Resources'), for: 'App\\\\Filament\\\\Resources')\n        ->discoverPages(in: app_path('Filament/Pages'), for: 'App\\\\Filament\\\\Pages')\n        ->discoverClusters(in: app_path('Filament/Clusters'), for: 'App\\\\Filament\\\\Clusters');\n}\n```\n\nNow, you can create a cluster with the php artisan make:filament-cluster command:\n\n`php artisan make:filament-cluster````\nphp artisan make:filament-cluster Settings\n```\n\nThis will create a new cluster class in the app/Filament/Clusters directory:\n\n`app/Filament/Clusters````\n<?php\n\nnamespace App\\Filament\\Clusters;\n\nuse Filament\\Clusters\\Cluster;\n\nclass Settings extends Cluster\n{\n    protected static ?string $navigationIcon = 'heroicon-o-squares-2x2';\n}\n```\n\nThe $navigationIcon property is defined by default since you will most likely want to customize this immediately. All other navigation properties and methods are also available to use, including $navigationLabel, $navigationSort and $navigationGroup. These are used to customize the cluster’s main navigation item, in the same way you would customize the item for a resource or page.\n\n`$navigationIcon``$navigationLabel``$navigationSort``$navigationGroup`## #Adding resources and pages to a cluster\n\nTo add resources and pages to a cluster, you just need to define the $cluster property on the resource or page class, and set it to the cluster class you created:\n\n`$cluster````\nuse App\\Filament\\Clusters\\Settings;\n\nprotected static ?string $cluster = Settings::class;\n```",
                "level": 3
              },
              {
                "title": "## #Code structure recommendations for panels using clusters",
                "content": "When using clusters, it is recommended that you move all of your resources and pages into a directory with the same name as the cluster. For example, here is a directory structure for a panel that uses a cluster called Settings, containing a ColorResource and two custom pages:\n\n`Settings``ColorResource````\n.\n+-- Clusters\n|   +-- Settings.php\n|   +-- Settings\n|   |   +-- Pages\n|   |   |   +-- ManageBranding.php\n|   |   |   +-- ManageNotifications.php\n|   |   +-- Resources\n|   |   |   +-- ColorResource.php\n|   |   |   +-- ColorResource\n|   |   |   |   +-- Pages\n|   |   |   |   |   +-- CreateColor.php\n|   |   |   |   |   +-- EditColor.php\n|   |   |   |   |   +-- ListColors.php\n```\n\nThis is a recommendation, not a requirement. You can structure your panel however you like, as long as the resources and pages in your cluster use the $cluster property. This is just a suggestion to help you keep your panel organized.\n\n`$cluster`When a cluster exists in your panel, and you generate new resources or pages with the make:filament-resource or make:filament-page commands, you will be asked if you want to create them inside a cluster directory, according to these guidelines. If you choose to, then Filament will also assign the correct $cluster property to the resource or page class for you. If you do not, you will need to define the $cluster property yourself.\n\n`make:filament-resource``make:filament-page``$cluster``$cluster`## #Customizing the cluster breadcrumb\n\nThe cluster’s name is in the breadcrumbs of all resources and pages in the cluster.\n\nYou may customize the breadcrumb name using the $clusterBreadcrumb property in the cluster class:\n\n`$clusterBreadcrumb````\nprotected static ?string $clusterBreadcrumb = 'cluster';\n```\n\nAlternatively, you may use the getClusterBreadcrumb() to define a dynamic breadcrumb name:\n\n`getClusterBreadcrumb()````\npublic static function getClusterBreadcrumb(): string\n{\n    return __('filament/clusters/cluster.name');\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Creating a cluster",
              "Code structure recommendations for panels using clusters"
            ],
            "code_examples_count": 14,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "multi-tenancy": {
          "metadata": {
            "title": "Multi Tenancy",
            "url": "https://filamentphp.com/docs/3.x/panels/multi-tenancy",
            "section": "panels",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "themes": {
          "metadata": {
            "title": "Themes",
            "url": "https://filamentphp.com/docs/3.x/panels/themes",
            "section": "panels",
            "word_count": 1332,
            "character_count": 9478
          },
          "content": {
            "full_text": "\n# Themes - Panels - Filament\n\nPanels\n\n# Themes\n\n## #Changing the colors\n\nIn the configuration, you can easily change the colors that are used. Filament ships with 6 predefined colors that are used everywhere within the framework. They are customizable as follows:\n\n```\nuse Filament\\Panel;\nuse Filament\\Support\\Colors\\Color;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->colors([\n            'danger' => Color::Rose,\n            'gray' => Color::Gray,\n            'info' => Color::Blue,\n            'primary' => Color::Indigo,\n            'success' => Color::Emerald,\n            'warning' => Color::Orange,\n        ]);\n}\n```\n\nThe Filament\\Support\\Colors\\Color class contains color options for all Tailwind CSS color palettes.\n\n`Filament\\Support\\Colors\\Color`You can also pass in a function to register() which will only get called when the app is getting rendered. This is useful if you are calling register() from a service provider, and want to access objects like the currently authenticated user, which are initialized later in middleware.\n\n`register()``register()`Alternatively, you may pass your own palette in as an array of RGB values:\n\n```\n$panel\n    ->colors([\n        'primary' => [\n            50 => '238, 242, 255',\n            100 => '224, 231, 255',\n            200 => '199, 210, 254',\n            300 => '165, 180, 252',\n            400 => '129, 140, 248',\n            500 => '99, 102, 241',\n            600 => '79, 70, 229',\n            700 => '67, 56, 202',\n            800 => '55, 48, 163',\n            900 => '49, 46, 129',\n            950 => '30, 27, 75',\n        ],\n    ])\n```\n\n### #Generating a color palette\n\nIf you want us to attempt to generate a palette for you based on a singular hex or RGB value, you can pass that in:\n\n```\n$panel\n    ->colors([\n        'primary' => '#6366f1',\n    ])\n\n$panel\n    ->colors([\n        'primary' => 'rgb(99, 102, 241)',\n    ])\n```\n\n## #Changing the font\n\nBy default, we use the Inter font. You can change this using the font() method in the configuration file:\n\n`font()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->font('Poppins');\n}\n```\n\nAll Google Fonts are available to use.\n\n### #Changing the font provider\n\nBunny Fonts CDN is used to serve the fonts. It is GDPR-compliant. If you’d like to use Google Fonts CDN instead, you can do so using the provider argument of the font() method:\n\n`provider``font()````\nuse Filament\\FontProviders\\GoogleFontProvider;\n\n$panel->font('Inter', provider: GoogleFontProvider::class)\n```\n\nOr if you’d like to serve the fonts from a local stylesheet, you can use the LocalFontProvider:\n\n`LocalFontProvider````\nuse Filament\\FontProviders\\LocalFontProvider;\n\n$panel->font(\n    'Inter',\n    url: asset('css/fonts.css'),\n    provider: LocalFontProvider::class,\n)\n```\n\n## #Creating a custom theme\n\nFilament allows you to change the CSS used to render the UI by compiling a custom stylesheet to replace the default one. This custom stylesheet is called a “theme”.\n\nThemes use Tailwind CSS, the Tailwind Forms plugin, the Tailwind Typography plugin, the PostCSS Nesting plugin, and Autoprefixer.\n\n> Filament v3 uses Tailwind CSS v3 for styling. As such, when creating a theme, you need to use Tailwind CSS v3. The php artisan make:filament-theme command will install Tailwind CSS v3 if you do not have it installed already. If you have Tailwind CSS v4 installed, it will not fully install the necessary Vite configuration to compile the theme. We suggest that you either use the Tailwind CLI to compile the theme, or downgrade your project to Tailwind CSS v3. The command to compile the theme with the Tailwind CLI will be output when you run the make:filament-theme command. You could save this command into a script in package.json for easy use.\nFilament v4 will support Tailwind CSS v4.\n\nFilament v3 uses Tailwind CSS v3 for styling. As such, when creating a theme, you need to use Tailwind CSS v3. The php artisan make:filament-theme command will install Tailwind CSS v3 if you do not have it installed already. If you have Tailwind CSS v4 installed, it will not fully install the necessary Vite configuration to compile the theme. We suggest that you either use the Tailwind CLI to compile the theme, or downgrade your project to Tailwind CSS v3. The command to compile the theme with the Tailwind CLI will be output when you run the make:filament-theme command. You could save this command into a script in package.json for easy use.\n\n`php artisan make:filament-theme``make:filament-theme``package.json`Filament v4 will support Tailwind CSS v4.\n\nTo create a custom theme for a panel, you can use the php artisan make:filament-theme command:\n\n`php artisan make:filament-theme````\nphp artisan make:filament-theme\n```\n\nIf you have multiple panels, you can specify the panel you want to create a theme for:\n\n```\nphp artisan make:filament-theme admin\n```\n\nBy default, this command will use NPM to install dependencies. If you want to use a different package manager, you can use the --pm option:\n\n`--pm````\nphp artisan make:filament-theme --pm=bun\n```\n\nThe command will create a CSS file and Tailwind Configuration file in the /resources/css/filament directory. You can then customize the theme by editing these files. It will also give you instructions on how to compile the theme and register it in Filament. Please follow the instructions in the command to complete the setup process:\n\n`/resources/css/filament````\n⇂ First, add a new item to the `input` array of `vite.config.js`: `resources/css/filament/admin/theme.css`\n⇂ Next, register the theme in the admin panel provider using `->viteTheme('resources/css/filament/admin/theme.css')`\n⇂ Finally, run `npm run build` to compile the theme\n```\n\nPlease reference the command to see the exact file names that you need to register, they may not be admin/theme.css.\n\n`admin/theme.css`If you have Tailwind v4 installed, the output may look like this:\n\n```\n⇂ It looks like you have Tailwind v4 installed. Filament uses Tailwind v3. You should downgrade your project and re-run this command with `--force`, or use the following command to compile the theme with the Tailwind v3 CLI:\n⇂ npx tailwindcss@3 --input ./resources/css/filament/admin/theme.css --output ./public/css/filament/admin/theme.css --config ./resources/css/filament/admin/tailwind.config.js --minify\n⇂ Make sure to register the theme in the admin panel provider using `->theme(asset('css/filament/admin/theme.css'))`\n```\n\n## #Disabling dark mode\n\nTo disable dark mode switching, you can use the configuration file:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->darkMode(false);\n}\n```\n\n## #Changing the default theme mode\n\nBy default, Filament uses the user’s system theme as the default mode. For example, if the user’s computer is in dark mode, Filament will use dark mode by default. The system mode in Filament is reactive if the user changes their computer’s mode. If you want to change the default mode to force light or dark mode, you can use the defaultThemeMode() method, passing ThemeMode::Light or ThemeMode::Dark:\n\n`defaultThemeMode()``ThemeMode::Light``ThemeMode::Dark````\nuse Filament\\Enums\\ThemeMode;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->defaultThemeMode(ThemeMode::Light);\n}\n```\n\n## #Adding a logo\n\nBy default, Filament uses your app’s name to render a simple text-based logo. However, you can easily customize this.\n\nIf you want to simply change the text that is used in the logo, you can use the brandName() method:\n\n`brandName()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->brandName('Filament Demo');\n}\n```\n\nTo render an image instead, you can pass a URL to the brandLogo() method:\n\n`brandLogo()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->brandLogo(asset('images/logo.svg'));\n}\n```\n\nAlternatively, you may directly pass HTML to the brandLogo() method to render an inline SVG element for example:\n\n`brandLogo()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->brandLogo(fn () => view('filament.admin.logo'));\n}\n```\n\n```\n<svg\n    viewBox=\"0 0 128 26\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    class=\"h-full fill-gray-500 dark:fill-gray-400\"\n>\n    <!-- ... -->\n</svg>\n```\n\nIf you need a different logo to be used when the application is in dark mode, you can pass it to darkModeBrandLogo() in the same way.\n\n`darkModeBrandLogo()`The logo height defaults to a sensible value, but it’s impossible to account for all possible aspect ratios. Therefore, you may customize the height of the rendered logo using the brandLogoHeight() method:\n\n`brandLogoHeight()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->brandLogo(fn () => view('filament.admin.logo'))\n        ->brandLogoHeight('2rem');\n}\n```\n\n## #Adding a favicon\n\nTo add a favicon, you can use the configuration file, passing the public URL of the favicon:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->favicon(asset('images/favicon.png'));\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Themes - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Themes",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Changing the colors",
                "content": "In the configuration, you can easily change the colors that are used. Filament ships with 6 predefined colors that are used everywhere within the framework. They are customizable as follows:\n\n```\nuse Filament\\Panel;\nuse Filament\\Support\\Colors\\Color;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->colors([\n            'danger' => Color::Rose,\n            'gray' => Color::Gray,\n            'info' => Color::Blue,\n            'primary' => Color::Indigo,\n            'success' => Color::Emerald,\n            'warning' => Color::Orange,\n        ]);\n}\n```\n\nThe Filament\\Support\\Colors\\Color class contains color options for all Tailwind CSS color palettes.\n\n`Filament\\Support\\Colors\\Color`You can also pass in a function to register() which will only get called when the app is getting rendered. This is useful if you are calling register() from a service provider, and want to access objects like the currently authenticated user, which are initialized later in middleware.\n\n`register()``register()`Alternatively, you may pass your own palette in as an array of RGB values:\n\n```\n$panel\n    ->colors([\n        'primary' => [\n            50 => '238, 242, 255',\n            100 => '224, 231, 255',\n            200 => '199, 210, 254',\n            300 => '165, 180, 252',\n            400 => '129, 140, 248',\n            500 => '99, 102, 241',\n            600 => '79, 70, 229',\n            700 => '67, 56, 202',\n            800 => '55, 48, 163',\n            900 => '49, 46, 129',\n            950 => '30, 27, 75',\n        ],\n    ])\n```",
                "level": 3
              },
              {
                "title": "### #Generating a color palette",
                "content": "If you want us to attempt to generate a palette for you based on a singular hex or RGB value, you can pass that in:\n\n```\n$panel\n    ->colors([\n        'primary' => '#6366f1',\n    ])\n\n$panel\n    ->colors([\n        'primary' => 'rgb(99, 102, 241)',\n    ])\n```",
                "level": 4
              },
              {
                "title": "## #Changing the font",
                "content": "By default, we use the Inter font. You can change this using the font() method in the configuration file:\n\n`font()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->font('Poppins');\n}\n```\n\nAll Google Fonts are available to use.",
                "level": 3
              },
              {
                "title": "### #Changing the font provider",
                "content": "Bunny Fonts CDN is used to serve the fonts. It is GDPR-compliant. If you’d like to use Google Fonts CDN instead, you can do so using the provider argument of the font() method:\n\n`provider``font()````\nuse Filament\\FontProviders\\GoogleFontProvider;\n\n$panel->font('Inter', provider: GoogleFontProvider::class)\n```\n\nOr if you’d like to serve the fonts from a local stylesheet, you can use the LocalFontProvider:\n\n`LocalFontProvider````\nuse Filament\\FontProviders\\LocalFontProvider;\n\n$panel->font(\n    'Inter',\n    url: asset('css/fonts.css'),\n    provider: LocalFontProvider::class,\n)\n```",
                "level": 4
              },
              {
                "title": "## #Creating a custom theme",
                "content": "Filament allows you to change the CSS used to render the UI by compiling a custom stylesheet to replace the default one. This custom stylesheet is called a “theme”.\n\nThemes use Tailwind CSS, the Tailwind Forms plugin, the Tailwind Typography plugin, the PostCSS Nesting plugin, and Autoprefixer.\n\n> Filament v3 uses Tailwind CSS v3 for styling. As such, when creating a theme, you need to use Tailwind CSS v3. The php artisan make:filament-theme command will install Tailwind CSS v3 if you do not have it installed already. If you have Tailwind CSS v4 installed, it will not fully install the necessary Vite configuration to compile the theme. We suggest that you either use the Tailwind CLI to compile the theme, or downgrade your project to Tailwind CSS v3. The command to compile the theme with the Tailwind CLI will be output when you run the make:filament-theme command. You could save this command into a script in package.json for easy use.\nFilament v4 will support Tailwind CSS v4.\n\nFilament v3 uses Tailwind CSS v3 for styling. As such, when creating a theme, you need to use Tailwind CSS v3. The php artisan make:filament-theme command will install Tailwind CSS v3 if you do not have it installed already. If you have Tailwind CSS v4 installed, it will not fully install the necessary Vite configuration to compile the theme. We suggest that you either use the Tailwind CLI to compile the theme, or downgrade your project to Tailwind CSS v3. The command to compile the theme with the Tailwind CLI will be output when you run the make:filament-theme command. You could save this command into a script in package.json for easy use.\n\n`php artisan make:filament-theme``make:filament-theme``package.json`Filament v4 will support Tailwind CSS v4.\n\nTo create a custom theme for a panel, you can use the php artisan make:filament-theme command:\n\n`php artisan make:filament-theme````\nphp artisan make:filament-theme\n```\n\nIf you have multiple panels, you can specify the panel you want to create a theme for:\n\n```\nphp artisan make:filament-theme admin\n```\n\nBy default, this command will use NPM to install dependencies. If you want to use a different package manager, you can use the --pm option:\n\n`--pm````\nphp artisan make:filament-theme --pm=bun\n```\n\nThe command will create a CSS file and Tailwind Configuration file in the /resources/css/filament directory. You can then customize the theme by editing these files. It will also give you instructions on how to compile the theme and register it in Filament. Please follow the instructions in the command to complete the setup process:\n\n`/resources/css/filament````\n⇂ First, add a new item to the `input` array of `vite.config.js`: `resources/css/filament/admin/theme.css`\n⇂ Next, register the theme in the admin panel provider using `->viteTheme('resources/css/filament/admin/theme.css')`\n⇂ Finally, run `npm run build` to compile the theme\n```\n\nPlease reference the command to see the exact file names that you need to register, they may not be admin/theme.css.\n\n`admin/theme.css`If you have Tailwind v4 installed, the output may look like this:\n\n```\n⇂ It looks like you have Tailwind v4 installed. Filament uses Tailwind v3. You should downgrade your project and re-run this command with `--force`, or use the following command to compile the theme with the Tailwind v3 CLI:\n⇂ npx tailwindcss@3 --input ./resources/css/filament/admin/theme.css --output ./public/css/filament/admin/theme.css --config ./resources/css/filament/admin/tailwind.config.js --minify\n⇂ Make sure to register the theme in the admin panel provider using `->theme(asset('css/filament/admin/theme.css'))`\n```",
                "level": 3
              },
              {
                "title": "## #Disabling dark mode",
                "content": "To disable dark mode switching, you can use the configuration file:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->darkMode(false);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Changing the default theme mode",
                "content": "By default, Filament uses the user’s system theme as the default mode. For example, if the user’s computer is in dark mode, Filament will use dark mode by default. The system mode in Filament is reactive if the user changes their computer’s mode. If you want to change the default mode to force light or dark mode, you can use the defaultThemeMode() method, passing ThemeMode::Light or ThemeMode::Dark:\n\n`defaultThemeMode()``ThemeMode::Light``ThemeMode::Dark````\nuse Filament\\Enums\\ThemeMode;\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->defaultThemeMode(ThemeMode::Light);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Adding a logo",
                "content": "By default, Filament uses your app’s name to render a simple text-based logo. However, you can easily customize this.\n\nIf you want to simply change the text that is used in the logo, you can use the brandName() method:\n\n`brandName()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->brandName('Filament Demo');\n}\n```\n\nTo render an image instead, you can pass a URL to the brandLogo() method:\n\n`brandLogo()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->brandLogo(asset('images/logo.svg'));\n}\n```\n\nAlternatively, you may directly pass HTML to the brandLogo() method to render an inline SVG element for example:\n\n`brandLogo()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->brandLogo(fn () => view('filament.admin.logo'));\n}\n```\n\n```\n<svg\n    viewBox=\"0 0 128 26\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    class=\"h-full fill-gray-500 dark:fill-gray-400\"\n>\n    <!-- ... -->\n</svg>\n```\n\nIf you need a different logo to be used when the application is in dark mode, you can pass it to darkModeBrandLogo() in the same way.\n\n`darkModeBrandLogo()`The logo height defaults to a sensible value, but it’s impossible to account for all possible aspect ratios. Therefore, you may customize the height of the rendered logo using the brandLogoHeight() method:\n\n`brandLogoHeight()````\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->brandLogo(fn () => view('filament.admin.logo'))\n        ->brandLogoHeight('2rem');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Adding a favicon",
                "content": "To add a favicon, you can use the configuration file, passing the public URL of the favicon:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->favicon(asset('images/favicon.png'));\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Changing the colors",
              "Generating a color palette",
              "Changing the font",
              "Changing the font provider",
              "Creating a custom theme",
              "Disabling dark mode",
              "Changing the default theme mode",
              "Adding a logo",
              "Adding a favicon"
            ],
            "code_examples_count": 38,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "plugin-development": {
          "metadata": {
            "title": "Plugin Development",
            "url": "https://filamentphp.com/docs/3.x/panels/plugin-development",
            "section": "panels",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "testing": {
          "metadata": {
            "title": "Testing",
            "url": "https://filamentphp.com/docs/3.x/panels/testing",
            "section": "panels",
            "word_count": 1048,
            "character_count": 9615
          },
          "content": {
            "full_text": "\n# Testing - Panels - Filament\n\nPanels\n\n# Testing\n\n## #Overview\n\nAll examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\nSince all pages in the app are Livewire components, we’re just using Livewire testing helpers everywhere. If you’ve never tested Livewire components before, please read this guide from the Livewire docs.\n\n## #Getting started\n\nEnsure that you are authenticated to access the app in your TestCase:\n\n`TestCase````\nprotected function setUp(): void\n{\n    parent::setUp();\n\n    $this->actingAs(User::factory()->create());\n}\n```\n\n### #Testing multiple panels\n\nIf you have multiple panels and you would like to test a non-default panel, you will need to tell Filament which panel you are testing. This can be done in the setUp() method of the test case, or you can do it at the start of a particular test. Filament usually does this in a middleware when you access the panel through a request, so if you’re not making a request in your test like when testing a Livewire component, you need to set the current panel manually:\n\n`setUp()````\nuse Filament\\Facades\\Filament;\n\nFilament::setCurrentPanel(\n    Filament::getPanel('app'), // Where `app` is the ID of the panel you want to test.\n);\n```\n\n## #Resources\n\n### #Pages\n\n#### #List\n\n##### #Routing & render\n\nTo ensure that the List page for the PostResource is able to render successfully, generate a page URL, perform a request to this URL and ensure that it is successful:\n\n`PostResource````\nit('can render page', function () {\n    $this->get(PostResource::getUrl('index'))->assertSuccessful();\n});\n```\n\n##### #Table\n\nFilament includes a selection of helpers for testing tables. A full guide to testing tables can be found in the Table Builder documentation.\n\nTo use a table testing helper, make assertions on the resource’s List page class, which holds the table:\n\n```\nuse function Pest\\Livewire\\livewire;\n\nit('can list posts', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts);\n});\n```\n\n#### #Create\n\n##### #Routing & render\n\nTo ensure that the Create page for the PostResource is able to render successfully, generate a page URL, perform a request to this URL and ensure that it is successful:\n\n`PostResource````\nit('can render page', function () {\n    $this->get(PostResource::getUrl('create'))->assertSuccessful();\n});\n```\n\n##### #Creating\n\nYou may check that data is correctly saved into the database by calling fillForm() with your form data, and then asserting that the database contains a matching record:\n\n`fillForm()````\nuse function Pest\\Livewire\\livewire;\n\nit('can create', function () {\n    $newData = Post::factory()->make();\n\n    livewire(PostResource\\Pages\\CreatePost::class)\n        ->fillForm([\n            'author_id' => $newData->author->getKey(),\n            'content' => $newData->content,\n            'tags' => $newData->tags,\n            'title' => $newData->title,\n        ])\n        ->call('create')\n        ->assertHasNoFormErrors();\n\n    $this->assertDatabaseHas(Post::class, [\n        'author_id' => $newData->author->getKey(),\n        'content' => $newData->content,\n        'tags' => json_encode($newData->tags),\n        'title' => $newData->title,\n    ]);\n});\n```\n\n##### #Validation\n\nUse assertHasFormErrors() to ensure that data is properly validated in a form:\n\n`assertHasFormErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate input', function () {\n    livewire(PostResource\\Pages\\CreatePost::class)\n        ->fillForm([\n            'title' => null,\n        ])\n        ->call('create')\n        ->assertHasFormErrors(['title' => 'required']);\n});\n```\n\n#### #Edit\n\n##### #Routing & render\n\nTo ensure that the Edit page for the PostResource is able to render successfully, generate a page URL, perform a request to this URL and ensure that it is successful:\n\n`PostResource````\nit('can render page', function () {\n    $this->get(PostResource::getUrl('edit', [\n        'record' => Post::factory()->create(),\n    ]))->assertSuccessful();\n});\n```\n\n##### #Filling existing data\n\nTo check that the form is filled with the correct data from the database, you may assertFormSet() that the data in the form matches that of the record:\n\n`assertFormSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can retrieve data', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\EditPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->assertFormSet([\n            'author_id' => $post->author->getKey(),\n            'content' => $post->content,\n            'tags' => $post->tags,\n            'title' => $post->title,\n        ]);\n});\n```\n\n##### #Saving\n\nYou may check that data is correctly saved into the database by calling fillForm() with your form data, and then asserting that the database contains a matching record:\n\n`fillForm()````\nuse function Pest\\Livewire\\livewire;\n\nit('can save', function () {\n    $post = Post::factory()->create();\n    $newData = Post::factory()->make();\n\n    livewire(PostResource\\Pages\\EditPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->fillForm([\n            'author_id' => $newData->author->getKey(),\n            'content' => $newData->content,\n            'tags' => $newData->tags,\n            'title' => $newData->title,\n        ])\n        ->call('save')\n        ->assertHasNoFormErrors();\n\n    expect($post->refresh())\n        ->author_id->toBe($newData->author->getKey())\n        ->content->toBe($newData->content)\n        ->tags->toBe($newData->tags)\n        ->title->toBe($newData->title);\n});\n```\n\n##### #Validation\n\nUse assertHasFormErrors() to ensure that data is properly validated in a form:\n\n`assertHasFormErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate input', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\EditPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->fillForm([\n            'title' => null,\n        ])\n        ->call('save')\n        ->assertHasFormErrors(['title' => 'required']);\n});\n```\n\n##### #Deleting\n\nYou can test the DeleteAction using callAction():\n\n`DeleteAction``callAction()````\nuse Filament\\Actions\\DeleteAction;\nuse function Pest\\Livewire\\livewire;\n\nit('can delete', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\EditPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->callAction(DeleteAction::class);\n\n    $this->assertModelMissing($post);\n});\n```\n\nYou can ensure that a particular user is not able to see a DeleteAction using assertActionHidden():\n\n`DeleteAction``assertActionHidden()````\nuse Filament\\Actions\\DeleteAction;\nuse function Pest\\Livewire\\livewire;\n\nit('can not delete', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\EditPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->assertActionHidden(DeleteAction::class);\n});\n```\n\n#### #View\n\n##### #Routing & render\n\nTo ensure that the View page for the PostResource is able to render successfully, generate a page URL, perform a request to this URL and ensure that it is successful:\n\n`PostResource````\nit('can render page', function () {\n    $this->get(PostResource::getUrl('view', [\n        'record' => Post::factory()->create(),\n    ]))->assertSuccessful();\n});\n```\n\n##### #Filling existing data\n\nTo check that the form is filled with the correct data from the database, you may assertFormSet() that the data in the form matches that of the record:\n\n`assertFormSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can retrieve data', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ViewPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->assertFormSet([\n            'author_id' => $post->author->getKey(),\n            'content' => $post->content,\n            'tags' => $post->tags,\n            'title' => $post->title,\n        ]);\n});\n```\n\n### #Relation managers\n\n##### #Render\n\nTo ensure that a relation manager is able to render successfully, mount the Livewire component:\n\n```\nuse App\\Filament\\Resources\\CategoryResource\\Pages\\EditCategory;\nuse function Pest\\Livewire\\livewire;\n\nit('can render relation manager', function () {\n    $category = Category::factory()\n        ->has(Post::factory()->count(10))\n        ->create();\n\n    livewire(CategoryResource\\RelationManagers\\PostsRelationManager::class, [\n        'ownerRecord' => $category,\n        'pageClass' => EditCategory::class,\n    ])\n        ->assertSuccessful();\n});\n```\n\n##### #Table\n\nFilament includes a selection of helpers for testing tables. A full guide to testing tables can be found in the Table Builder documentation.\n\nTo use a table testing helper, make assertions on the relation manager class, which holds the table:\n\n```\nuse App\\Filament\\Resources\\CategoryResource\\Pages\\EditCategory;\nuse function Pest\\Livewire\\livewire;\n\nit('can list posts', function () {\n    $category = Category::factory()\n        ->has(Post::factory()->count(10))\n        ->create();\n\n    livewire(CategoryResource\\RelationManagers\\PostsRelationManager::class, [\n        'ownerRecord' => $category,\n        'pageClass' => EditCategory::class,\n    ])\n        ->assertCanSeeTableRecords($category->posts);\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Testing - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Testing",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "All examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\nSince all pages in the app are Livewire components, we’re just using Livewire testing helpers everywhere. If you’ve never tested Livewire components before, please read this guide from the Livewire docs.",
                "level": 3
              },
              {
                "title": "## #Getting started",
                "content": "Ensure that you are authenticated to access the app in your TestCase:\n\n`TestCase````\nprotected function setUp(): void\n{\n    parent::setUp();\n\n    $this->actingAs(User::factory()->create());\n}\n```",
                "level": 3
              },
              {
                "title": "### #Testing multiple panels",
                "content": "If you have multiple panels and you would like to test a non-default panel, you will need to tell Filament which panel you are testing. This can be done in the setUp() method of the test case, or you can do it at the start of a particular test. Filament usually does this in a middleware when you access the panel through a request, so if you’re not making a request in your test like when testing a Livewire component, you need to set the current panel manually:\n\n`setUp()````\nuse Filament\\Facades\\Filament;\n\nFilament::setCurrentPanel(\n    Filament::getPanel('app'), // Where `app` is the ID of the panel you want to test.\n);\n```",
                "level": 4
              },
              {
                "title": "## #Resources",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Pages",
                "content": "",
                "level": 4
              },
              {
                "title": "#### #List",
                "content": "",
                "level": 5
              },
              {
                "title": "##### #Routing & render",
                "content": "To ensure that the List page for the PostResource is able to render successfully, generate a page URL, perform a request to this URL and ensure that it is successful:\n\n`PostResource````\nit('can render page', function () {\n    $this->get(PostResource::getUrl('index'))->assertSuccessful();\n});\n```",
                "level": 6
              },
              {
                "title": "##### #Table",
                "content": "Filament includes a selection of helpers for testing tables. A full guide to testing tables can be found in the Table Builder documentation.\n\nTo use a table testing helper, make assertions on the resource’s List page class, which holds the table:\n\n```\nuse function Pest\\Livewire\\livewire;\n\nit('can list posts', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts);\n});\n```",
                "level": 6
              },
              {
                "title": "#### #Create",
                "content": "",
                "level": 5
              },
              {
                "title": "##### #Routing & render",
                "content": "To ensure that the Create page for the PostResource is able to render successfully, generate a page URL, perform a request to this URL and ensure that it is successful:\n\n`PostResource````\nit('can render page', function () {\n    $this->get(PostResource::getUrl('create'))->assertSuccessful();\n});\n```",
                "level": 6
              },
              {
                "title": "##### #Creating",
                "content": "You may check that data is correctly saved into the database by calling fillForm() with your form data, and then asserting that the database contains a matching record:\n\n`fillForm()````\nuse function Pest\\Livewire\\livewire;\n\nit('can create', function () {\n    $newData = Post::factory()->make();\n\n    livewire(PostResource\\Pages\\CreatePost::class)\n        ->fillForm([\n            'author_id' => $newData->author->getKey(),\n            'content' => $newData->content,\n            'tags' => $newData->tags,\n            'title' => $newData->title,\n        ])\n        ->call('create')\n        ->assertHasNoFormErrors();\n\n    $this->assertDatabaseHas(Post::class, [\n        'author_id' => $newData->author->getKey(),\n        'content' => $newData->content,\n        'tags' => json_encode($newData->tags),\n        'title' => $newData->title,\n    ]);\n});\n```",
                "level": 6
              },
              {
                "title": "##### #Validation",
                "content": "Use assertHasFormErrors() to ensure that data is properly validated in a form:\n\n`assertHasFormErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate input', function () {\n    livewire(PostResource\\Pages\\CreatePost::class)\n        ->fillForm([\n            'title' => null,\n        ])\n        ->call('create')\n        ->assertHasFormErrors(['title' => 'required']);\n});\n```",
                "level": 6
              },
              {
                "title": "#### #Edit",
                "content": "",
                "level": 5
              },
              {
                "title": "##### #Routing & render",
                "content": "To ensure that the Edit page for the PostResource is able to render successfully, generate a page URL, perform a request to this URL and ensure that it is successful:\n\n`PostResource````\nit('can render page', function () {\n    $this->get(PostResource::getUrl('edit', [\n        'record' => Post::factory()->create(),\n    ]))->assertSuccessful();\n});\n```",
                "level": 6
              },
              {
                "title": "##### #Filling existing data",
                "content": "To check that the form is filled with the correct data from the database, you may assertFormSet() that the data in the form matches that of the record:\n\n`assertFormSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can retrieve data', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\EditPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->assertFormSet([\n            'author_id' => $post->author->getKey(),\n            'content' => $post->content,\n            'tags' => $post->tags,\n            'title' => $post->title,\n        ]);\n});\n```",
                "level": 6
              },
              {
                "title": "##### #Saving",
                "content": "You may check that data is correctly saved into the database by calling fillForm() with your form data, and then asserting that the database contains a matching record:\n\n`fillForm()````\nuse function Pest\\Livewire\\livewire;\n\nit('can save', function () {\n    $post = Post::factory()->create();\n    $newData = Post::factory()->make();\n\n    livewire(PostResource\\Pages\\EditPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->fillForm([\n            'author_id' => $newData->author->getKey(),\n            'content' => $newData->content,\n            'tags' => $newData->tags,\n            'title' => $newData->title,\n        ])\n        ->call('save')\n        ->assertHasNoFormErrors();\n\n    expect($post->refresh())\n        ->author_id->toBe($newData->author->getKey())\n        ->content->toBe($newData->content)\n        ->tags->toBe($newData->tags)\n        ->title->toBe($newData->title);\n});\n```",
                "level": 6
              },
              {
                "title": "##### #Validation",
                "content": "Use assertHasFormErrors() to ensure that data is properly validated in a form:\n\n`assertHasFormErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate input', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\EditPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->fillForm([\n            'title' => null,\n        ])\n        ->call('save')\n        ->assertHasFormErrors(['title' => 'required']);\n});\n```",
                "level": 6
              },
              {
                "title": "##### #Deleting",
                "content": "You can test the DeleteAction using callAction():\n\n`DeleteAction``callAction()````\nuse Filament\\Actions\\DeleteAction;\nuse function Pest\\Livewire\\livewire;\n\nit('can delete', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\EditPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->callAction(DeleteAction::class);\n\n    $this->assertModelMissing($post);\n});\n```\n\nYou can ensure that a particular user is not able to see a DeleteAction using assertActionHidden():\n\n`DeleteAction``assertActionHidden()````\nuse Filament\\Actions\\DeleteAction;\nuse function Pest\\Livewire\\livewire;\n\nit('can not delete', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\EditPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->assertActionHidden(DeleteAction::class);\n});\n```",
                "level": 6
              },
              {
                "title": "#### #View",
                "content": "",
                "level": 5
              },
              {
                "title": "##### #Routing & render",
                "content": "To ensure that the View page for the PostResource is able to render successfully, generate a page URL, perform a request to this URL and ensure that it is successful:\n\n`PostResource````\nit('can render page', function () {\n    $this->get(PostResource::getUrl('view', [\n        'record' => Post::factory()->create(),\n    ]))->assertSuccessful();\n});\n```",
                "level": 6
              },
              {
                "title": "##### #Filling existing data",
                "content": "To check that the form is filled with the correct data from the database, you may assertFormSet() that the data in the form matches that of the record:\n\n`assertFormSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can retrieve data', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ViewPost::class, [\n        'record' => $post->getRouteKey(),\n    ])\n        ->assertFormSet([\n            'author_id' => $post->author->getKey(),\n            'content' => $post->content,\n            'tags' => $post->tags,\n            'title' => $post->title,\n        ]);\n});\n```",
                "level": 6
              },
              {
                "title": "### #Relation managers",
                "content": "",
                "level": 4
              },
              {
                "title": "##### #Render",
                "content": "To ensure that a relation manager is able to render successfully, mount the Livewire component:\n\n```\nuse App\\Filament\\Resources\\CategoryResource\\Pages\\EditCategory;\nuse function Pest\\Livewire\\livewire;\n\nit('can render relation manager', function () {\n    $category = Category::factory()\n        ->has(Post::factory()->count(10))\n        ->create();\n\n    livewire(CategoryResource\\RelationManagers\\PostsRelationManager::class, [\n        'ownerRecord' => $category,\n        'pageClass' => EditCategory::class,\n    ])\n        ->assertSuccessful();\n});\n```",
                "level": 6
              },
              {
                "title": "##### #Table",
                "content": "Filament includes a selection of helpers for testing tables. A full guide to testing tables can be found in the Table Builder documentation.\n\nTo use a table testing helper, make assertions on the relation manager class, which holds the table:\n\n```\nuse App\\Filament\\Resources\\CategoryResource\\Pages\\EditCategory;\nuse function Pest\\Livewire\\livewire;\n\nit('can list posts', function () {\n    $category = Category::factory()\n        ->has(Post::factory()->count(10))\n        ->create();\n\n    livewire(CategoryResource\\RelationManagers\\PostsRelationManager::class, [\n        'ownerRecord' => $category,\n        'pageClass' => EditCategory::class,\n    ])\n        ->assertCanSeeTableRecords($category->posts);\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 6
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Getting started",
              "Testing multiple panels",
              "Resources",
              "Pages",
              "Relation managers"
            ],
            "code_examples_count": 34,
            "has_installation_info": true,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "upgrading": {
          "metadata": {
            "title": "Upgrading",
            "url": "https://filamentphp.com/docs/3.x/panels/upgrading",
            "section": "panels",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        }
      }
    },
    "tables": {
      "section_info": {
        "name": "tables",
        "page_count": 13,
        "description": "Interactive datatable builder for displaying and managing data"
      },
      "pages": {
        "installation": {
          "metadata": {
            "title": "Installation",
            "url": "https://filamentphp.com/docs/3.x/tables/installation",
            "section": "tables",
            "word_count": 677,
            "character_count": 5619
          },
          "content": {
            "full_text": "\n# Installation - Tables - Filament\n\nTables\n\n# Installation\n\nThe Table Builder package is pre-installed with the Panel Builder. This guide is for using the Table Builder in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)\n\n## #Installation\n\nRequire the Table Builder package using Composer:\n\n```\ncomposer require filament/tables:\"^3.3\" -W\n```\n\n## #New Laravel projects\n\nTo quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --tables\n\nnpm install\n\nnpm run dev\n```\n\n## #Existing Laravel projects\n\nRun the following command to install the Table Builder assets:\n\n```\nphp artisan filament:install --tables\n```\n\n### #Installing Tailwind CSS\n\n> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```\n\n### #Configuring styles\n\nAdd Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```\n\n### #Automatically refreshing the browser\n\nYou may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```\n\n### #Compiling assets\n\nCompile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```\n\n## #Publishing configuration\n\nYou can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Tables - Filament",
                "content": "Tables",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "The Table Builder package is pre-installed with the Panel Builder. This guide is for using the Table Builder in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "Require the Table Builder package using Composer:\n\n```\ncomposer require filament/tables:\"^3.3\" -W\n```",
                "level": 3
              },
              {
                "title": "## #New Laravel projects",
                "content": "To quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --tables\n\nnpm install\n\nnpm run dev\n```",
                "level": 3
              },
              {
                "title": "## #Existing Laravel projects",
                "content": "Run the following command to install the Table Builder assets:\n\n```\nphp artisan filament:install --tables\n```",
                "level": 3
              },
              {
                "title": "### #Installing Tailwind CSS",
                "content": "> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```",
                "level": 4
              },
              {
                "title": "### #Configuring styles",
                "content": "Add Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```",
                "level": 4
              },
              {
                "title": "### #Automatically refreshing the browser",
                "content": "You may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```",
                "level": 4
              },
              {
                "title": "### #Compiling assets",
                "content": "Compile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```",
                "level": 4
              },
              {
                "title": "## #Publishing configuration",
                "content": "You can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "New Laravel projects",
              "Existing Laravel projects",
              "Installing Tailwind CSS",
              "Configuring styles",
              "Automatically refreshing the browser",
              "Compiling assets",
              "Publishing configuration",
              "Upgrading"
            ],
            "code_examples_count": 24,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "getting-started": {
          "metadata": {
            "title": "Getting Started",
            "url": "https://filamentphp.com/docs/3.x/tables/getting-started",
            "section": "tables",
            "word_count": 1138,
            "character_count": 8116
          },
          "content": {
            "full_text": "\n# Getting started - Tables - Filament\n\nTables\n\n# Getting started\n\n## #Overview\n\nFilament’s Table Builder package allows you to add an interactive datatable to any Livewire component. It’s also used within other Filament packages, such as the Panel Builder for displaying resources and relation managers, as well as for the table widget. Learning the features of the Table Builder will be incredibly time-saving when both building your own custom Livewire tables and using Filament’s other packages.\n\nThis guide will walk you through the basics of building tables with Filament’s table package. If you’re planning to add a new table to your own Livewire component, you should do that first and then come back. If you’re adding a table to an app resource, or another Filament package, you’re ready to go!\n\n## #Defining table columns\n\nThe basis of any table is rows and columns. Filament uses Eloquent to get the data for rows in the table, and you are responsible for defining the columns that are used in that row.\n\nFilament includes many column types prebuilt for you, and you can view a full list here. You can even create your own custom column types to display data in whatever way you need.\n\nColumns are stored in an array, as objects within the $table->columns() method:\n\n`$table->columns()````\nuse Filament\\Tables\\Columns\\IconColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            TextColumn::make('title'),\n            TextColumn::make('slug'),\n            IconColumn::make('is_featured')\n                ->boolean(),\n        ]);\n}\n```\n\nIn this example, there are 3 columns in the table. The first two display text - the title and slug of each row in the table. The third column displays an icon, either a green check or a red cross depending on if the row is featured or not.\n\n### #Making columns sortable and searchable\n\nYou can easily modify columns by chaining methods onto them. For example, you can make a column searchable using the searchable() method. Now, there will be a search field in the table, and you will be able to filter rows by the value of that column:\n\n`searchable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->searchable()\n```\n\nYou can make multiple columns searchable, and Filament will be able to search for matches within any of them, all at once.\n\nYou can also make a column sortable using the sortable() method. This will add a sort button to the column header, and clicking it will sort the table by that column:\n\n`sortable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->sortable()\n```\n\n### #Accessing related data from columns\n\nYou can also display data in a column that belongs to a relationship. For example, if you have a Post model that belongs to a User model (the author of the post), you can display the user’s name in the table:\n\n`Post``User````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('author.name')\n```\n\nIn this case, Filament will search for an author relationship on the Post model, and then display the name attribute of that relationship. We call this “dot notation” - you can use it to display any attribute of any relationship, even nested distant relationships. Filament uses this dot notation to eager-load the results of that relationship for you.\n\n`author``Post``name`## #Defining table filters\n\nAs well as making columns searchable(), you can allow the users to filter rows in the table in other ways. We call these components “filters”, and they are defined in the $table->filters() method:\n\n`searchable()``$table->filters()````\nuse Filament\\Tables\\Filters\\Filter;\nuse Filament\\Tables\\Filters\\SelectFilter;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->filters([\n            Filter::make('is_featured')\n                ->query(fn (Builder $query) => $query->where('is_featured', true)),\n            SelectFilter::make('status')\n                ->options([\n                    'draft' => 'Draft',\n                    'reviewing' => 'Reviewing',\n                    'published' => 'Published',\n                ]),\n        ]);\n}\n```\n\nIn this example, we have defined 2 table filters. On the table, there is now a “filter” icon button in the top corner. Clicking it will open a dropdown with the 2 filters we have defined.\n\nThe first filter is rendered as a checkbox. When it’s checked, only featured rows in the table will be displayed. When it’s unchecked, all rows will be displayed.\n\nThe second filter is rendered as a select dropdown. When a user selects an option, only rows with that status will be displayed. When no option is selected, all rows will be displayed.\n\nIt’s possible to define as many filters as you need, and use any component from the Form Builder package to create a UI. For example, you could create a custom date range filter.\n\n## #Defining table actions\n\nFilament’s tables can use Actions. They are buttons that can be added to the end of any table row, or even in the header of a table. For instance, you may want an action to “create” a new record in the header, and then “edit” and “delete” actions on each row. Bulk actions can be used to execute code when records in the table are selected.\n\n```\nuse App\\Models\\Post;\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Actions\\BulkActionGroup;\nuse Filament\\Tables\\Actions\\DeleteBulkAction;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->actions([\n            Action::make('feature')\n                ->action(function (Post $record) {\n                    $record->is_featured = true;\n                    $record->save();\n                })\n                ->hidden(fn (Post $record): bool => $record->is_featured),\n            Action::make('unfeature')\n                ->action(function (Post $record) {\n                    $record->is_featured = false;\n                    $record->save();\n                })\n                ->visible(fn (Post $record): bool => $record->is_featured),\n        ])\n        ->bulkActions([\n            BulkActionGroup::make([\n                DeleteBulkAction::make(),\n            ]),\n        ]);\n}\n```\n\nIn this example, we define 2 actions for table rows. The first action is a “feature” action. When clicked, it will set the is_featured attribute on the record to true - which is written within the action() method. Using the hidden() method, the action will be hidden if the record is already featured. The second action is an “unfeature” action. When clicked, it will set the is_featured attribute on the record to false. Using the visible() method, the action will be hidden if the record is not featured.\n\n`is_featured``true``action()``hidden()``is_featured``false``visible()`We also define a bulk action. When bulk actions are defined, each row in the table will have a checkbox. This bulk action is built-in to Filament, and it will delete all selected records. However, you can write your own custom bulk actions easily too.\n\nActions can also open modals to request confirmation from the user, as well as render forms inside to collect extra data. It’s a good idea to read the Actions documentation to learn more about their extensive capabilities throughout Filament.\n\n## #Next steps with the Table Builder package\n\nNow you’ve finished reading this guide, where to next? Here are some suggestions:\n\n- Explore the available columns to display data in your table.\n- Deep dive into table actions and start using modals.\n- Discover how to build complex, responsive table layouts without touching CSS.\n- Add summaries to your tables, which give an overview of the data inside them.\n- Find out about all advanced techniques that you can customize tables to your needs.\n- Write automated tests for your tables using our suite of helper methods.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Tables - Filament",
                "content": "Tables",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament’s Table Builder package allows you to add an interactive datatable to any Livewire component. It’s also used within other Filament packages, such as the Panel Builder for displaying resources and relation managers, as well as for the table widget. Learning the features of the Table Builder will be incredibly time-saving when both building your own custom Livewire tables and using Filament’s other packages.\n\nThis guide will walk you through the basics of building tables with Filament’s table package. If you’re planning to add a new table to your own Livewire component, you should do that first and then come back. If you’re adding a table to an app resource, or another Filament package, you’re ready to go!",
                "level": 3
              },
              {
                "title": "## #Defining table columns",
                "content": "The basis of any table is rows and columns. Filament uses Eloquent to get the data for rows in the table, and you are responsible for defining the columns that are used in that row.\n\nFilament includes many column types prebuilt for you, and you can view a full list here. You can even create your own custom column types to display data in whatever way you need.\n\nColumns are stored in an array, as objects within the $table->columns() method:\n\n`$table->columns()````\nuse Filament\\Tables\\Columns\\IconColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            TextColumn::make('title'),\n            TextColumn::make('slug'),\n            IconColumn::make('is_featured')\n                ->boolean(),\n        ]);\n}\n```\n\nIn this example, there are 3 columns in the table. The first two display text - the title and slug of each row in the table. The third column displays an icon, either a green check or a red cross depending on if the row is featured or not.",
                "level": 3
              },
              {
                "title": "### #Making columns sortable and searchable",
                "content": "You can easily modify columns by chaining methods onto them. For example, you can make a column searchable using the searchable() method. Now, there will be a search field in the table, and you will be able to filter rows by the value of that column:\n\n`searchable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->searchable()\n```\n\nYou can make multiple columns searchable, and Filament will be able to search for matches within any of them, all at once.\n\nYou can also make a column sortable using the sortable() method. This will add a sort button to the column header, and clicking it will sort the table by that column:\n\n`sortable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->sortable()\n```",
                "level": 4
              },
              {
                "title": "### #Accessing related data from columns",
                "content": "You can also display data in a column that belongs to a relationship. For example, if you have a Post model that belongs to a User model (the author of the post), you can display the user’s name in the table:\n\n`Post``User````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('author.name')\n```\n\nIn this case, Filament will search for an author relationship on the Post model, and then display the name attribute of that relationship. We call this “dot notation” - you can use it to display any attribute of any relationship, even nested distant relationships. Filament uses this dot notation to eager-load the results of that relationship for you.\n\n`author``Post``name`## #Defining table filters\n\nAs well as making columns searchable(), you can allow the users to filter rows in the table in other ways. We call these components “filters”, and they are defined in the $table->filters() method:\n\n`searchable()``$table->filters()````\nuse Filament\\Tables\\Filters\\Filter;\nuse Filament\\Tables\\Filters\\SelectFilter;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->filters([\n            Filter::make('is_featured')\n                ->query(fn (Builder $query) => $query->where('is_featured', true)),\n            SelectFilter::make('status')\n                ->options([\n                    'draft' => 'Draft',\n                    'reviewing' => 'Reviewing',\n                    'published' => 'Published',\n                ]),\n        ]);\n}\n```\n\nIn this example, we have defined 2 table filters. On the table, there is now a “filter” icon button in the top corner. Clicking it will open a dropdown with the 2 filters we have defined.\n\nThe first filter is rendered as a checkbox. When it’s checked, only featured rows in the table will be displayed. When it’s unchecked, all rows will be displayed.\n\nThe second filter is rendered as a select dropdown. When a user selects an option, only rows with that status will be displayed. When no option is selected, all rows will be displayed.\n\nIt’s possible to define as many filters as you need, and use any component from the Form Builder package to create a UI. For example, you could create a custom date range filter.",
                "level": 4
              },
              {
                "title": "## #Defining table actions",
                "content": "Filament’s tables can use Actions. They are buttons that can be added to the end of any table row, or even in the header of a table. For instance, you may want an action to “create” a new record in the header, and then “edit” and “delete” actions on each row. Bulk actions can be used to execute code when records in the table are selected.\n\n```\nuse App\\Models\\Post;\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Actions\\BulkActionGroup;\nuse Filament\\Tables\\Actions\\DeleteBulkAction;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->actions([\n            Action::make('feature')\n                ->action(function (Post $record) {\n                    $record->is_featured = true;\n                    $record->save();\n                })\n                ->hidden(fn (Post $record): bool => $record->is_featured),\n            Action::make('unfeature')\n                ->action(function (Post $record) {\n                    $record->is_featured = false;\n                    $record->save();\n                })\n                ->visible(fn (Post $record): bool => $record->is_featured),\n        ])\n        ->bulkActions([\n            BulkActionGroup::make([\n                DeleteBulkAction::make(),\n            ]),\n        ]);\n}\n```\n\nIn this example, we define 2 actions for table rows. The first action is a “feature” action. When clicked, it will set the is_featured attribute on the record to true - which is written within the action() method. Using the hidden() method, the action will be hidden if the record is already featured. The second action is an “unfeature” action. When clicked, it will set the is_featured attribute on the record to false. Using the visible() method, the action will be hidden if the record is not featured.\n\n`is_featured``true``action()``hidden()``is_featured``false``visible()`We also define a bulk action. When bulk actions are defined, each row in the table will have a checkbox. This bulk action is built-in to Filament, and it will delete all selected records. However, you can write your own custom bulk actions easily too.\n\nActions can also open modals to request confirmation from the user, as well as render forms inside to collect extra data. It’s a good idea to read the Actions documentation to learn more about their extensive capabilities throughout Filament.",
                "level": 3
              },
              {
                "title": "## #Next steps with the Table Builder package",
                "content": "Now you’ve finished reading this guide, where to next? Here are some suggestions:\n\n- Explore the available columns to display data in your table.\n- Deep dive into table actions and start using modals.\n- Discover how to build complex, responsive table layouts without touching CSS.\n- Add summaries to your tables, which give an overview of the data inside them.\n- Find out about all advanced techniques that you can customize tables to your needs.\n- Write automated tests for your tables using our suite of helper methods.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Defining table columns",
              "Making columns sortable and searchable",
              "Accessing related data from columns",
              "Defining table actions",
              "Next steps with the Table Builder package"
            ],
            "code_examples_count": 12,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "columns": {
          "metadata": {
            "title": "Columns",
            "url": "https://filamentphp.com/docs/3.x/tables/columns",
            "section": "tables",
            "word_count": 1968,
            "character_count": 17355
          },
          "content": {
            "full_text": "\n# Getting started - Tables - Filament\n\nTables  \n-  Columns\n\n# Getting started\n\n## #Overview\n\nColumn classes can be found in the Filament\\Tables\\Columns namespace. You can put them inside the $table->columns() method:\n\n`Filament\\Tables\\Columns``$table->columns()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ]);\n}\n```\n\nColumns may be created using the static make() method, passing its unique name. The name of the column should correspond to a column or accessor on your model. You may use “dot notation” to access columns within relationships.\n\n`make()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n\nTextColumn::make('author.name')\n```\n\n## #Available columns\n\nFilament ships with two main types of columns - static and editable.\n\nStatic columns display data to the user:\n\n- Text column\n- Icon column\n- Image column\n- Color column\n\nEditable columns allow the user to update data in the database without leaving the table:\n\n- Select column\n- Toggle column\n- Text input column\n- Checkbox column\n\nYou may also create your own custom columns to display data however you wish.\n\n## #Setting a label\n\nBy default, the label of the column, which is displayed in the header of the table, is generated from the name of the column. You may customize this using the label() method:\n\n`label()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->label('Post title')\n```\n\nOptionally, you can have the label automatically translated using Laravel’s localization features with the translateLabel() method:\n\n`translateLabel()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->translateLabel() // Equivalent to `label(__('Title'))`\n```\n\n## #Sorting\n\nColumns may be sortable, by clicking on the column label. To make a column sortable, you must use the sortable() method:\n\n`sortable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->sortable()\n```\n\nIf you’re using an accessor column, you may pass sortable() an array of database columns to sort by:\n\n`sortable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('full_name')\n    ->sortable(['first_name', 'last_name'])\n```\n\nYou may customize how the sorting is applied to the Eloquent query using a callback:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nTextColumn::make('full_name')\n    ->sortable(query: function (Builder $query, string $direction): Builder {\n        return $query\n            ->orderBy('last_name', $direction)\n            ->orderBy('first_name', $direction);\n    })\n```\n\n## #Sorting by default\n\nYou may choose to sort a table by default if no other sort is applied. You can use the defaultSort() method for this:\n\n`defaultSort()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->defaultSort('stock', 'desc');\n}\n```\n\n### #Persist sort in session\n\nTo persist the sorting in the user’s session, use the persistSortInSession() method:\n\n`persistSortInSession()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->persistSortInSession();\n}\n```\n\n### #Setting a default sort option label\n\nTo set a default sort option label, use the defaultSortOptionLabel() method:\n\n`defaultSortOptionLabel()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->defaultSortOptionLabel('Date');\n}\n```\n\n## #Searching\n\nColumns may be searchable by using the text input field in the top right of the table. To make a column searchable, you must use the searchable() method:\n\n`searchable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->searchable()\n```\n\nIf you’re using an accessor column, you may pass searchable() an array of database columns to search within:\n\n`searchable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('full_name')\n    ->searchable(['first_name', 'last_name'])\n```\n\nYou may customize how the search is applied to the Eloquent query using a callback:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nTextColumn::make('full_name')\n    ->searchable(query: function (Builder $query, string $search): Builder {\n        return $query\n            ->where('first_name', 'like', \"%{$search}%\")\n            ->orWhere('last_name', 'like', \"%{$search}%\");\n    })\n```\n\n#### #Customizing the table search field placeholder\n\nYou may customize the placeholder in the search field using the searchPlaceholder() method on the $table:\n\n`searchPlaceholder()``$table````\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->searchPlaceholder('Search (ID, Name)');\n}\n```\n\n### #Searching individually\n\nYou can choose to enable a per-column search input field using the isIndividual parameter:\n\n`isIndividual````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->searchable(isIndividual: true)\n```\n\nIf you use the isIndividual parameter, you may still search that column using the main “global” search input field for the entire table.\n\n`isIndividual`To disable that functionality while still preserving the individual search functionality, you need the isGlobal parameter:\n\n`isGlobal````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->searchable(isIndividual: true, isGlobal: false)\n```\n\nYou may optionally persist the searches in the query string:\n\n```\nuse Livewire\\Attributes\\Url;\n\n/**\n * @var array<string, string | array<string, string | null> | null>\n */\n#[Url]\npublic array $tableColumnSearches = [];\n```\n\n### #Customizing the table search debounce\n\nYou may customize the debounce time in all table search fields using the searchDebounce() method on the $table. By default it is set to 500ms:\n\n`searchDebounce()``$table``500ms````\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->searchDebounce('750ms');\n}\n```\n\n### #Searching when the input is blurred\n\nInstead of automatically reloading the table contents while the user is typing their search, which is affected by the debounce of the search field, you may change the behavior so that the table is only searched when the user blurs the input (tabs or clicks out of it), using the searchOnBlur() method:\n\n`searchOnBlur()````\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->searchOnBlur();\n}\n```\n\n### #Persist search in session\n\nTo persist the table or individual column search in the user’s session, use the persistSearchInSession() or persistColumnSearchInSession() method:\n\n`persistSearchInSession()``persistColumnSearchInSession()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->persistSearchInSession()\n        ->persistColumnSearchesInSession();\n}\n```\n\n## #Column actions and URLs\n\nWhen a cell is clicked, you may run an “action”, or open a URL.\n\n### #Running actions\n\nTo run an action, you may use the action() method, passing a callback or the name of a Livewire method to run. Each method accepts a $record parameter which you may use to customize the behavior of the action:\n\n`action()``$record````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->action(function (Post $record): void {\n        $this->dispatch('open-post-edit-modal', post: $record->getKey());\n    })\n```\n\n#### #Action modals\n\nYou may open action modals by passing in an Action object to the action() method:\n\n`Action``action()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->action(\n        Action::make('select')\n            ->requiresConfirmation()\n            ->action(function (Post $record): void {\n                $this->dispatch('select-post', post: $record->getKey());\n            }),\n    )\n```\n\nAction objects passed into the action() method must have a unique name to distinguish it from other actions within the table.\n\n`action()`### #Opening URLs\n\nTo open a URL, you may use the url() method, passing a callback or static URL to open. Callbacks accept a $record parameter which you may use to customize the URL:\n\n`url()``$record````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->url(fn (Post $record): string => route('posts.edit', ['post' => $record]))\n```\n\nYou may also choose to open the URL in a new tab:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->url(fn (Post $record): string => route('posts.edit', ['post' => $record]))\n    ->openUrlInNewTab()\n```\n\n## #Setting a default value\n\nTo set a default value for columns with an empty state, you may use the default() method. This method will treat the default state as if it were real, so columns like image or color will display the default image or color.\n\n`default()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('description')\n    ->default('No description.')\n```\n\n## #Adding placeholder text if a column is empty\n\nSometimes you may want to display placeholder text for columns with an empty state, which is styled as a lighter gray text. This differs from the default value, as the placeholder is always text and not treated as if it were real state.\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('description')\n    ->placeholder('No description.')\n```\n\n## #Hiding columns\n\nTo hide a column conditionally, you may use the hidden() and visible() methods, whichever you prefer:\n\n`hidden()``visible()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('role')\n    ->hidden(! auth()->user()->isAdmin())\n// or\nTextColumn::make('role')\n    ->visible(auth()->user()->isAdmin())\n```\n\n### #Toggling column visibility\n\nUsers may hide or show columns themselves in the table. To make a column toggleable, use the toggleable() method:\n\n`toggleable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('email')\n    ->toggleable()\n```\n\n#### #Making toggleable columns hidden by default\n\nBy default, toggleable columns are visible. To make them hidden instead:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('id')\n    ->toggleable(isToggledHiddenByDefault: true)\n```\n\n#### #Customizing the toggle columns dropdown trigger action\n\nTo customize the toggle dropdown trigger button, you may use the toggleColumnsTriggerAction() method, passing a closure that returns an action. All methods that are available to customize action trigger buttons can be used:\n\n`toggleColumnsTriggerAction()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->toggleColumnsTriggerAction(\n            fn (Action $action) => $action\n                ->button()\n                ->label('Toggle columns'),\n        );\n}\n```\n\n## #Calculated state\n\nSometimes you need to calculate the state of a column, instead of directly reading it from a database column.\n\nBy passing a callback function to the state() method, you can customize the returned state for that column based on the $record:\n\n`state()``$record````\nuse App\\Models\\Order;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('amount_including_vat')\n    ->state(function (Order $record): float {\n        return $record->amount * (1 + $record->vat_rate);\n    })\n```\n\n## #Tooltips\n\nYou may specify a tooltip to display when you hover over a cell:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->tooltip('Title')\n```\n\nThis method also accepts a closure that can access the current table record:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nTextColumn::make('title')\n    ->tooltip(fn (Model $record): string => \"By {$record->author->name}\")\n```\n\n## #Horizontally aligning column content\n\nTable columns are aligned to the start (left in LTR interfaces or right in RTL interfaces) by default. You may change the alignment using the alignment() method, and passing it Alignment::Start, Alignment::Center, Alignment::End or Alignment::Justify options:\n\n`alignment()``Alignment::Start``Alignment::Center``Alignment::End``Alignment::Justify````\nuse Filament\\Support\\Enums\\Alignment;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('email')\n    ->alignment(Alignment::End)\n```\n\nAlternatively, you may use shorthand methods like alignEnd():\n\n`alignEnd()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->alignEnd()\n```\n\n## #Vertically aligning column content\n\nTable column content is vertically centered by default. You may change the vertical alignment using the verticalAlignment() method, and passing it VerticalAlignment::Start, VerticalAlignment::Center or VerticalAlignment::End options:\n\n`verticalAlignment()``VerticalAlignment::Start``VerticalAlignment::Center``VerticalAlignment::End````\nuse Filament\\Support\\Enums\\VerticalAlignment;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->verticalAlignment(VerticalAlignment::Start)\n```\n\nAlternatively, you may use shorthand methods like verticallyAlignStart():\n\n`verticallyAlignStart()````\nuse Filament\\Support\\Enums\\VerticalAlignment;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->verticallyAlignStart()\n```\n\n## #Allowing column headers to wrap\n\nBy default, column headers will not wrap onto multiple lines, if they need more space. You may allow them to wrap using the wrapHeader() method:\n\n`wrapHeader()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->wrapHeader()\n```\n\n## #Controlling the width of columns\n\nBy default, columns will take up as much space as they need. You may allow some columns to consume more space than others by using the grow() method:\n\n`grow()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->grow()\n```\n\nAlternatively, you can define a width for the column, which is passed to the header cell using the style attribute, so you can use any valid CSS value:\n\n`style````\nuse Filament\\Tables\\Columns\\IconColumn;\n\nIconColumn::make('is_paid')\n    ->label('Paid')\n    ->boolean()\n    ->width('1%')\n```\n\n## #Grouping columns\n\nYou group multiple columns together underneath a single heading using a ColumnGroup object:\n\n`ColumnGroup````\nuse Filament\\Tables\\Columns\\ColumnGroup;\nuse Filament\\Tables\\Columns\\IconColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            TextColumn::make('title'),\n            TextColumn::make('slug'),\n            ColumnGroup::make('Visibility', [\n                TextColumn::make('status'),\n                IconColumn::make('is_featured'),\n            ]),\n            TextColumn::make('author.name'),\n        ]);\n}\n```\n\nThe first argument is the label of the group, and the second is an array of column objects that belong to that group.\n\nYou can also control the group header alignment and wrapping on the ColumnGroup object. To improve the multi-line fluency of the API, you can chain the columns() onto the object instead of passing it as the second argument:\n\n`ColumnGroup``columns()````\nuse Filament\\Support\\Enums\\Alignment;\nuse Filament\\Tables\\Columns\\ColumnGroup;\n\nColumnGroup::make('Website visibility')\n    ->columns([\n        // ...\n    ])\n    ->alignment(Alignment::Center)\n    ->wrapHeader()\n```\n\n## #Custom attributes\n\nThe HTML of columns can be customized, by passing an array of extraAttributes():\n\n`extraAttributes()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('slug')\n    ->extraAttributes(['class' => 'bg-gray-200'])\n```\n\nThese get merged onto the outer <div> element of each cell in that column.\n\n`<div>`## #Global settings\n\nIf you wish to change the default behavior of all columns globally, then you can call the static configureUsing() method inside a service provider’s boot() method, to which you pass a Closure to modify the columns using. For example, if you wish to make all columns searchable() and toggleable(), you can do it like so:\n\n`configureUsing()``boot()``searchable()``toggleable()````\nuse Filament\\Tables\\Columns\\Column;\n\nColumn::configureUsing(function (Column $column): void {\n    $column\n        ->toggleable()\n        ->searchable();\n});\n```\n\nAdditionally, you can call this code on specific column types as well:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::configureUsing(function (TextColumn $column): void {\n    $column\n        ->toggleable()\n        ->searchable();\n});\n```\n\nOf course, you are still able to overwrite this on each column individually:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->toggleable(false)\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Tables - Filament",
                "content": "Tables  \n-  Columns",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Column classes can be found in the Filament\\Tables\\Columns namespace. You can put them inside the $table->columns() method:\n\n`Filament\\Tables\\Columns``$table->columns()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ]);\n}\n```\n\nColumns may be created using the static make() method, passing its unique name. The name of the column should correspond to a column or accessor on your model. You may use “dot notation” to access columns within relationships.\n\n`make()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n\nTextColumn::make('author.name')\n```",
                "level": 3
              },
              {
                "title": "## #Available columns",
                "content": "Filament ships with two main types of columns - static and editable.\n\nStatic columns display data to the user:\n\n- Text column\n- Icon column\n- Image column\n- Color column\n\nEditable columns allow the user to update data in the database without leaving the table:\n\n- Select column\n- Toggle column\n- Text input column\n- Checkbox column\n\nYou may also create your own custom columns to display data however you wish.",
                "level": 3
              },
              {
                "title": "## #Setting a label",
                "content": "By default, the label of the column, which is displayed in the header of the table, is generated from the name of the column. You may customize this using the label() method:\n\n`label()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->label('Post title')\n```\n\nOptionally, you can have the label automatically translated using Laravel’s localization features with the translateLabel() method:\n\n`translateLabel()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->translateLabel() // Equivalent to `label(__('Title'))`\n```",
                "level": 3
              },
              {
                "title": "## #Sorting",
                "content": "Columns may be sortable, by clicking on the column label. To make a column sortable, you must use the sortable() method:\n\n`sortable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->sortable()\n```\n\nIf you’re using an accessor column, you may pass sortable() an array of database columns to sort by:\n\n`sortable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('full_name')\n    ->sortable(['first_name', 'last_name'])\n```\n\nYou may customize how the sorting is applied to the Eloquent query using a callback:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nTextColumn::make('full_name')\n    ->sortable(query: function (Builder $query, string $direction): Builder {\n        return $query\n            ->orderBy('last_name', $direction)\n            ->orderBy('first_name', $direction);\n    })\n```",
                "level": 3
              },
              {
                "title": "## #Sorting by default",
                "content": "You may choose to sort a table by default if no other sort is applied. You can use the defaultSort() method for this:\n\n`defaultSort()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->defaultSort('stock', 'desc');\n}\n```",
                "level": 3
              },
              {
                "title": "### #Persist sort in session",
                "content": "To persist the sorting in the user’s session, use the persistSortInSession() method:\n\n`persistSortInSession()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->persistSortInSession();\n}\n```",
                "level": 4
              },
              {
                "title": "### #Setting a default sort option label",
                "content": "To set a default sort option label, use the defaultSortOptionLabel() method:\n\n`defaultSortOptionLabel()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->defaultSortOptionLabel('Date');\n}\n```",
                "level": 4
              },
              {
                "title": "## #Searching",
                "content": "Columns may be searchable by using the text input field in the top right of the table. To make a column searchable, you must use the searchable() method:\n\n`searchable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->searchable()\n```\n\nIf you’re using an accessor column, you may pass searchable() an array of database columns to search within:\n\n`searchable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('full_name')\n    ->searchable(['first_name', 'last_name'])\n```\n\nYou may customize how the search is applied to the Eloquent query using a callback:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nTextColumn::make('full_name')\n    ->searchable(query: function (Builder $query, string $search): Builder {\n        return $query\n            ->where('first_name', 'like', \"%{$search}%\")\n            ->orWhere('last_name', 'like', \"%{$search}%\");\n    })\n```",
                "level": 3
              },
              {
                "title": "#### #Customizing the table search field placeholder",
                "content": "You may customize the placeholder in the search field using the searchPlaceholder() method on the $table:\n\n`searchPlaceholder()``$table````\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->searchPlaceholder('Search (ID, Name)');\n}\n```",
                "level": 5
              },
              {
                "title": "### #Searching individually",
                "content": "You can choose to enable a per-column search input field using the isIndividual parameter:\n\n`isIndividual````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->searchable(isIndividual: true)\n```\n\nIf you use the isIndividual parameter, you may still search that column using the main “global” search input field for the entire table.\n\n`isIndividual`To disable that functionality while still preserving the individual search functionality, you need the isGlobal parameter:\n\n`isGlobal````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->searchable(isIndividual: true, isGlobal: false)\n```\n\nYou may optionally persist the searches in the query string:\n\n```\nuse Livewire\\Attributes\\Url;\n\n/**\n * @var array<string, string | array<string, string | null> | null>\n */\n#[Url]\npublic array $tableColumnSearches = [];\n```",
                "level": 4
              },
              {
                "title": "### #Customizing the table search debounce",
                "content": "You may customize the debounce time in all table search fields using the searchDebounce() method on the $table. By default it is set to 500ms:\n\n`searchDebounce()``$table``500ms````\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->searchDebounce('750ms');\n}\n```",
                "level": 4
              },
              {
                "title": "### #Searching when the input is blurred",
                "content": "Instead of automatically reloading the table contents while the user is typing their search, which is affected by the debounce of the search field, you may change the behavior so that the table is only searched when the user blurs the input (tabs or clicks out of it), using the searchOnBlur() method:\n\n`searchOnBlur()````\nuse Filament\\Tables\\Table;\n\npublic static function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->searchOnBlur();\n}\n```",
                "level": 4
              },
              {
                "title": "### #Persist search in session",
                "content": "To persist the table or individual column search in the user’s session, use the persistSearchInSession() or persistColumnSearchInSession() method:\n\n`persistSearchInSession()``persistColumnSearchInSession()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            // ...\n        ])\n        ->persistSearchInSession()\n        ->persistColumnSearchesInSession();\n}\n```",
                "level": 4
              },
              {
                "title": "## #Column actions and URLs",
                "content": "When a cell is clicked, you may run an “action”, or open a URL.",
                "level": 3
              },
              {
                "title": "### #Running actions",
                "content": "To run an action, you may use the action() method, passing a callback or the name of a Livewire method to run. Each method accepts a $record parameter which you may use to customize the behavior of the action:\n\n`action()``$record````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->action(function (Post $record): void {\n        $this->dispatch('open-post-edit-modal', post: $record->getKey());\n    })\n```",
                "level": 4
              },
              {
                "title": "#### #Action modals",
                "content": "You may open action modals by passing in an Action object to the action() method:\n\n`Action``action()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->action(\n        Action::make('select')\n            ->requiresConfirmation()\n            ->action(function (Post $record): void {\n                $this->dispatch('select-post', post: $record->getKey());\n            }),\n    )\n```\n\nAction objects passed into the action() method must have a unique name to distinguish it from other actions within the table.\n\n`action()`### #Opening URLs\n\nTo open a URL, you may use the url() method, passing a callback or static URL to open. Callbacks accept a $record parameter which you may use to customize the URL:\n\n`url()``$record````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->url(fn (Post $record): string => route('posts.edit', ['post' => $record]))\n```\n\nYou may also choose to open the URL in a new tab:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->url(fn (Post $record): string => route('posts.edit', ['post' => $record]))\n    ->openUrlInNewTab()\n```",
                "level": 5
              },
              {
                "title": "## #Setting a default value",
                "content": "To set a default value for columns with an empty state, you may use the default() method. This method will treat the default state as if it were real, so columns like image or color will display the default image or color.\n\n`default()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('description')\n    ->default('No description.')\n```",
                "level": 3
              },
              {
                "title": "## #Adding placeholder text if a column is empty",
                "content": "Sometimes you may want to display placeholder text for columns with an empty state, which is styled as a lighter gray text. This differs from the default value, as the placeholder is always text and not treated as if it were real state.\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('description')\n    ->placeholder('No description.')\n```",
                "level": 3
              },
              {
                "title": "## #Hiding columns",
                "content": "To hide a column conditionally, you may use the hidden() and visible() methods, whichever you prefer:\n\n`hidden()``visible()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('role')\n    ->hidden(! auth()->user()->isAdmin())\n// or\nTextColumn::make('role')\n    ->visible(auth()->user()->isAdmin())\n```",
                "level": 3
              },
              {
                "title": "### #Toggling column visibility",
                "content": "Users may hide or show columns themselves in the table. To make a column toggleable, use the toggleable() method:\n\n`toggleable()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('email')\n    ->toggleable()\n```",
                "level": 4
              },
              {
                "title": "#### #Making toggleable columns hidden by default",
                "content": "By default, toggleable columns are visible. To make them hidden instead:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('id')\n    ->toggleable(isToggledHiddenByDefault: true)\n```",
                "level": 5
              },
              {
                "title": "#### #Customizing the toggle columns dropdown trigger action",
                "content": "To customize the toggle dropdown trigger button, you may use the toggleColumnsTriggerAction() method, passing a closure that returns an action. All methods that are available to customize action trigger buttons can be used:\n\n`toggleColumnsTriggerAction()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->toggleColumnsTriggerAction(\n            fn (Action $action) => $action\n                ->button()\n                ->label('Toggle columns'),\n        );\n}\n```",
                "level": 5
              },
              {
                "title": "## #Calculated state",
                "content": "Sometimes you need to calculate the state of a column, instead of directly reading it from a database column.\n\nBy passing a callback function to the state() method, you can customize the returned state for that column based on the $record:\n\n`state()``$record````\nuse App\\Models\\Order;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('amount_including_vat')\n    ->state(function (Order $record): float {\n        return $record->amount * (1 + $record->vat_rate);\n    })\n```",
                "level": 3
              },
              {
                "title": "## #Tooltips",
                "content": "You may specify a tooltip to display when you hover over a cell:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('title')\n    ->tooltip('Title')\n```\n\nThis method also accepts a closure that can access the current table record:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nTextColumn::make('title')\n    ->tooltip(fn (Model $record): string => \"By {$record->author->name}\")\n```",
                "level": 3
              },
              {
                "title": "## #Horizontally aligning column content",
                "content": "Table columns are aligned to the start (left in LTR interfaces or right in RTL interfaces) by default. You may change the alignment using the alignment() method, and passing it Alignment::Start, Alignment::Center, Alignment::End or Alignment::Justify options:\n\n`alignment()``Alignment::Start``Alignment::Center``Alignment::End``Alignment::Justify````\nuse Filament\\Support\\Enums\\Alignment;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('email')\n    ->alignment(Alignment::End)\n```\n\nAlternatively, you may use shorthand methods like alignEnd():\n\n`alignEnd()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->alignEnd()\n```",
                "level": 3
              },
              {
                "title": "## #Vertically aligning column content",
                "content": "Table column content is vertically centered by default. You may change the vertical alignment using the verticalAlignment() method, and passing it VerticalAlignment::Start, VerticalAlignment::Center or VerticalAlignment::End options:\n\n`verticalAlignment()``VerticalAlignment::Start``VerticalAlignment::Center``VerticalAlignment::End````\nuse Filament\\Support\\Enums\\VerticalAlignment;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->verticalAlignment(VerticalAlignment::Start)\n```\n\nAlternatively, you may use shorthand methods like verticallyAlignStart():\n\n`verticallyAlignStart()````\nuse Filament\\Support\\Enums\\VerticalAlignment;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->verticallyAlignStart()\n```",
                "level": 3
              },
              {
                "title": "## #Allowing column headers to wrap",
                "content": "By default, column headers will not wrap onto multiple lines, if they need more space. You may allow them to wrap using the wrapHeader() method:\n\n`wrapHeader()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->wrapHeader()\n```",
                "level": 3
              },
              {
                "title": "## #Controlling the width of columns",
                "content": "By default, columns will take up as much space as they need. You may allow some columns to consume more space than others by using the grow() method:\n\n`grow()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->grow()\n```\n\nAlternatively, you can define a width for the column, which is passed to the header cell using the style attribute, so you can use any valid CSS value:\n\n`style````\nuse Filament\\Tables\\Columns\\IconColumn;\n\nIconColumn::make('is_paid')\n    ->label('Paid')\n    ->boolean()\n    ->width('1%')\n```",
                "level": 3
              },
              {
                "title": "## #Grouping columns",
                "content": "You group multiple columns together underneath a single heading using a ColumnGroup object:\n\n`ColumnGroup````\nuse Filament\\Tables\\Columns\\ColumnGroup;\nuse Filament\\Tables\\Columns\\IconColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            TextColumn::make('title'),\n            TextColumn::make('slug'),\n            ColumnGroup::make('Visibility', [\n                TextColumn::make('status'),\n                IconColumn::make('is_featured'),\n            ]),\n            TextColumn::make('author.name'),\n        ]);\n}\n```\n\nThe first argument is the label of the group, and the second is an array of column objects that belong to that group.\n\nYou can also control the group header alignment and wrapping on the ColumnGroup object. To improve the multi-line fluency of the API, you can chain the columns() onto the object instead of passing it as the second argument:\n\n`ColumnGroup``columns()````\nuse Filament\\Support\\Enums\\Alignment;\nuse Filament\\Tables\\Columns\\ColumnGroup;\n\nColumnGroup::make('Website visibility')\n    ->columns([\n        // ...\n    ])\n    ->alignment(Alignment::Center)\n    ->wrapHeader()\n```",
                "level": 3
              },
              {
                "title": "## #Custom attributes",
                "content": "The HTML of columns can be customized, by passing an array of extraAttributes():\n\n`extraAttributes()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('slug')\n    ->extraAttributes(['class' => 'bg-gray-200'])\n```\n\nThese get merged onto the outer <div> element of each cell in that column.\n\n`<div>`## #Global settings\n\nIf you wish to change the default behavior of all columns globally, then you can call the static configureUsing() method inside a service provider’s boot() method, to which you pass a Closure to modify the columns using. For example, if you wish to make all columns searchable() and toggleable(), you can do it like so:\n\n`configureUsing()``boot()``searchable()``toggleable()````\nuse Filament\\Tables\\Columns\\Column;\n\nColumn::configureUsing(function (Column $column): void {\n    $column\n        ->toggleable()\n        ->searchable();\n});\n```\n\nAdditionally, you can call this code on specific column types as well:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::configureUsing(function (TextColumn $column): void {\n    $column\n        ->toggleable()\n        ->searchable();\n});\n```\n\nOf course, you are still able to overwrite this on each column individually:\n\n```\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('name')\n    ->toggleable(false)\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Available columns",
              "Setting a label",
              "Sorting",
              "Sorting by default",
              "Persist sort in session",
              "Setting a default sort option label",
              "Searching",
              "Searching individually",
              "Customizing the table search debounce"
            ],
            "code_examples_count": 92,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "filters": {
          "metadata": {
            "title": "Filters",
            "url": "https://filamentphp.com/docs/3.x/tables/filters",
            "section": "tables",
            "word_count": 1187,
            "character_count": 9304
          },
          "content": {
            "full_text": "\n# Getting started - Tables - Filament\n\nTables  \n-  Filters\n\n# Getting started\n\n## #Overview\n\nFilters allow you to define certain constraints on your data, and allow users to scope it to find the information they need. You put them in the $table->filters() method:\n\n`$table->filters()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ]);\n}\n```\n\nFilters may be created using the static make() method, passing its unique name. You should then pass a callback to query() which applies your filter’s scope:\n\n`make()``query()````\nuse Filament\\Tables\\Filters\\Filter;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nFilter::make('is_featured')\n    ->query(fn (Builder $query): Builder => $query->where('is_featured', true))\n```\n\n## #Available filters\n\nBy default, using the Filter::make() method will render a checkbox form component. When the checkbox is on, the query() will be activated.\n\n`Filter::make()``query()`- You can also replace the checkbox with a toggle.\n- You can use a ternary filter to replace the checkbox with a select field to allow users to pick between 3 states - usually “true”, “false” and “blank”. This is useful for filtering boolean columns that are nullable.\n- The trashed filter is a pre-built ternary filter that allows you to filter soft-deletable records.\n- You may use a select filter to allow users to select from a list of options, and filter using the selection.\n- You may use a query builder to allow users to create complex sets of filters, with an advanced user interface for combining constraints.\n- You may build custom filters with other form fields, to do whatever you want.\n\n## #Setting a label\n\nBy default, the label of the filter, which is displayed in the filter form, is generated from the name of the filter. You may customize this using the label() method:\n\n`label()````\nuse Filament\\Tables\\Filters\\Filter;\n\nFilter::make('is_featured')\n    ->label('Featured')\n```\n\nOptionally, you can have the label automatically translated using Laravel’s localization features with the translateLabel() method:\n\n`translateLabel()````\nuse Filament\\Tables\\Filters\\Filter;\n\nFilter::make('is_featured')\n    ->translateLabel() // Equivalent to `label(__('Is featured'))`\n```\n\n## #Customizing the filter form\n\nBy default, creating a filter with the Filter class will render a checkbox form component. When the checkbox is checked, the query() function will be applied to the table’s query, scoping the records in the table. When the checkbox is unchecked, the query() function will be removed from the table’s query.\n\n`Filter``query()``query()`Filters are built entirely on Filament’s form fields. They can render any combination of form fields, which users can then interact with to filter the table.\n\n### #Using a toggle button instead of a checkbox\n\nThe simplest example of managing the form field that is used for a filter is to replace the checkbox with a toggle button, using the toggle() method:\n\n`toggle()````\nuse Filament\\Tables\\Filters\\Filter;\n\nFilter::make('is_featured')\n    ->toggle()\n```\n\n### #Applying the filter by default\n\nYou may set a filter to be enabled by default, using the default() method:\n\n`default()````\nuse Filament\\Tables\\Filters\\Filter;\n\nFilter::make('is_featured')\n    ->default()\n```\n\n### #Customizing the built-in filter form field\n\nWhether you are using a checkbox, a toggle or a select, you can customize the built-in form field used for the filter, using the modifyFormFieldUsing() method. The method accepts a function with a $field parameter that gives you access to the form field object to customize:\n\n`modifyFormFieldUsing()``$field````\nuse Filament\\Forms\\Components\\Checkbox;\nuse Filament\\Tables\\Filters\\Filter;\n\nFilter::make('is_featured')\n    ->modifyFormFieldUsing(fn (Checkbox $field) => $field->inline(false))\n```\n\n## #Persist filters in session\n\nTo persist the table filters in the user’s session, use the persistFiltersInSession() method:\n\n`persistFiltersInSession()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->persistFiltersInSession();\n}\n```\n\n## #Deferring filters\n\nYou can defer filter changes from affecting the table, until the user clicks an “Apply” button. To do this, use the deferFilters() method:\n\n`deferFilters()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->deferFilters();\n}\n```\n\n### #Customizing the apply filters action\n\nWhen deferring filters, you can customize the “Apply” button, using the filtersApplyAction() method, passing a closure that returns an action. All methods that are available to customize action trigger buttons can be used:\n\n`filtersApplyAction()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->filtersApplyAction(\n            fn (Action $action) => $action\n                ->link()\n                ->label('Save filters to table'),\n        );\n}\n```\n\n## #Deselecting records when filters change\n\nBy default, all records will be deselected when the filters change. Using the deselectAllRecordsWhenFiltered(false) method, you can disable this behavior:\n\n`deselectAllRecordsWhenFiltered(false)````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->deselectAllRecordsWhenFiltered(false);\n}\n```\n\n## #Modifying the base query\n\nBy default, modifications to the Eloquent query performed in the query() method will be applied inside a scoped where() clause. This is to ensure that the query does not clash with any other filters that may be applied, especially those that use orWhere().\n\n`query()``where()``orWhere()`However, the downside of this is that the query() method cannot be used to modify the query in other ways, such as removing global scopes, since the base query needs to be modified directly, not the scoped query.\n\n`query()`To modify the base query directly, you may use the baseQuery() method, passing a closure that receives the base query:\n\n`baseQuery()````\nuse Illuminate\\Database\\Eloquent\\Builder;\nuse Illuminate\\Database\\Eloquent\\SoftDeletingScope;\nuse Filament\\Tables\\Filters\\TernaryFilter;\n\nTernaryFilter::make('trashed')\n    // ...\n    ->baseQuery(fn (Builder $query) => $query->withoutGlobalScopes([\n        SoftDeletingScope::class,\n    ]))\n```\n\n## #Customizing the filters trigger action\n\nTo customize the filters trigger buttons, you may use the filtersTriggerAction() method, passing a closure that returns an action. All methods that are available to customize action trigger buttons can be used:\n\n`filtersTriggerAction()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->filtersTriggerAction(\n            fn (Action $action) => $action\n                ->button()\n                ->label('Filter'),\n        );\n}\n```\n\n## #Table filter utility injection\n\nThe vast majority of methods used to configure filters accept functions as parameters instead of hardcoded values:\n\n```\nuse App\\Models\\Author;\nuse Filament\\Tables\\Filters\\SelectFilter;\n\nSelectFilter::make('author')\n    ->options(fn (): array => Author::query()->pluck('name', 'id')->all())\n```\n\nThis alone unlocks many customization possibilities.\n\nThe package is also able to inject many utilities to use inside these functions, as parameters. All customization methods that accept functions as arguments can inject utilities.\n\nThese injected utilities require specific parameter names to be used. Otherwise, Filament doesn’t know what to inject.\n\n### #Injecting the current filter instance\n\nIf you wish to access the current filter instance, define a $filter parameter:\n\n`$filter````\nuse Filament\\Tables\\Filters\\BaseFilter;\n\nfunction (BaseFilter $filter) {\n    // ...\n}\n```\n\n### #Injecting the current Livewire component instance\n\nIf you wish to access the current Livewire component instance that the table belongs to, define a $livewire parameter:\n\n`$livewire````\nuse Filament\\Tables\\Contracts\\HasTable;\n\nfunction (HasTable $livewire) {\n    // ...\n}\n```\n\n### #Injecting the current table instance\n\nIf you wish to access the current table configuration instance that the filter belongs to, define a $table parameter:\n\n`$table````\nuse Filament\\Tables\\Table;\n\nfunction (Table $table) {\n    // ...\n}\n```\n\n### #Injecting multiple utilities\n\nThe parameters are injected dynamically using reflection, so you are able to combine multiple parameters in any order:\n\n```\nuse Filament\\Tables\\Contracts\\HasTable;\nuse Filament\\Tables\\Table;\n\nfunction (HasTable $livewire, Table $table) {\n    // ...\n}\n```\n\n### #Injecting dependencies from Laravel’s container\n\nYou may inject anything from Laravel’s container like normal, alongside utilities:\n\n```\nuse Filament\\Tables\\Table;\nuse Illuminate\\Http\\Request;\n\nfunction (Request $request, Table $table) {\n    // ...\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Tables - Filament",
                "content": "Tables  \n-  Filters",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filters allow you to define certain constraints on your data, and allow users to scope it to find the information they need. You put them in the $table->filters() method:\n\n`$table->filters()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ]);\n}\n```\n\nFilters may be created using the static make() method, passing its unique name. You should then pass a callback to query() which applies your filter’s scope:\n\n`make()``query()````\nuse Filament\\Tables\\Filters\\Filter;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nFilter::make('is_featured')\n    ->query(fn (Builder $query): Builder => $query->where('is_featured', true))\n```",
                "level": 3
              },
              {
                "title": "## #Available filters",
                "content": "By default, using the Filter::make() method will render a checkbox form component. When the checkbox is on, the query() will be activated.\n\n`Filter::make()``query()`- You can also replace the checkbox with a toggle.\n- You can use a ternary filter to replace the checkbox with a select field to allow users to pick between 3 states - usually “true”, “false” and “blank”. This is useful for filtering boolean columns that are nullable.\n- The trashed filter is a pre-built ternary filter that allows you to filter soft-deletable records.\n- You may use a select filter to allow users to select from a list of options, and filter using the selection.\n- You may use a query builder to allow users to create complex sets of filters, with an advanced user interface for combining constraints.\n- You may build custom filters with other form fields, to do whatever you want.",
                "level": 3
              },
              {
                "title": "## #Setting a label",
                "content": "By default, the label of the filter, which is displayed in the filter form, is generated from the name of the filter. You may customize this using the label() method:\n\n`label()````\nuse Filament\\Tables\\Filters\\Filter;\n\nFilter::make('is_featured')\n    ->label('Featured')\n```\n\nOptionally, you can have the label automatically translated using Laravel’s localization features with the translateLabel() method:\n\n`translateLabel()````\nuse Filament\\Tables\\Filters\\Filter;\n\nFilter::make('is_featured')\n    ->translateLabel() // Equivalent to `label(__('Is featured'))`\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the filter form",
                "content": "By default, creating a filter with the Filter class will render a checkbox form component. When the checkbox is checked, the query() function will be applied to the table’s query, scoping the records in the table. When the checkbox is unchecked, the query() function will be removed from the table’s query.\n\n`Filter``query()``query()`Filters are built entirely on Filament’s form fields. They can render any combination of form fields, which users can then interact with to filter the table.",
                "level": 3
              },
              {
                "title": "### #Using a toggle button instead of a checkbox",
                "content": "The simplest example of managing the form field that is used for a filter is to replace the checkbox with a toggle button, using the toggle() method:\n\n`toggle()````\nuse Filament\\Tables\\Filters\\Filter;\n\nFilter::make('is_featured')\n    ->toggle()\n```",
                "level": 4
              },
              {
                "title": "### #Applying the filter by default",
                "content": "You may set a filter to be enabled by default, using the default() method:\n\n`default()````\nuse Filament\\Tables\\Filters\\Filter;\n\nFilter::make('is_featured')\n    ->default()\n```",
                "level": 4
              },
              {
                "title": "### #Customizing the built-in filter form field",
                "content": "Whether you are using a checkbox, a toggle or a select, you can customize the built-in form field used for the filter, using the modifyFormFieldUsing() method. The method accepts a function with a $field parameter that gives you access to the form field object to customize:\n\n`modifyFormFieldUsing()``$field````\nuse Filament\\Forms\\Components\\Checkbox;\nuse Filament\\Tables\\Filters\\Filter;\n\nFilter::make('is_featured')\n    ->modifyFormFieldUsing(fn (Checkbox $field) => $field->inline(false))\n```",
                "level": 4
              },
              {
                "title": "## #Persist filters in session",
                "content": "To persist the table filters in the user’s session, use the persistFiltersInSession() method:\n\n`persistFiltersInSession()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->persistFiltersInSession();\n}\n```",
                "level": 3
              },
              {
                "title": "## #Deferring filters",
                "content": "You can defer filter changes from affecting the table, until the user clicks an “Apply” button. To do this, use the deferFilters() method:\n\n`deferFilters()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->deferFilters();\n}\n```",
                "level": 3
              },
              {
                "title": "### #Customizing the apply filters action",
                "content": "When deferring filters, you can customize the “Apply” button, using the filtersApplyAction() method, passing a closure that returns an action. All methods that are available to customize action trigger buttons can be used:\n\n`filtersApplyAction()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->filtersApplyAction(\n            fn (Action $action) => $action\n                ->link()\n                ->label('Save filters to table'),\n        );\n}\n```",
                "level": 4
              },
              {
                "title": "## #Deselecting records when filters change",
                "content": "By default, all records will be deselected when the filters change. Using the deselectAllRecordsWhenFiltered(false) method, you can disable this behavior:\n\n`deselectAllRecordsWhenFiltered(false)````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->deselectAllRecordsWhenFiltered(false);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Modifying the base query",
                "content": "By default, modifications to the Eloquent query performed in the query() method will be applied inside a scoped where() clause. This is to ensure that the query does not clash with any other filters that may be applied, especially those that use orWhere().\n\n`query()``where()``orWhere()`However, the downside of this is that the query() method cannot be used to modify the query in other ways, such as removing global scopes, since the base query needs to be modified directly, not the scoped query.\n\n`query()`To modify the base query directly, you may use the baseQuery() method, passing a closure that receives the base query:\n\n`baseQuery()````\nuse Illuminate\\Database\\Eloquent\\Builder;\nuse Illuminate\\Database\\Eloquent\\SoftDeletingScope;\nuse Filament\\Tables\\Filters\\TernaryFilter;\n\nTernaryFilter::make('trashed')\n    // ...\n    ->baseQuery(fn (Builder $query) => $query->withoutGlobalScopes([\n        SoftDeletingScope::class,\n    ]))\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the filters trigger action",
                "content": "To customize the filters trigger buttons, you may use the filtersTriggerAction() method, passing a closure that returns an action. All methods that are available to customize action trigger buttons can be used:\n\n`filtersTriggerAction()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->filters([\n            // ...\n        ])\n        ->filtersTriggerAction(\n            fn (Action $action) => $action\n                ->button()\n                ->label('Filter'),\n        );\n}\n```",
                "level": 3
              },
              {
                "title": "## #Table filter utility injection",
                "content": "The vast majority of methods used to configure filters accept functions as parameters instead of hardcoded values:\n\n```\nuse App\\Models\\Author;\nuse Filament\\Tables\\Filters\\SelectFilter;\n\nSelectFilter::make('author')\n    ->options(fn (): array => Author::query()->pluck('name', 'id')->all())\n```\n\nThis alone unlocks many customization possibilities.\n\nThe package is also able to inject many utilities to use inside these functions, as parameters. All customization methods that accept functions as arguments can inject utilities.\n\nThese injected utilities require specific parameter names to be used. Otherwise, Filament doesn’t know what to inject.",
                "level": 3
              },
              {
                "title": "### #Injecting the current filter instance",
                "content": "If you wish to access the current filter instance, define a $filter parameter:\n\n`$filter````\nuse Filament\\Tables\\Filters\\BaseFilter;\n\nfunction (BaseFilter $filter) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting the current Livewire component instance",
                "content": "If you wish to access the current Livewire component instance that the table belongs to, define a $livewire parameter:\n\n`$livewire````\nuse Filament\\Tables\\Contracts\\HasTable;\n\nfunction (HasTable $livewire) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting the current table instance",
                "content": "If you wish to access the current table configuration instance that the filter belongs to, define a $table parameter:\n\n`$table````\nuse Filament\\Tables\\Table;\n\nfunction (Table $table) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting multiple utilities",
                "content": "The parameters are injected dynamically using reflection, so you are able to combine multiple parameters in any order:\n\n```\nuse Filament\\Tables\\Contracts\\HasTable;\nuse Filament\\Tables\\Table;\n\nfunction (HasTable $livewire, Table $table) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting dependencies from Laravel’s container",
                "content": "You may inject anything from Laravel’s container like normal, alongside utilities:\n\n```\nuse Filament\\Tables\\Table;\nuse Illuminate\\Http\\Request;\n\nfunction (Request $request, Table $table) {\n    // ...\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Available filters",
              "Setting a label",
              "Customizing the filter form",
              "Using a toggle button instead of a checkbox",
              "Applying the filter by default",
              "Customizing the built-in filter form field",
              "Persist filters in session",
              "Deferring filters",
              "Customizing the apply filters action"
            ],
            "code_examples_count": 38,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "actions": {
          "metadata": {
            "title": "Actions",
            "url": "https://filamentphp.com/docs/3.x/tables/actions",
            "section": "tables",
            "word_count": 1574,
            "character_count": 12873
          },
          "content": {
            "full_text": "\n# Actions - Tables - Filament\n\nTables\n\n# Actions\n\n## #Overview\n\nFilament’s tables can use Actions. They are buttons that can be added to the end of any table row, or even in the header of a table. For instance, you may want an action to “create” a new record in the header, and then “edit” and “delete” actions on each row. Bulk actions can be used to execute code when records in the table are selected. Additionally, actions can be added to any table column, such that each cell in that column is a trigger for your action.\n\nIt’s highly advised that you read the documentation about customizing action trigger buttons and action modals to that you are aware of the full capabilities of actions.\n\n## #Row actions\n\nAction buttons can be rendered at the end of each table row. You can put them in the $table->actions() method:\n\n`$table->actions()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->actions([\n            // ...\n        ]);\n}\n```\n\nActions may be created using the static make() method, passing its unique name.\n\n`make()`You can then pass a function to action() which executes the task, or a function to url() which creates a link:\n\n`action()``url()````\nuse App\\Models\\Post;\nuse Filament\\Tables\\Actions\\Action;\n\nAction::make('edit')\n    ->url(fn (Post $record): string => route('posts.edit', $record))\n    ->openUrlInNewTab()\n\nAction::make('delete')\n    ->requiresConfirmation()\n    ->action(fn (Post $record) => $record->delete())\n```\n\nAll methods on the action accept callback functions, where you can access the current table $record that was clicked.\n\n`$record`### #Positioning row actions before columns\n\nBy default, the row actions in your table are rendered in the final cell of each row. You may move them before the columns by using the position argument:\n\n`position````\nuse Filament\\Tables\\Enums\\ActionsPosition;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->actions([\n            // ...\n        ], position: ActionsPosition::BeforeColumns);\n}\n```\n\n### #Positioning row actions before the checkbox column\n\nBy default, the row actions in your table are rendered in the final cell of each row. You may move them before the checkbox column by using the position argument:\n\n`position````\nuse Filament\\Tables\\Enums\\ActionsPosition;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->actions([\n            // ...\n        ], position: ActionsPosition::BeforeCells);\n}\n```\n\n### #Accessing the selected table rows\n\nYou may want an action to be able to access all the selected rows in the table. Usually, this is done with a bulk action in the header of the table. However, you may want to do this with a row action, where the selected rows provide context for the action.\n\nFor example, you may want to have a row action that copies the row data to all the selected records. To force the table to be selectable, even if there aren’t bulk actions defined, you need to use the selectable() method. To allow the action to access the selected records, you need to use the accessSelectedRecords() method. Then, you can use the $selectedRecords parameter in your action to access the selected records:\n\n`selectable()``accessSelectedRecords()``$selectedRecords````\nuse Filament\\Tables\\Table;\nuse Filament\\Tables\\Actions\\Action;\nuse Illuminate\\Database\\Eloquent\\Collection;\nuse Illuminate\\Database\\Eloquent\\Model;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->selectable()\n        ->actions([\n            Action::make('copyToSelected')\n                ->accessSelectedRecords()\n                ->action(function (Model $record, Collection $selectedRecords) {\n                    $selectedRecords->each(\n                        fn (Model $selectedRecord) => $selectedRecord->update([\n                            'is_active' => $record->is_active,\n                        ]),\n                    );\n                }),\n        ]);\n}\n```\n\n## #Bulk actions\n\nTables also support “bulk actions”. These can be used when the user selects rows in the table. Traditionally, when rows are selected, a “bulk actions” button appears in the top left corner of the table. When the user clicks this button, they are presented with a dropdown menu of actions to choose from. You can put them in the $table->bulkActions() method:\n\n`$table->bulkActions()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->bulkActions([\n            // ...\n        ]);\n}\n```\n\nBulk actions may be created using the static make() method, passing its unique name. You should then pass a callback to action() which executes the task:\n\n`make()``action()````\nuse Filament\\Tables\\Actions\\BulkAction;\nuse Illuminate\\Database\\Eloquent\\Collection;\n\nBulkAction::make('delete')\n    ->requiresConfirmation()\n    ->action(fn (Collection $records) => $records->each->delete())\n```\n\nThe function allows you to access the current table $records that are selected. It is an Eloquent collection of models.\n\n`$records`### #Grouping bulk actions\n\nYou may use a BulkActionGroup object to group multiple bulk actions together in a dropdown. Any bulk actions that remain outside the BulkActionGroup will be rendered next to the dropdown’s trigger button:\n\n`BulkActionGroup``BulkActionGroup````\nuse Filament\\Tables\\Actions\\BulkAction;\nuse Filament\\Tables\\Actions\\BulkActionGroup;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->bulkActions([\n            BulkActionGroup::make([\n                BulkAction::make('delete')\n                    ->requiresConfirmation()\n                    ->action(fn (Collection $records) => $records->each->delete()),\n                BulkAction::make('forceDelete')\n                    ->requiresConfirmation()\n                    ->action(fn (Collection $records) => $records->each->forceDelete()),\n            ]),\n            BulkAction::make('export')->button()->action(fn (Collection $records) => ...),\n        ]);\n}\n```\n\nAlternatively, if all of your bulk actions are grouped, you can use the shorthand groupedBulkActions() method:\n\n`groupedBulkActions()````\nuse Filament\\Tables\\Actions\\BulkAction;\nuse Filament\\Tables\\Actions\\BulkActionGroup;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groupedBulkActions([\n            BulkAction::make('delete')\n                ->requiresConfirmation()\n                ->action(fn (Collection $records) => $records->each->delete()),\n            BulkAction::make('forceDelete')\n                ->requiresConfirmation()\n                ->action(fn (Collection $records) => $records->each->forceDelete()),\n        ]);\n}\n```\n\n### #Deselecting records once a bulk action has finished\n\nYou may deselect the records after a bulk action has been executed using the deselectRecordsAfterCompletion() method:\n\n`deselectRecordsAfterCompletion()````\nuse Filament\\Tables\\Actions\\BulkAction;\nuse Illuminate\\Database\\Eloquent\\Collection;\n\nBulkAction::make('delete')\n    ->action(fn (Collection $records) => $records->each->delete())\n    ->deselectRecordsAfterCompletion()\n```\n\n### #Disabling bulk actions for some rows\n\nYou may conditionally disable bulk actions for a specific record:\n\n```\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Model;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->bulkActions([\n            // ...\n        ])\n        ->checkIfRecordIsSelectableUsing(\n            fn (Model $record): bool => $record->status === Status::Enabled,\n        );\n}\n```\n\n### #Preventing bulk-selection of all pages\n\nThe selectCurrentPageOnly() method can be used to prevent the user from easily bulk-selecting all records in the table at once, and instead only allows them to select one page at a time:\n\n`selectCurrentPageOnly()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->bulkActions([\n            // ...\n        ])\n        ->selectCurrentPageOnly();\n}\n```\n\n## #Header actions\n\nBoth row actions and bulk actions can be rendered in the header of the table. You can put them in the $table->headerActions() method:\n\n`$table->headerActions()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->headerActions([\n            // ...\n        ]);\n}\n```\n\nThis is useful for things like “create” actions, which are not related to any specific table row, or bulk actions that need to be more visible.\n\n## #Column actions\n\nActions can be added to columns, such that when a cell in that column is clicked, it acts as the trigger for an action. You can learn more about column actions in the documentation.\n\n## #Prebuilt table actions\n\nFilament includes several prebuilt actions and bulk actions that you can add to a table. Their aim is to simplify the most common Eloquent-related actions:\n\n- Create\n- Edit\n- View\n- Delete\n- Replicate\n- Force-delete\n- Restore\n- Import\n- Export\n\n## #Grouping actions\n\nYou may use an ActionGroup object to group multiple table actions together in a dropdown:\n\n`ActionGroup````\nuse Filament\\Tables\\Actions\\ActionGroup;\nuse Filament\\Tables\\Actions\\DeleteAction;\nuse Filament\\Tables\\Actions\\EditAction;\nuse Filament\\Tables\\Actions\\ViewAction;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->actions([\n            ActionGroup::make([\n                ViewAction::make(),\n                EditAction::make(),\n                DeleteAction::make(),\n            ]),\n            // ...\n        ]);\n}\n```\n\n### #Choosing an action group button style\n\nOut of the box, action group triggers have 3 styles - “button”, “link”, and “icon button”.\n\n“Icon button” triggers are circular buttons with an icon and no label. Usually, this is the default button style, but you can use it manually with the iconButton() method:\n\n`iconButton()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])->iconButton()\n```\n\n“Button” triggers have a background color, label, and optionally an icon. You can switch to that style with the button() method:\n\n`button()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])\n    ->button()\n    ->label('Actions')\n```\n\n“Link” triggers have no background color. They must have a label and optionally an icon. They look like a link that you might find embedded within text. You can switch to that style with the link() method:\n\n`link()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])\n    ->link()\n    ->label('Actions')\n```\n\n### #Setting the action group button icon\n\nYou may set the icon of the action group button using the icon() method:\n\n`icon()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])->icon('heroicon-m-ellipsis-horizontal');\n```\n\n### #Setting the action group button color\n\nYou may set the color of the action group button using the color() method:\n\n`color()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])->color('info');\n```\n\n### #Setting the action group button size\n\nButtons come in 3 sizes - sm, md or lg. You may set the size of the action group button using the size() method:\n\n`sm``md``lg``size()````\nuse Filament\\Support\\Enums\\ActionSize;\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])->size(ActionSize::Small);\n```\n\n### #Setting the action group tooltip\n\nYou may set the tooltip of the action group using the tooltip() method:\n\n`tooltip()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])->tooltip('Actions');\n```\n\n## #Table action utility injection\n\nAll actions, not just table actions, have access to many utilities within the vast majority of configuration methods. However, in addition to those, table actions have access to a few more:\n\n### #Injecting the current Eloquent record\n\nIf you wish to access the current Eloquent record of the action, define a $record parameter:\n\n`$record````\nuse Illuminate\\Database\\Eloquent\\Model;\n\nfunction (Model $record) {\n    // ...\n}\n```\n\nBe aware that bulk actions, header actions, and empty state actions do not have access to the $record, as they are not related to any table row.\n\n`$record`### #Injecting the current Eloquent model class\n\nIf you wish to access the current Eloquent model class of the table, define a $model parameter:\n\n`$model````\nfunction (string $model) {\n    // ...\n}\n```\n\n### #Injecting the current table instance\n\nIf you wish to access the current table configuration instance that the action belongs to, define a $table parameter:\n\n`$table````\nuse Filament\\Tables\\Table;\n\nfunction (Table $table) {\n    // ...\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Actions - Tables - Filament",
                "content": "Tables",
                "level": 1
              },
              {
                "title": "# Actions",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament’s tables can use Actions. They are buttons that can be added to the end of any table row, or even in the header of a table. For instance, you may want an action to “create” a new record in the header, and then “edit” and “delete” actions on each row. Bulk actions can be used to execute code when records in the table are selected. Additionally, actions can be added to any table column, such that each cell in that column is a trigger for your action.\n\nIt’s highly advised that you read the documentation about customizing action trigger buttons and action modals to that you are aware of the full capabilities of actions.",
                "level": 3
              },
              {
                "title": "## #Row actions",
                "content": "Action buttons can be rendered at the end of each table row. You can put them in the $table->actions() method:\n\n`$table->actions()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->actions([\n            // ...\n        ]);\n}\n```\n\nActions may be created using the static make() method, passing its unique name.\n\n`make()`You can then pass a function to action() which executes the task, or a function to url() which creates a link:\n\n`action()``url()````\nuse App\\Models\\Post;\nuse Filament\\Tables\\Actions\\Action;\n\nAction::make('edit')\n    ->url(fn (Post $record): string => route('posts.edit', $record))\n    ->openUrlInNewTab()\n\nAction::make('delete')\n    ->requiresConfirmation()\n    ->action(fn (Post $record) => $record->delete())\n```\n\nAll methods on the action accept callback functions, where you can access the current table $record that was clicked.\n\n`$record`### #Positioning row actions before columns\n\nBy default, the row actions in your table are rendered in the final cell of each row. You may move them before the columns by using the position argument:\n\n`position````\nuse Filament\\Tables\\Enums\\ActionsPosition;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->actions([\n            // ...\n        ], position: ActionsPosition::BeforeColumns);\n}\n```",
                "level": 3
              },
              {
                "title": "### #Positioning row actions before the checkbox column",
                "content": "By default, the row actions in your table are rendered in the final cell of each row. You may move them before the checkbox column by using the position argument:\n\n`position````\nuse Filament\\Tables\\Enums\\ActionsPosition;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->actions([\n            // ...\n        ], position: ActionsPosition::BeforeCells);\n}\n```",
                "level": 4
              },
              {
                "title": "### #Accessing the selected table rows",
                "content": "You may want an action to be able to access all the selected rows in the table. Usually, this is done with a bulk action in the header of the table. However, you may want to do this with a row action, where the selected rows provide context for the action.\n\nFor example, you may want to have a row action that copies the row data to all the selected records. To force the table to be selectable, even if there aren’t bulk actions defined, you need to use the selectable() method. To allow the action to access the selected records, you need to use the accessSelectedRecords() method. Then, you can use the $selectedRecords parameter in your action to access the selected records:\n\n`selectable()``accessSelectedRecords()``$selectedRecords````\nuse Filament\\Tables\\Table;\nuse Filament\\Tables\\Actions\\Action;\nuse Illuminate\\Database\\Eloquent\\Collection;\nuse Illuminate\\Database\\Eloquent\\Model;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->selectable()\n        ->actions([\n            Action::make('copyToSelected')\n                ->accessSelectedRecords()\n                ->action(function (Model $record, Collection $selectedRecords) {\n                    $selectedRecords->each(\n                        fn (Model $selectedRecord) => $selectedRecord->update([\n                            'is_active' => $record->is_active,\n                        ]),\n                    );\n                }),\n        ]);\n}\n```",
                "level": 4
              },
              {
                "title": "## #Bulk actions",
                "content": "Tables also support “bulk actions”. These can be used when the user selects rows in the table. Traditionally, when rows are selected, a “bulk actions” button appears in the top left corner of the table. When the user clicks this button, they are presented with a dropdown menu of actions to choose from. You can put them in the $table->bulkActions() method:\n\n`$table->bulkActions()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->bulkActions([\n            // ...\n        ]);\n}\n```\n\nBulk actions may be created using the static make() method, passing its unique name. You should then pass a callback to action() which executes the task:\n\n`make()``action()````\nuse Filament\\Tables\\Actions\\BulkAction;\nuse Illuminate\\Database\\Eloquent\\Collection;\n\nBulkAction::make('delete')\n    ->requiresConfirmation()\n    ->action(fn (Collection $records) => $records->each->delete())\n```\n\nThe function allows you to access the current table $records that are selected. It is an Eloquent collection of models.\n\n`$records`### #Grouping bulk actions\n\nYou may use a BulkActionGroup object to group multiple bulk actions together in a dropdown. Any bulk actions that remain outside the BulkActionGroup will be rendered next to the dropdown’s trigger button:\n\n`BulkActionGroup``BulkActionGroup````\nuse Filament\\Tables\\Actions\\BulkAction;\nuse Filament\\Tables\\Actions\\BulkActionGroup;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->bulkActions([\n            BulkActionGroup::make([\n                BulkAction::make('delete')\n                    ->requiresConfirmation()\n                    ->action(fn (Collection $records) => $records->each->delete()),\n                BulkAction::make('forceDelete')\n                    ->requiresConfirmation()\n                    ->action(fn (Collection $records) => $records->each->forceDelete()),\n            ]),\n            BulkAction::make('export')->button()->action(fn (Collection $records) => ...),\n        ]);\n}\n```\n\nAlternatively, if all of your bulk actions are grouped, you can use the shorthand groupedBulkActions() method:\n\n`groupedBulkActions()````\nuse Filament\\Tables\\Actions\\BulkAction;\nuse Filament\\Tables\\Actions\\BulkActionGroup;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groupedBulkActions([\n            BulkAction::make('delete')\n                ->requiresConfirmation()\n                ->action(fn (Collection $records) => $records->each->delete()),\n            BulkAction::make('forceDelete')\n                ->requiresConfirmation()\n                ->action(fn (Collection $records) => $records->each->forceDelete()),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "### #Deselecting records once a bulk action has finished",
                "content": "You may deselect the records after a bulk action has been executed using the deselectRecordsAfterCompletion() method:\n\n`deselectRecordsAfterCompletion()````\nuse Filament\\Tables\\Actions\\BulkAction;\nuse Illuminate\\Database\\Eloquent\\Collection;\n\nBulkAction::make('delete')\n    ->action(fn (Collection $records) => $records->each->delete())\n    ->deselectRecordsAfterCompletion()\n```",
                "level": 4
              },
              {
                "title": "### #Disabling bulk actions for some rows",
                "content": "You may conditionally disable bulk actions for a specific record:\n\n```\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Model;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->bulkActions([\n            // ...\n        ])\n        ->checkIfRecordIsSelectableUsing(\n            fn (Model $record): bool => $record->status === Status::Enabled,\n        );\n}\n```",
                "level": 4
              },
              {
                "title": "### #Preventing bulk-selection of all pages",
                "content": "The selectCurrentPageOnly() method can be used to prevent the user from easily bulk-selecting all records in the table at once, and instead only allows them to select one page at a time:\n\n`selectCurrentPageOnly()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->bulkActions([\n            // ...\n        ])\n        ->selectCurrentPageOnly();\n}\n```",
                "level": 4
              },
              {
                "title": "## #Header actions",
                "content": "Both row actions and bulk actions can be rendered in the header of the table. You can put them in the $table->headerActions() method:\n\n`$table->headerActions()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->headerActions([\n            // ...\n        ]);\n}\n```\n\nThis is useful for things like “create” actions, which are not related to any specific table row, or bulk actions that need to be more visible.",
                "level": 3
              },
              {
                "title": "## #Column actions",
                "content": "Actions can be added to columns, such that when a cell in that column is clicked, it acts as the trigger for an action. You can learn more about column actions in the documentation.",
                "level": 3
              },
              {
                "title": "## #Prebuilt table actions",
                "content": "Filament includes several prebuilt actions and bulk actions that you can add to a table. Their aim is to simplify the most common Eloquent-related actions:\n\n- Create\n- Edit\n- View\n- Delete\n- Replicate\n- Force-delete\n- Restore\n- Import\n- Export",
                "level": 3
              },
              {
                "title": "## #Grouping actions",
                "content": "You may use an ActionGroup object to group multiple table actions together in a dropdown:\n\n`ActionGroup````\nuse Filament\\Tables\\Actions\\ActionGroup;\nuse Filament\\Tables\\Actions\\DeleteAction;\nuse Filament\\Tables\\Actions\\EditAction;\nuse Filament\\Tables\\Actions\\ViewAction;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->actions([\n            ActionGroup::make([\n                ViewAction::make(),\n                EditAction::make(),\n                DeleteAction::make(),\n            ]),\n            // ...\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "### #Choosing an action group button style",
                "content": "Out of the box, action group triggers have 3 styles - “button”, “link”, and “icon button”.\n\n“Icon button” triggers are circular buttons with an icon and no label. Usually, this is the default button style, but you can use it manually with the iconButton() method:\n\n`iconButton()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])->iconButton()\n```\n\n“Button” triggers have a background color, label, and optionally an icon. You can switch to that style with the button() method:\n\n`button()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])\n    ->button()\n    ->label('Actions')\n```\n\n“Link” triggers have no background color. They must have a label and optionally an icon. They look like a link that you might find embedded within text. You can switch to that style with the link() method:\n\n`link()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])\n    ->link()\n    ->label('Actions')\n```",
                "level": 4
              },
              {
                "title": "### #Setting the action group button icon",
                "content": "You may set the icon of the action group button using the icon() method:\n\n`icon()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])->icon('heroicon-m-ellipsis-horizontal');\n```",
                "level": 4
              },
              {
                "title": "### #Setting the action group button color",
                "content": "You may set the color of the action group button using the color() method:\n\n`color()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])->color('info');\n```",
                "level": 4
              },
              {
                "title": "### #Setting the action group button size",
                "content": "Buttons come in 3 sizes - sm, md or lg. You may set the size of the action group button using the size() method:\n\n`sm``md``lg``size()````\nuse Filament\\Support\\Enums\\ActionSize;\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])->size(ActionSize::Small);\n```",
                "level": 4
              },
              {
                "title": "### #Setting the action group tooltip",
                "content": "You may set the tooltip of the action group using the tooltip() method:\n\n`tooltip()````\nuse Filament\\Tables\\Actions\\ActionGroup;\n\nActionGroup::make([\n    // ...\n])->tooltip('Actions');\n```",
                "level": 4
              },
              {
                "title": "## #Table action utility injection",
                "content": "All actions, not just table actions, have access to many utilities within the vast majority of configuration methods. However, in addition to those, table actions have access to a few more:",
                "level": 3
              },
              {
                "title": "### #Injecting the current Eloquent record",
                "content": "If you wish to access the current Eloquent record of the action, define a $record parameter:\n\n`$record````\nuse Illuminate\\Database\\Eloquent\\Model;\n\nfunction (Model $record) {\n    // ...\n}\n```\n\nBe aware that bulk actions, header actions, and empty state actions do not have access to the $record, as they are not related to any table row.\n\n`$record`### #Injecting the current Eloquent model class\n\nIf you wish to access the current Eloquent model class of the table, define a $model parameter:\n\n`$model````\nfunction (string $model) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting the current table instance",
                "content": "If you wish to access the current table configuration instance that the action belongs to, define a $table parameter:\n\n`$table````\nuse Filament\\Tables\\Table;\n\nfunction (Table $table) {\n    // ...\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Row actions",
              "Positioning row actions before the checkbox column",
              "Accessing the selected table rows",
              "Bulk actions",
              "Deselecting records once a bulk action has finished",
              "Disabling bulk actions for some rows",
              "Preventing bulk-selection of all pages",
              "Header actions",
              "Column actions"
            ],
            "code_examples_count": 48,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "layout": {
          "metadata": {
            "title": "Layout",
            "url": "https://filamentphp.com/docs/3.x/tables/layout",
            "section": "tables",
            "word_count": 1250,
            "character_count": 13256
          },
          "content": {
            "full_text": "\n# Layout - Tables - Filament\n\nTables\n\n# Layout\n\n## #The problem with traditional table layouts\n\nTraditional tables are notorious for having bad responsiveness. On mobile, there is only so much flexibility you have when rendering content that is horizontally long:\n\n- Allow the user to scroll horizontally to see more table content\n- Hide non-important columns on smaller devices\n\nBoth of these are possible with Filament. Tables automatically scroll horizontally when they overflow anyway, and you may choose to show and hide columns based on the responsive breakpoint of the browser. To do this, you may use a visibleFrom() or hiddenFrom() method:\n\n`visibleFrom()``hiddenFrom()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('slug')\n    ->visibleFrom('md')\n```\n\nThis is fine, but there is still a glaring issue - on mobile, the user is unable to see much information in a table row at once without scrolling.\n\nThankfully, Filament lets you build responsive table-like interfaces, without touching HTML or CSS. These layouts let you define exactly where content appears in a table row, at each responsive breakpoint.\n\n## #Allowing columns to stack on mobile\n\nLet’s introduce a component - Split:\n\n`Split````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular(),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    TextColumn::make('email'),\n])\n```\n\nA Split component is used to wrap around columns, and allow them to stack on mobile.\n\n`Split`By default, columns within a split will appear aside each other all the time. However, you may choose a responsive breakpoint where this behavior starts from(). Before this point, the columns will stack on top of each other:\n\n`from()````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular(),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    TextColumn::make('email'),\n])->from('md')\n```\n\nIn this example, the columns will only appear horizontally aside each other from md breakpoint devices onwards:\n\n`md`### #Preventing a column from creating whitespace\n\nSplits, like table columns, will automatically adjust their whitespace to ensure that each column has proportionate separation. You can prevent this from happening, using grow(false). In this example, we will make sure that the avatar image will sit tightly against the name column:\n\n`grow(false)````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular()\n        ->grow(false),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    TextColumn::make('email'),\n])\n```\n\nThe other columns which are allowed to grow() will adjust to consume the newly-freed space:\n\n`grow()`### #Stacking within a split\n\nInside a split, you may stack multiple columns on top of each other vertically. This allows you to display more data inside fewer columns on desktop:\n\n```\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular(),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    Stack::make([\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone'),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ]),\n])\n```\n\n#### #Hiding a stack on mobile\n\nSimilar to individual columns, you may choose to hide a stack based on the responsive breakpoint of the browser. To do this, you may use a visibleFrom() method:\n\n`visibleFrom()````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular(),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    Stack::make([\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone'),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ])->visibleFrom('md'),\n])\n```\n\n#### #Aligning stacked content\n\nBy default, columns within a stack are aligned to the start. You may choose to align columns within a stack to the Alignment::Center or Alignment::End:\n\n`Alignment::Center``Alignment::End````\nuse Filament\\Support\\Enums\\Alignment;\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular(),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    Stack::make([\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone')\n            ->grow(false),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope')\n            ->grow(false),\n    ])\n        ->alignment(Alignment::End)\n        ->visibleFrom('md'),\n])\n```\n\nEnsure that the columns within the stack have grow(false) set, otherwise they will stretch to fill the entire width of the stack and follow their own alignment configuration instead of the stack’s.\n\n`grow(false)`#### #Spacing stacked content\n\nBy default, stacked content has no vertical padding between columns. To add some, you may use the space() method, which accepts either 1, 2, or 3, corresponding to Tailwind’s spacing scale:\n\n`space()``1``2``3````\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nStack::make([\n    TextColumn::make('phone')\n        ->icon('heroicon-m-phone'),\n    TextColumn::make('email')\n        ->icon('heroicon-m-envelope'),\n])->space(1)\n```\n\n## #Controlling column width using a grid\n\nSometimes, using a Split creates inconsistent widths when columns contain lots of content. This is because it’s powered by Flexbox internally and each row individually controls how much space is allocated to content.\n\n`Split`Instead, you may use a Grid layout, which uses CSS Grid Layout to allow you to control column widths:\n\n`Grid````\nuse Filament\\Tables\\Columns\\Layout\\Grid;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nGrid::make([\n    'lg' => 2,\n])\n    ->schema([\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone'),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ])\n```\n\nThese columns will always consume equal width within the grid, from the lg breakpoint.\n\n`lg`You may choose to customize the number of columns within the grid at other breakpoints:\n\n```\nuse Filament\\Tables\\Columns\\Layout\\Grid;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nGrid::make([\n    'lg' => 2,\n    '2xl' => 4,\n])\n    ->schema([\n        Stack::make([\n            TextColumn::make('name'),\n            TextColumn::make('job'),\n        ]),\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone'),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ])\n```\n\nAnd you can even control how many grid columns will be consumed by each component at each breakpoint:\n\n```\nuse Filament\\Tables\\Columns\\Layout\\Grid;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nGrid::make([\n    'lg' => 2,\n    '2xl' => 5,\n])\n    ->schema([\n        Stack::make([\n            TextColumn::make('name'),\n            TextColumn::make('job'),\n        ])->columnSpan([\n            'lg' => 'full',\n            '2xl' => 2,\n        ]),\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone')\n            ->columnSpan([\n                '2xl' => 2,\n            ]),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ])\n```\n\n## #Collapsible content\n\nWhen you’re using a column layout like split or stack, then you can also add collapsible content. This is very useful for when you don’t want to display all data in the table at once, but still want it to be accessible to the user if they need to access it, without navigating away.\n\nSplit and stack components can be made collapsible(), but there is also a dedicated Panel component that provides a pre-styled background color and border radius, to separate the collapsible content from the rest:\n\n`collapsible()``Panel````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Panel;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\n[\n    Split::make([\n        ImageColumn::make('avatar')\n            ->circular(),\n        TextColumn::make('name')\n            ->weight(FontWeight::Bold)\n            ->searchable()\n            ->sortable(),\n    ]),\n    Panel::make([\n        Stack::make([\n            TextColumn::make('phone')\n                ->icon('heroicon-m-phone'),\n            TextColumn::make('email')\n                ->icon('heroicon-m-envelope'),\n        ]),\n    ])->collapsible(),\n]\n```\n\nYou can expand a panel by default using the collapsed(false) method:\n\n`collapsed(false)````\nuse Filament\\Tables\\Columns\\Layout\\Panel;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nPanel::make([\n    Split::make([\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone'),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ])->from('md'),\n])->collapsed(false)\n```\n\n## #Arranging records into a grid\n\nSometimes, you may find that your data fits into a grid format better than a list. Filament can handle that too!\n\nSimply use the $table->contentGrid() method:\n\n`$table->contentGrid()````\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Stack::make([\n                // Columns\n            ]),\n        ])\n        ->contentGrid([\n            'md' => 2,\n            'xl' => 3,\n        ]);\n}\n```\n\nIn this example, the rows will be displayed in a grid:\n\n- On mobile, they will be displayed in 1 column only.\n- From the md breakpoint, they will be displayed in 2 columns.\n- From the xl breakpoint onwards, they will be displayed in 3 columns.\n\n`md``xl`These settings are fully customizable, any breakpoint from sm to 2xl can contain 1 to 12 columns.\n\n`sm``2xl``1``12`## #Custom HTML\n\nYou may add custom HTML to your table using a View component. It can even be collapsible():\n\n`View``collapsible()````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\View;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\n[\n    Split::make([\n        ImageColumn::make('avatar')\n            ->circular(),\n        TextColumn::make('name')\n            ->weight(FontWeight::Bold)\n            ->searchable()\n            ->sortable(),\n    ]),\n    View::make('users.table.collapsible-row-content')\n        ->collapsible(),\n]\n```\n\nNow, create a /resources/views/users/table/collapsible-row-content.blade.php file, and add in your HTML. You can access the table record using $getRecord():\n\n`/resources/views/users/table/collapsible-row-content.blade.php``$getRecord()````\n<p class=\"px-4 py-3 bg-gray-100 rounded-lg\">\n    <span class=\"font-medium\">\n        Email address:\n    </span>\n\n    <span>\n        {{ $getRecord()->email }}\n    </span>\n</p>\n```\n\n### #Embedding other components\n\nYou could even pass in columns or other layout components to the components() method:\n\n`components()````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\View;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\n[\n    Split::make([\n        ImageColumn::make('avatar')\n            ->circular(),\n        TextColumn::make('name')\n            ->weight(FontWeight::Bold)\n            ->searchable()\n            ->sortable(),\n    ]),\n    View::make('users.table.collapsible-row-content')\n        ->components([\n            TextColumn::make('email')\n                ->icon('heroicon-m-envelope'),\n        ])\n        ->collapsible(),\n]\n```\n\nNow, render the components in the Blade file:\n\n```\n<div class=\"px-4 py-3 bg-gray-100 rounded-lg\">\n    <x-filament-tables::columns.layout\n        :components=\"$getComponents()\"\n        :record=\"$getRecord()\"\n        :record-key=\"$recordKey\"\n    />\n</div>\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Layout - Tables - Filament",
                "content": "Tables",
                "level": 1
              },
              {
                "title": "# Layout",
                "content": "",
                "level": 1
              },
              {
                "title": "## #The problem with traditional table layouts",
                "content": "Traditional tables are notorious for having bad responsiveness. On mobile, there is only so much flexibility you have when rendering content that is horizontally long:\n\n- Allow the user to scroll horizontally to see more table content\n- Hide non-important columns on smaller devices\n\nBoth of these are possible with Filament. Tables automatically scroll horizontally when they overflow anyway, and you may choose to show and hide columns based on the responsive breakpoint of the browser. To do this, you may use a visibleFrom() or hiddenFrom() method:\n\n`visibleFrom()``hiddenFrom()````\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('slug')\n    ->visibleFrom('md')\n```\n\nThis is fine, but there is still a glaring issue - on mobile, the user is unable to see much information in a table row at once without scrolling.\n\nThankfully, Filament lets you build responsive table-like interfaces, without touching HTML or CSS. These layouts let you define exactly where content appears in a table row, at each responsive breakpoint.",
                "level": 3
              },
              {
                "title": "## #Allowing columns to stack on mobile",
                "content": "Let’s introduce a component - Split:\n\n`Split````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular(),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    TextColumn::make('email'),\n])\n```\n\nA Split component is used to wrap around columns, and allow them to stack on mobile.\n\n`Split`By default, columns within a split will appear aside each other all the time. However, you may choose a responsive breakpoint where this behavior starts from(). Before this point, the columns will stack on top of each other:\n\n`from()````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular(),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    TextColumn::make('email'),\n])->from('md')\n```\n\nIn this example, the columns will only appear horizontally aside each other from md breakpoint devices onwards:\n\n`md`### #Preventing a column from creating whitespace\n\nSplits, like table columns, will automatically adjust their whitespace to ensure that each column has proportionate separation. You can prevent this from happening, using grow(false). In this example, we will make sure that the avatar image will sit tightly against the name column:\n\n`grow(false)````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular()\n        ->grow(false),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    TextColumn::make('email'),\n])\n```\n\nThe other columns which are allowed to grow() will adjust to consume the newly-freed space:\n\n`grow()`### #Stacking within a split\n\nInside a split, you may stack multiple columns on top of each other vertically. This allows you to display more data inside fewer columns on desktop:\n\n```\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular(),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    Stack::make([\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone'),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ]),\n])\n```",
                "level": 3
              },
              {
                "title": "#### #Hiding a stack on mobile",
                "content": "Similar to individual columns, you may choose to hide a stack based on the responsive breakpoint of the browser. To do this, you may use a visibleFrom() method:\n\n`visibleFrom()````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular(),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    Stack::make([\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone'),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ])->visibleFrom('md'),\n])\n```",
                "level": 5
              },
              {
                "title": "#### #Aligning stacked content",
                "content": "By default, columns within a stack are aligned to the start. You may choose to align columns within a stack to the Alignment::Center or Alignment::End:\n\n`Alignment::Center``Alignment::End````\nuse Filament\\Support\\Enums\\Alignment;\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nSplit::make([\n    ImageColumn::make('avatar')\n        ->circular(),\n    TextColumn::make('name')\n        ->weight(FontWeight::Bold)\n        ->searchable()\n        ->sortable(),\n    Stack::make([\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone')\n            ->grow(false),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope')\n            ->grow(false),\n    ])\n        ->alignment(Alignment::End)\n        ->visibleFrom('md'),\n])\n```\n\nEnsure that the columns within the stack have grow(false) set, otherwise they will stretch to fill the entire width of the stack and follow their own alignment configuration instead of the stack’s.\n\n`grow(false)`#### #Spacing stacked content\n\nBy default, stacked content has no vertical padding between columns. To add some, you may use the space() method, which accepts either 1, 2, or 3, corresponding to Tailwind’s spacing scale:\n\n`space()``1``2``3````\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nStack::make([\n    TextColumn::make('phone')\n        ->icon('heroicon-m-phone'),\n    TextColumn::make('email')\n        ->icon('heroicon-m-envelope'),\n])->space(1)\n```",
                "level": 5
              },
              {
                "title": "## #Controlling column width using a grid",
                "content": "Sometimes, using a Split creates inconsistent widths when columns contain lots of content. This is because it’s powered by Flexbox internally and each row individually controls how much space is allocated to content.\n\n`Split`Instead, you may use a Grid layout, which uses CSS Grid Layout to allow you to control column widths:\n\n`Grid````\nuse Filament\\Tables\\Columns\\Layout\\Grid;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nGrid::make([\n    'lg' => 2,\n])\n    ->schema([\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone'),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ])\n```\n\nThese columns will always consume equal width within the grid, from the lg breakpoint.\n\n`lg`You may choose to customize the number of columns within the grid at other breakpoints:\n\n```\nuse Filament\\Tables\\Columns\\Layout\\Grid;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nGrid::make([\n    'lg' => 2,\n    '2xl' => 4,\n])\n    ->schema([\n        Stack::make([\n            TextColumn::make('name'),\n            TextColumn::make('job'),\n        ]),\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone'),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ])\n```\n\nAnd you can even control how many grid columns will be consumed by each component at each breakpoint:\n\n```\nuse Filament\\Tables\\Columns\\Layout\\Grid;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nGrid::make([\n    'lg' => 2,\n    '2xl' => 5,\n])\n    ->schema([\n        Stack::make([\n            TextColumn::make('name'),\n            TextColumn::make('job'),\n        ])->columnSpan([\n            'lg' => 'full',\n            '2xl' => 2,\n        ]),\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone')\n            ->columnSpan([\n                '2xl' => 2,\n            ]),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ])\n```",
                "level": 3
              },
              {
                "title": "## #Collapsible content",
                "content": "When you’re using a column layout like split or stack, then you can also add collapsible content. This is very useful for when you don’t want to display all data in the table at once, but still want it to be accessible to the user if they need to access it, without navigating away.\n\nSplit and stack components can be made collapsible(), but there is also a dedicated Panel component that provides a pre-styled background color and border radius, to separate the collapsible content from the rest:\n\n`collapsible()``Panel````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Panel;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\n[\n    Split::make([\n        ImageColumn::make('avatar')\n            ->circular(),\n        TextColumn::make('name')\n            ->weight(FontWeight::Bold)\n            ->searchable()\n            ->sortable(),\n    ]),\n    Panel::make([\n        Stack::make([\n            TextColumn::make('phone')\n                ->icon('heroicon-m-phone'),\n            TextColumn::make('email')\n                ->icon('heroicon-m-envelope'),\n        ]),\n    ])->collapsible(),\n]\n```\n\nYou can expand a panel by default using the collapsed(false) method:\n\n`collapsed(false)````\nuse Filament\\Tables\\Columns\\Layout\\Panel;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nPanel::make([\n    Split::make([\n        TextColumn::make('phone')\n            ->icon('heroicon-m-phone'),\n        TextColumn::make('email')\n            ->icon('heroicon-m-envelope'),\n    ])->from('md'),\n])->collapsed(false)\n```",
                "level": 3
              },
              {
                "title": "## #Arranging records into a grid",
                "content": "Sometimes, you may find that your data fits into a grid format better than a list. Filament can handle that too!\n\nSimply use the $table->contentGrid() method:\n\n`$table->contentGrid()````\nuse Filament\\Tables\\Columns\\Layout\\Stack;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            Stack::make([\n                // Columns\n            ]),\n        ])\n        ->contentGrid([\n            'md' => 2,\n            'xl' => 3,\n        ]);\n}\n```\n\nIn this example, the rows will be displayed in a grid:\n\n- On mobile, they will be displayed in 1 column only.\n- From the md breakpoint, they will be displayed in 2 columns.\n- From the xl breakpoint onwards, they will be displayed in 3 columns.\n\n`md``xl`These settings are fully customizable, any breakpoint from sm to 2xl can contain 1 to 12 columns.\n\n`sm``2xl``1``12`## #Custom HTML\n\nYou may add custom HTML to your table using a View component. It can even be collapsible():\n\n`View``collapsible()````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\View;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\n[\n    Split::make([\n        ImageColumn::make('avatar')\n            ->circular(),\n        TextColumn::make('name')\n            ->weight(FontWeight::Bold)\n            ->searchable()\n            ->sortable(),\n    ]),\n    View::make('users.table.collapsible-row-content')\n        ->collapsible(),\n]\n```\n\nNow, create a /resources/views/users/table/collapsible-row-content.blade.php file, and add in your HTML. You can access the table record using $getRecord():\n\n`/resources/views/users/table/collapsible-row-content.blade.php``$getRecord()````\n<p class=\"px-4 py-3 bg-gray-100 rounded-lg\">\n    <span class=\"font-medium\">\n        Email address:\n    </span>\n\n    <span>\n        {{ $getRecord()->email }}\n    </span>\n</p>\n```",
                "level": 3
              },
              {
                "title": "### #Embedding other components",
                "content": "You could even pass in columns or other layout components to the components() method:\n\n`components()````\nuse Filament\\Support\\Enums\\FontWeight;\nuse Filament\\Tables\\Columns\\Layout\\Split;\nuse Filament\\Tables\\Columns\\Layout\\View;\nuse Filament\\Tables\\Columns\\ImageColumn;\nuse Filament\\Tables\\Columns\\TextColumn;\n\n[\n    Split::make([\n        ImageColumn::make('avatar')\n            ->circular(),\n        TextColumn::make('name')\n            ->weight(FontWeight::Bold)\n            ->searchable()\n            ->sortable(),\n    ]),\n    View::make('users.table.collapsible-row-content')\n        ->components([\n            TextColumn::make('email')\n                ->icon('heroicon-m-envelope'),\n        ])\n        ->collapsible(),\n]\n```\n\nNow, render the components in the Blade file:\n\n```\n<div class=\"px-4 py-3 bg-gray-100 rounded-lg\">\n    <x-filament-tables::columns.layout\n        :components=\"$getComponents()\"\n        :record=\"$getRecord()\"\n        :record-key=\"$recordKey\"\n    />\n</div>\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "The problem with traditional table layouts",
              "Allowing columns to stack on mobile",
              "Controlling column width using a grid",
              "Collapsible content",
              "Arranging records into a grid",
              "Embedding other components"
            ],
            "code_examples_count": 36,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "summaries": {
          "metadata": {
            "title": "Summaries",
            "url": "https://filamentphp.com/docs/3.x/tables/summaries",
            "section": "tables",
            "word_count": 1383,
            "character_count": 12231
          },
          "content": {
            "full_text": "\n# Summaries - Tables - Filament\n\nTables\n\n# Summaries\n\n## #Overview\n\nYou may render a “summary” section below your table content. This is great for displaying the results of calculations such as averages, sums, counts, and ranges of the data in your table.\n\nBy default, there will be a single summary line for the current page of data, and an additional summary line for the totals for all data if multiple pages are available. You may also add summaries for groups of records, see “Summarising groups of rows”.\n\n“Summarizer” objects can be added to any table column using the summarize() method:\n\n`summarize()````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make())\n```\n\nMultiple “summarizers” may be added to the same column:\n\n```\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->numeric()\n    ->summarize([\n        Average::make(),\n        Range::make(),\n    ])\n```\n\n> The first column in a table may not use summarizers. That column is used to render the heading and subheading/s of the summary section.\n\nThe first column in a table may not use summarizers. That column is used to render the heading and subheading/s of the summary section.\n\n## #Available summarizers\n\nFilament ships with four types of summarizer:\n\n- Average\n- Count\n- Range\n- Sum\n\nYou may also create your own custom summarizers to display data in whatever way you wish.\n\n## #Average\n\nAverage can be used to calculate the average of all values in the dataset:\n\n```\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make())\n```\n\nIn this example, all ratings in the table will be added together and divided by the number of ratings.\n\n## #Count\n\nCount can be used to find the total number of values in the dataset. Unless you just want to calculate the number of rows, you will probably want to scope the dataset as well:\n\n```\nuse Filament\\Tables\\Columns\\IconColumn;\nuse Filament\\Tables\\Columns\\Summarizers\\Count;\nuse Illuminate\\Database\\Query\\Builder;\n\nIconColumn::make('is_published')\n    ->boolean()\n    ->summarize(\n        Count::make()->query(fn (Builder $query) => $query->where('is_published', true)),\n    ),\n```\n\nIn this example, the table will calculate how many posts are published.\n\n### #Counting the occurrence of icons\n\nUsing a count on an icon column allows you to use the icons() method, which gives the user a visual representation of how many of each icon are in the table:\n\n`icons()````\nuse Filament\\Tables\\Columns\\IconColumn;\nuse Filament\\Tables\\Columns\\Summarizers\\Count;\nuse Illuminate\\Database\\Query\\Builder;\n\nIconColumn::make('is_published')\n    ->boolean()\n    ->summarize(Count::make()->icons()),\n```\n\n## #Range\n\nRange can be used to calculate the minimum and maximum value in the dataset:\n\n```\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Range::make())\n```\n\nIn this example, the minimum and maximum price in the table will be found.\n\n### #Date range\n\nYou may format the range as dates using the minimalDateTimeDifference() method:\n\n`minimalDateTimeDifference()````\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('created_at')\n    ->dateTime()\n    ->summarize(Range::make()->minimalDateTimeDifference())\n```\n\nThis method will present the minimal difference between the minimum and maximum date. For example:\n\n- If the minimum and maximum dates are different days, only the dates will be displayed.\n- If the minimum and maximum dates are on the same day at different times, both the date and time will be displayed.\n- If the minimum and maximum dates and times are identical, they will only appear once.\n\n### #Text range\n\nYou may format the range as text using the minimalTextualDifference() method:\n\n`minimalTextualDifference()````\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('sku')\n    ->summarize(Range::make()->minimalTextualDifference())\n```\n\nThis method will present the minimal difference between the minimum and maximum. For example:\n\n- If the minimum and maximum start with different letters, only the first letters will be displayed.\n- If the minimum and maximum start with the same letter, more of the text will be rendered until a difference is found.\n- If the minimum and maximum are identical, they will only appear once.\n\n### #Including null values in the range\n\nBy default, we will exclude null values from the range. If you would like to include them, you may use the excludeNull(false) method:\n\n`excludeNull(false)````\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('sku')\n    ->summarize(Range::make()->excludeNull(false))\n```\n\n## #Sum\n\nSum can be used to calculate the total of all values in the dataset:\n\n```\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Sum::make())\n```\n\nIn this example, all prices in the table will be added together.\n\n## #Setting a label\n\nYou may set a summarizer’s label using the label() method:\n\n`label()````\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Sum::make()->label('Total'))\n```\n\n## #Scoping the dataset\n\nYou may apply a database query scope to a summarizer’s dataset using the query() method:\n\n`query()````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Query\\Builder;\n\nTextColumn::make('rating')\n    ->summarize(\n        Average::make()->query(fn (Builder $query) => $query->where('is_published', true)),\n    ),\n```\n\nIn this example, now only rows where is_published is set to true will be used to calculate the average.\n\n`is_published``true`This feature is especially useful with the count summarizer, as it can count how many records in the dataset pass a test:\n\n```\nuse Filament\\Tables\\Columns\\IconColumn;\nuse Filament\\Tables\\Columns\\Summarizers\\Count;\nuse Illuminate\\Database\\Query\\Builder;\n\nIconColumn::make('is_published')\n    ->boolean()\n    ->summarize(\n        Count::make()->query(fn (Builder $query) => $query->where('is_published', true)),\n    ),\n```\n\nIn this example, the table will calculate how many posts are published.\n\n## #Formatting\n\n### #Number formatting\n\nThe numeric() method allows you to format an entry as a number:\n\n`numeric()````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make()->numeric())\n```\n\nIf you would like to customize the number of decimal places used to format the number with, you can use the decimalPlaces argument:\n\n`decimalPlaces````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make()->numeric(\n        decimalPlaces: 0,\n    ))\n```\n\nBy default, your app’s locale will be used to format the number suitably. If you would like to customize the locale used, you can pass it to the locale argument:\n\n`locale````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make()->numeric(\n        locale: 'nl',\n    ))\n```\n\nAlternatively, you can set the default locale used across your app using the Table::$defaultNumberLocale method in the boot() method of a service provider:\n\n`Table::$defaultNumberLocale``boot()````\nuse Filament\\Tables\\Table;\n\nTable::$defaultNumberLocale = 'nl';\n```\n\n### #Currency formatting\n\nThe money() method allows you to easily format monetary values, in any currency:\n\n`money()````\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Sum::make()->money('EUR'))\n```\n\nThere is also a divideBy argument for money() that allows you to divide the original value by a number before formatting it. This could be useful if your database stores the price in cents, for example:\n\n`divideBy``money()````\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Sum::make()->money('EUR', divideBy: 100))\n```\n\nBy default, your app’s locale will be used to format the money suitably. If you would like to customize the locale used, you can pass it to the locale argument:\n\n`locale````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Sum::make()->money('EUR', locale: 'nl'))\n```\n\nAlternatively, you can set the default locale used across your app using the Table::$defaultNumberLocale method in the boot() method of a service provider:\n\n`Table::$defaultNumberLocale``boot()````\nuse Filament\\Tables\\Table;\n\nTable::$defaultNumberLocale = 'nl';\n```\n\n### #Limiting text length\n\nYou may limit() the length of the summary’s value:\n\n`limit()````\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('sku')\n    ->summarize(Range::make()->limit(5))\n```\n\n### #Adding a prefix or suffix\n\nYou may add a prefix or suffix to the summary’s value:\n\n```\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Support\\HtmlString;\n\nTextColumn::make('volume')\n    ->summarize(Sum::make()\n        ->prefix('Total volume: ')\n        ->suffix(new HtmlString(' m&sup3;'))\n    )\n```\n\n## #Custom summaries\n\nYou may create a custom summary by returning the value from the using() method:\n\n`using()````\nuse Filament\\Tables\\Columns\\Summarizers\\Summarizer;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Query\\Builder;\n\nTextColumn::make('name')\n    ->summarize(Summarizer::make()\n        ->label('First last name')\n        ->using(fn (Builder $query): string => $query->min('last_name')))\n```\n\nThe callback has access to the database $query builder instance to perform calculations with. It should return the value to display in the table.\n\n`$query`## #Conditionally hiding the summary\n\nTo hide a summary, you may pass a boolean, or a function that returns a boolean, to the hidden() method. If you need it, you can access the Eloquent query builder instance for that summarizer via the $query argument of the function:\n\n`hidden()``$query````\nuse Filament\\Tables\\Columns\\Summarizers\\Summarizer;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nTextColumn::make('sku')\n    ->summarize(Summarizer::make()\n        ->hidden(fn (Builder $query): bool => ! $query->exists()))\n```\n\nAlternatively, you can use the visible() method to achieve the opposite effect:\n\n`visible()````\nuse Filament\\Tables\\Columns\\Summarizers\\Summarizer;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nTextColumn::make('sku')\n    ->summarize(Summarizer::make()\n        ->visible(fn (Builder $query): bool => $query->exists()))\n```\n\n## #Summarising groups of rows\n\nYou can use summaries with groups to display a summary of the records inside a group. This works automatically if you choose to add a summariser to a column in a grouped table.\n\n### #Hiding the grouped rows and showing the summary only\n\nYou may hide the rows inside groups and just show the summary of each group using the groupsOnly() method. This is beneficial in many reporting scenarios.\n\n`groupsOnly()````\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            TextColumn::make('views_count')\n                ->summarize(Sum::make()),\n            TextColumn::make('likes_count')\n                ->summarize(Sum::make()),\n        ])\n        ->defaultGroup('category')\n        ->groupsOnly();\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Summaries - Tables - Filament",
                "content": "Tables",
                "level": 1
              },
              {
                "title": "# Summaries",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "You may render a “summary” section below your table content. This is great for displaying the results of calculations such as averages, sums, counts, and ranges of the data in your table.\n\nBy default, there will be a single summary line for the current page of data, and an additional summary line for the totals for all data if multiple pages are available. You may also add summaries for groups of records, see “Summarising groups of rows”.\n\n“Summarizer” objects can be added to any table column using the summarize() method:\n\n`summarize()````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make())\n```\n\nMultiple “summarizers” may be added to the same column:\n\n```\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->numeric()\n    ->summarize([\n        Average::make(),\n        Range::make(),\n    ])\n```\n\n> The first column in a table may not use summarizers. That column is used to render the heading and subheading/s of the summary section.\n\nThe first column in a table may not use summarizers. That column is used to render the heading and subheading/s of the summary section.",
                "level": 3
              },
              {
                "title": "## #Available summarizers",
                "content": "Filament ships with four types of summarizer:\n\n- Average\n- Count\n- Range\n- Sum\n\nYou may also create your own custom summarizers to display data in whatever way you wish.",
                "level": 3
              },
              {
                "title": "## #Average",
                "content": "Average can be used to calculate the average of all values in the dataset:\n\n```\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make())\n```\n\nIn this example, all ratings in the table will be added together and divided by the number of ratings.",
                "level": 3
              },
              {
                "title": "## #Count",
                "content": "Count can be used to find the total number of values in the dataset. Unless you just want to calculate the number of rows, you will probably want to scope the dataset as well:\n\n```\nuse Filament\\Tables\\Columns\\IconColumn;\nuse Filament\\Tables\\Columns\\Summarizers\\Count;\nuse Illuminate\\Database\\Query\\Builder;\n\nIconColumn::make('is_published')\n    ->boolean()\n    ->summarize(\n        Count::make()->query(fn (Builder $query) => $query->where('is_published', true)),\n    ),\n```\n\nIn this example, the table will calculate how many posts are published.",
                "level": 3
              },
              {
                "title": "### #Counting the occurrence of icons",
                "content": "Using a count on an icon column allows you to use the icons() method, which gives the user a visual representation of how many of each icon are in the table:\n\n`icons()````\nuse Filament\\Tables\\Columns\\IconColumn;\nuse Filament\\Tables\\Columns\\Summarizers\\Count;\nuse Illuminate\\Database\\Query\\Builder;\n\nIconColumn::make('is_published')\n    ->boolean()\n    ->summarize(Count::make()->icons()),\n```",
                "level": 4
              },
              {
                "title": "## #Range",
                "content": "Range can be used to calculate the minimum and maximum value in the dataset:\n\n```\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Range::make())\n```\n\nIn this example, the minimum and maximum price in the table will be found.",
                "level": 3
              },
              {
                "title": "### #Date range",
                "content": "You may format the range as dates using the minimalDateTimeDifference() method:\n\n`minimalDateTimeDifference()````\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('created_at')\n    ->dateTime()\n    ->summarize(Range::make()->minimalDateTimeDifference())\n```\n\nThis method will present the minimal difference between the minimum and maximum date. For example:\n\n- If the minimum and maximum dates are different days, only the dates will be displayed.\n- If the minimum and maximum dates are on the same day at different times, both the date and time will be displayed.\n- If the minimum and maximum dates and times are identical, they will only appear once.",
                "level": 4
              },
              {
                "title": "### #Text range",
                "content": "You may format the range as text using the minimalTextualDifference() method:\n\n`minimalTextualDifference()````\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('sku')\n    ->summarize(Range::make()->minimalTextualDifference())\n```\n\nThis method will present the minimal difference between the minimum and maximum. For example:\n\n- If the minimum and maximum start with different letters, only the first letters will be displayed.\n- If the minimum and maximum start with the same letter, more of the text will be rendered until a difference is found.\n- If the minimum and maximum are identical, they will only appear once.",
                "level": 4
              },
              {
                "title": "### #Including null values in the range",
                "content": "By default, we will exclude null values from the range. If you would like to include them, you may use the excludeNull(false) method:\n\n`excludeNull(false)````\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('sku')\n    ->summarize(Range::make()->excludeNull(false))\n```",
                "level": 4
              },
              {
                "title": "## #Sum",
                "content": "Sum can be used to calculate the total of all values in the dataset:\n\n```\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Sum::make())\n```\n\nIn this example, all prices in the table will be added together.",
                "level": 3
              },
              {
                "title": "## #Setting a label",
                "content": "You may set a summarizer’s label using the label() method:\n\n`label()````\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Sum::make()->label('Total'))\n```",
                "level": 3
              },
              {
                "title": "## #Scoping the dataset",
                "content": "You may apply a database query scope to a summarizer’s dataset using the query() method:\n\n`query()````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Query\\Builder;\n\nTextColumn::make('rating')\n    ->summarize(\n        Average::make()->query(fn (Builder $query) => $query->where('is_published', true)),\n    ),\n```\n\nIn this example, now only rows where is_published is set to true will be used to calculate the average.\n\n`is_published``true`This feature is especially useful with the count summarizer, as it can count how many records in the dataset pass a test:\n\n```\nuse Filament\\Tables\\Columns\\IconColumn;\nuse Filament\\Tables\\Columns\\Summarizers\\Count;\nuse Illuminate\\Database\\Query\\Builder;\n\nIconColumn::make('is_published')\n    ->boolean()\n    ->summarize(\n        Count::make()->query(fn (Builder $query) => $query->where('is_published', true)),\n    ),\n```\n\nIn this example, the table will calculate how many posts are published.",
                "level": 3
              },
              {
                "title": "## #Formatting",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Number formatting",
                "content": "The numeric() method allows you to format an entry as a number:\n\n`numeric()````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make()->numeric())\n```\n\nIf you would like to customize the number of decimal places used to format the number with, you can use the decimalPlaces argument:\n\n`decimalPlaces````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make()->numeric(\n        decimalPlaces: 0,\n    ))\n```\n\nBy default, your app’s locale will be used to format the number suitably. If you would like to customize the locale used, you can pass it to the locale argument:\n\n`locale````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make()->numeric(\n        locale: 'nl',\n    ))\n```\n\nAlternatively, you can set the default locale used across your app using the Table::$defaultNumberLocale method in the boot() method of a service provider:\n\n`Table::$defaultNumberLocale``boot()````\nuse Filament\\Tables\\Table;\n\nTable::$defaultNumberLocale = 'nl';\n```",
                "level": 4
              },
              {
                "title": "### #Currency formatting",
                "content": "The money() method allows you to easily format monetary values, in any currency:\n\n`money()````\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Sum::make()->money('EUR'))\n```\n\nThere is also a divideBy argument for money() that allows you to divide the original value by a number before formatting it. This could be useful if your database stores the price in cents, for example:\n\n`divideBy``money()````\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Sum::make()->money('EUR', divideBy: 100))\n```\n\nBy default, your app’s locale will be used to format the money suitably. If you would like to customize the locale used, you can pass it to the locale argument:\n\n`locale````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('price')\n    ->summarize(Sum::make()->money('EUR', locale: 'nl'))\n```\n\nAlternatively, you can set the default locale used across your app using the Table::$defaultNumberLocale method in the boot() method of a service provider:\n\n`Table::$defaultNumberLocale``boot()````\nuse Filament\\Tables\\Table;\n\nTable::$defaultNumberLocale = 'nl';\n```",
                "level": 4
              },
              {
                "title": "### #Limiting text length",
                "content": "You may limit() the length of the summary’s value:\n\n`limit()````\nuse Filament\\Tables\\Columns\\Summarizers\\Range;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('sku')\n    ->summarize(Range::make()->limit(5))\n```",
                "level": 4
              },
              {
                "title": "### #Adding a prefix or suffix",
                "content": "You may add a prefix or suffix to the summary’s value:\n\n```\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Support\\HtmlString;\n\nTextColumn::make('volume')\n    ->summarize(Sum::make()\n        ->prefix('Total volume: ')\n        ->suffix(new HtmlString(' m&sup3;'))\n    )\n```",
                "level": 4
              },
              {
                "title": "## #Custom summaries",
                "content": "You may create a custom summary by returning the value from the using() method:\n\n`using()````\nuse Filament\\Tables\\Columns\\Summarizers\\Summarizer;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Query\\Builder;\n\nTextColumn::make('name')\n    ->summarize(Summarizer::make()\n        ->label('First last name')\n        ->using(fn (Builder $query): string => $query->min('last_name')))\n```\n\nThe callback has access to the database $query builder instance to perform calculations with. It should return the value to display in the table.\n\n`$query`## #Conditionally hiding the summary\n\nTo hide a summary, you may pass a boolean, or a function that returns a boolean, to the hidden() method. If you need it, you can access the Eloquent query builder instance for that summarizer via the $query argument of the function:\n\n`hidden()``$query````\nuse Filament\\Tables\\Columns\\Summarizers\\Summarizer;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nTextColumn::make('sku')\n    ->summarize(Summarizer::make()\n        ->hidden(fn (Builder $query): bool => ! $query->exists()))\n```\n\nAlternatively, you can use the visible() method to achieve the opposite effect:\n\n`visible()````\nuse Filament\\Tables\\Columns\\Summarizers\\Summarizer;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nTextColumn::make('sku')\n    ->summarize(Summarizer::make()\n        ->visible(fn (Builder $query): bool => $query->exists()))\n```",
                "level": 3
              },
              {
                "title": "## #Summarising groups of rows",
                "content": "You can use summaries with groups to display a summary of the records inside a group. This works automatically if you choose to add a summariser to a column in a grouped table.",
                "level": 3
              },
              {
                "title": "### #Hiding the grouped rows and showing the summary only",
                "content": "You may hide the rows inside groups and just show the summary of each group using the groupsOnly() method. This is beneficial in many reporting scenarios.\n\n`groupsOnly()````\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            TextColumn::make('views_count')\n                ->summarize(Sum::make()),\n            TextColumn::make('likes_count')\n                ->summarize(Sum::make()),\n        ])\n        ->defaultGroup('category')\n        ->groupsOnly();\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Available summarizers",
              "Average",
              "Count",
              "Counting the occurrence of icons",
              "Range",
              "Date range",
              "Text range",
              "Including null values in the range",
              "Setting a label"
            ],
            "code_examples_count": 54,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "grouping": {
          "metadata": {
            "title": "Grouping",
            "url": "https://filamentphp.com/docs/3.x/tables/grouping",
            "section": "tables",
            "word_count": 1143,
            "character_count": 10034
          },
          "content": {
            "full_text": "\n# Grouping rows - Tables - Filament\n\nTables\n\n# Grouping rows\n\n## #Overview\n\nYou may allow users to group table rows together using a common attribute. This is useful for displaying lots of data in a more organized way.\n\nGroups can be set up using the name of the attribute to group by (e.g. 'status'), or a Group object which allows you to customize the behavior of that grouping (e.g. Group::make('status')->collapsible()).\n\n`'status'``Group``Group::make('status')->collapsible()`## #Grouping rows by default\n\nYou may want to always group posts by a specific attribute. To do this, pass the group to the defaultGroup() method:\n\n`defaultGroup()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->defaultGroup('status');\n}\n```\n\n## #Allowing users to choose between groupings\n\nYou may also allow users to pick between different groupings, by passing them in an array to the groups() method:\n\n`groups()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            'status',\n            'category',\n        ]);\n}\n```\n\nYou can use both groups() and defaultGroup() together to allow users to choose between different groupings, but have a default grouping set:\n\n`groups()``defaultGroup()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            'status',\n            'category',\n        ])\n        ->defaultGroup('status');\n}\n```\n\n## #Grouping by a relationship attribute\n\nYou can also group by a relationship attribute using dot-syntax. For example, if you have an author relationship which has a name attribute, you can use author.name as the name of the attribute:\n\n`author``name``author.name````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            'author.name',\n        ]);\n}\n```\n\n## #Setting a grouping label\n\nBy default, the label of the grouping will be generated based on the attribute. You may customize it with a Group object, using the label() method:\n\n`Group``label()````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('author.name')\n                ->label('Author name'),\n        ]);\n}\n```\n\n## #Setting a group title\n\nBy default, the title of a group will be the value of the attribute. You may customize it by returning a new title from the getTitleFromRecordUsing() method of a Group object:\n\n`getTitleFromRecordUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->getTitleFromRecordUsing(fn (Post $record): string => ucfirst($record->status->getLabel())),\n        ]);\n}\n```\n\n### #Disabling the title label prefix\n\nBy default, the title is prefixed with the label of the group. To disable this prefix, utilize the titlePrefixedWithLabel(false) method:\n\n`titlePrefixedWithLabel(false)````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->titlePrefixedWithLabel(false),\n        ]);\n}\n```\n\n## #Setting a group description\n\nYou may also set a description for a group, which will be displayed underneath the group title. To do this, use the getDescriptionFromRecordUsing() method on a Group object:\n\n`getDescriptionFromRecordUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->getDescriptionFromRecordUsing(fn (Post $record): string => $record->status->getDescription()),\n        ]);\n}\n```\n\n## #Setting a group key\n\nBy default, the key of a group will be the value of the attribute. It is used internally as a raw identifier of that group, instead of the title. You may customize it by returning a new key from the getKeyFromRecordUsing() method of a Group object:\n\n`getKeyFromRecordUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->getKeyFromRecordUsing(fn (Post $record): string => $record->status->value),\n        ]);\n}\n```\n\n## #Date groups\n\nWhen using a date-time column as a group, you may want to group by the date only, and ignore the time. To do this, use the date() method on a Group object:\n\n`date()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('created_at')\n                ->date(),\n        ]);\n}\n```\n\n## #Collapsible groups\n\nYou can allow rows inside a group to be collapsed underneath their group title. To enable this, use a Group object with the collapsible() method:\n\n`Group``collapsible()````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('author.name')\n                ->collapsible(),\n        ]);\n}\n```\n\n## #Summarising groups\n\nYou can use summaries with groups to display a summary of the records inside a group. This works automatically if you choose to add a summariser to a column in a grouped table.\n\n### #Hiding the grouped rows and showing the summary only\n\nYou may hide the rows inside groups and just show the summary of each group using the groupsOnly() method. This is very useful in many reporting scenarios.\n\n`groupsOnly()````\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            TextColumn::make('views_count')\n                ->summarize(Sum::make()),\n            TextColumn::make('likes_count')\n                ->summarize(Sum::make()),\n        ])\n        ->defaultGroup('category')\n        ->groupsOnly();\n}\n```\n\n## #Customizing the Eloquent query ordering behavior\n\nSome features require the table to be able to order an Eloquent query according to a group. You can customize how we do this using the orderQueryUsing() method on a Group object:\n\n`orderQueryUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->orderQueryUsing(fn (Builder $query, string $direction) => $query->orderBy('status', $direction)),\n        ]);\n}\n```\n\n## #Customizing the Eloquent query scoping behavior\n\nSome features require the table to be able to scope an Eloquent query according to a group. You can customize how we do this using the scopeQueryByKeyUsing() method on a Group object:\n\n`scopeQueryByKeyUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->scopeQueryByKeyUsing(fn (Builder $query, string $key) => $query->where('status', $key)),\n        ]);\n}\n```\n\n## #Customizing the Eloquent query grouping behavior\n\nSome features require the table to be able to group an Eloquent query according to a group. You can customize how we do this using the groupQueryUsing() method on a Group object:\n\n`groupQueryUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->groupQueryUsing(fn (Builder $query) => $query->groupBy('status')),\n        ]);\n}\n```\n\n## #Customizing the groups dropdown trigger action\n\nTo customize the groups dropdown trigger button, you may use the groupRecordsTriggerAction() method, passing a closure that returns an action. All methods that are available to customize action trigger buttons can be used:\n\n`groupRecordsTriggerAction()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            // ...\n        ])\n        ->groupRecordsTriggerAction(\n            fn (Action $action) => $action\n                ->button()\n                ->label('Group records'),\n        );\n}\n```\n\n## #Using the grouping settings dropdown on desktop\n\nBy default, the grouping settings dropdown will only be shown on mobile devices. On desktop devices, the grouping settings are in the header of the table. You can enable the dropdown on desktop devices too by using the groupingSettingsInDropdownOnDesktop() method:\n\n`groupingSettingsInDropdownOnDesktop()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            // ...\n        ])\n        ->groupingSettingsInDropdownOnDesktop();\n}\n```\n\n## #Hiding the grouping settings\n\nYou can hide the grouping settings interface using the groupingSettingsHidden() method:\n\n`groupingSettingsHidden()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n\t\t->defaultGroup('status')\n        ->groupingSettingsHidden();\n}\n```\n\n### #Hiding the grouping direction setting only\n\nYou can hide the grouping direction select interface using the groupingDirectionSettingHidden() method:\n\n`groupingDirectionSettingHidden()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n\t\t->defaultGroup('status')\n        ->groupingDirectionSettingHidden();\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Grouping rows - Tables - Filament",
                "content": "Tables",
                "level": 1
              },
              {
                "title": "# Grouping rows",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "You may allow users to group table rows together using a common attribute. This is useful for displaying lots of data in a more organized way.\n\nGroups can be set up using the name of the attribute to group by (e.g. 'status'), or a Group object which allows you to customize the behavior of that grouping (e.g. Group::make('status')->collapsible()).\n\n`'status'``Group``Group::make('status')->collapsible()`## #Grouping rows by default\n\nYou may want to always group posts by a specific attribute. To do this, pass the group to the defaultGroup() method:\n\n`defaultGroup()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->defaultGroup('status');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Allowing users to choose between groupings",
                "content": "You may also allow users to pick between different groupings, by passing them in an array to the groups() method:\n\n`groups()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            'status',\n            'category',\n        ]);\n}\n```\n\nYou can use both groups() and defaultGroup() together to allow users to choose between different groupings, but have a default grouping set:\n\n`groups()``defaultGroup()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            'status',\n            'category',\n        ])\n        ->defaultGroup('status');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Grouping by a relationship attribute",
                "content": "You can also group by a relationship attribute using dot-syntax. For example, if you have an author relationship which has a name attribute, you can use author.name as the name of the attribute:\n\n`author``name``author.name````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            'author.name',\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Setting a grouping label",
                "content": "By default, the label of the grouping will be generated based on the attribute. You may customize it with a Group object, using the label() method:\n\n`Group``label()````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('author.name')\n                ->label('Author name'),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Setting a group title",
                "content": "By default, the title of a group will be the value of the attribute. You may customize it by returning a new title from the getTitleFromRecordUsing() method of a Group object:\n\n`getTitleFromRecordUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->getTitleFromRecordUsing(fn (Post $record): string => ucfirst($record->status->getLabel())),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "### #Disabling the title label prefix",
                "content": "By default, the title is prefixed with the label of the group. To disable this prefix, utilize the titlePrefixedWithLabel(false) method:\n\n`titlePrefixedWithLabel(false)````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->titlePrefixedWithLabel(false),\n        ]);\n}\n```",
                "level": 4
              },
              {
                "title": "## #Setting a group description",
                "content": "You may also set a description for a group, which will be displayed underneath the group title. To do this, use the getDescriptionFromRecordUsing() method on a Group object:\n\n`getDescriptionFromRecordUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->getDescriptionFromRecordUsing(fn (Post $record): string => $record->status->getDescription()),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Setting a group key",
                "content": "By default, the key of a group will be the value of the attribute. It is used internally as a raw identifier of that group, instead of the title. You may customize it by returning a new key from the getKeyFromRecordUsing() method of a Group object:\n\n`getKeyFromRecordUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->getKeyFromRecordUsing(fn (Post $record): string => $record->status->value),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Date groups",
                "content": "When using a date-time column as a group, you may want to group by the date only, and ignore the time. To do this, use the date() method on a Group object:\n\n`date()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('created_at')\n                ->date(),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Collapsible groups",
                "content": "You can allow rows inside a group to be collapsed underneath their group title. To enable this, use a Group object with the collapsible() method:\n\n`Group``collapsible()````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('author.name')\n                ->collapsible(),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Summarising groups",
                "content": "You can use summaries with groups to display a summary of the records inside a group. This works automatically if you choose to add a summariser to a column in a grouped table.",
                "level": 3
              },
              {
                "title": "### #Hiding the grouped rows and showing the summary only",
                "content": "You may hide the rows inside groups and just show the summary of each group using the groupsOnly() method. This is very useful in many reporting scenarios.\n\n`groupsOnly()````\nuse Filament\\Tables\\Columns\\Summarizers\\Sum;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->columns([\n            TextColumn::make('views_count')\n                ->summarize(Sum::make()),\n            TextColumn::make('likes_count')\n                ->summarize(Sum::make()),\n        ])\n        ->defaultGroup('category')\n        ->groupsOnly();\n}\n```",
                "level": 4
              },
              {
                "title": "## #Customizing the Eloquent query ordering behavior",
                "content": "Some features require the table to be able to order an Eloquent query according to a group. You can customize how we do this using the orderQueryUsing() method on a Group object:\n\n`orderQueryUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->orderQueryUsing(fn (Builder $query, string $direction) => $query->orderBy('status', $direction)),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the Eloquent query scoping behavior",
                "content": "Some features require the table to be able to scope an Eloquent query according to a group. You can customize how we do this using the scopeQueryByKeyUsing() method on a Group object:\n\n`scopeQueryByKeyUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->scopeQueryByKeyUsing(fn (Builder $query, string $key) => $query->where('status', $key)),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the Eloquent query grouping behavior",
                "content": "Some features require the table to be able to group an Eloquent query according to a group. You can customize how we do this using the groupQueryUsing() method on a Group object:\n\n`groupQueryUsing()``Group````\nuse Filament\\Tables\\Grouping\\Group;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            Group::make('status')\n                ->groupQueryUsing(fn (Builder $query) => $query->groupBy('status')),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the groups dropdown trigger action",
                "content": "To customize the groups dropdown trigger button, you may use the groupRecordsTriggerAction() method, passing a closure that returns an action. All methods that are available to customize action trigger buttons can be used:\n\n`groupRecordsTriggerAction()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            // ...\n        ])\n        ->groupRecordsTriggerAction(\n            fn (Action $action) => $action\n                ->button()\n                ->label('Group records'),\n        );\n}\n```",
                "level": 3
              },
              {
                "title": "## #Using the grouping settings dropdown on desktop",
                "content": "By default, the grouping settings dropdown will only be shown on mobile devices. On desktop devices, the grouping settings are in the header of the table. You can enable the dropdown on desktop devices too by using the groupingSettingsInDropdownOnDesktop() method:\n\n`groupingSettingsInDropdownOnDesktop()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->groups([\n            // ...\n        ])\n        ->groupingSettingsInDropdownOnDesktop();\n}\n```",
                "level": 3
              },
              {
                "title": "## #Hiding the grouping settings",
                "content": "You can hide the grouping settings interface using the groupingSettingsHidden() method:\n\n`groupingSettingsHidden()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n\t\t->defaultGroup('status')\n        ->groupingSettingsHidden();\n}\n```",
                "level": 3
              },
              {
                "title": "### #Hiding the grouping direction setting only",
                "content": "You can hide the grouping direction select interface using the groupingDirectionSettingHidden() method:\n\n`groupingDirectionSettingHidden()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n\t\t->defaultGroup('status')\n        ->groupingDirectionSettingHidden();\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Allowing users to choose between groupings",
              "Grouping by a relationship attribute",
              "Setting a grouping label",
              "Setting a group title",
              "Disabling the title label prefix",
              "Setting a group description",
              "Setting a group key",
              "Date groups",
              "Collapsible groups"
            ],
            "code_examples_count": 38,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "empty-state": {
          "metadata": {
            "title": "Empty State",
            "url": "https://filamentphp.com/docs/3.x/tables/empty-state",
            "section": "tables",
            "word_count": 233,
            "character_count": 2012
          },
          "content": {
            "full_text": "\n# Empty state - Tables - Filament\n\nTables\n\n# Empty state\n\n## #Overview\n\nThe table’s “empty state” is rendered when there are no rows in the table.\n\n## #Setting the empty state heading\n\nTo customize the heading of the empty state, use the emptyStateHeading() method:\n\n`emptyStateHeading()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->emptyStateHeading('No posts yet');\n}\n```\n\n## #Setting the empty state description\n\nTo customize the description of the empty state, use the emptyStateDescription() method:\n\n`emptyStateDescription()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->emptyStateDescription('Once you write your first post, it will appear here.');\n}\n```\n\n## #Setting the empty state icon\n\nTo customize the icon of the empty state, use the emptyStateIcon() method:\n\n`emptyStateIcon()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->emptyStateIcon('heroicon-o-bookmark');\n}\n```\n\n## #Adding empty state actions\n\nYou can add Actions to the empty state to prompt users to take action. Pass these to the emptyStateActions() method:\n\n`emptyStateActions()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->emptyStateActions([\n            Action::make('create')\n                ->label('Create post')\n                ->url(route('posts.create'))\n                ->icon('heroicon-m-plus')\n                ->button(),\n        ]);\n}\n```\n\n## #Using a custom empty state view\n\nYou may use a completely custom empty state view by passing it to the emptyState() method:\n\n`emptyState()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->emptyState(view('tables.posts.empty-state'));\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Empty state - Tables - Filament",
                "content": "Tables",
                "level": 1
              },
              {
                "title": "# Empty state",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "The table’s “empty state” is rendered when there are no rows in the table.",
                "level": 3
              },
              {
                "title": "## #Setting the empty state heading",
                "content": "To customize the heading of the empty state, use the emptyStateHeading() method:\n\n`emptyStateHeading()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->emptyStateHeading('No posts yet');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Setting the empty state description",
                "content": "To customize the description of the empty state, use the emptyStateDescription() method:\n\n`emptyStateDescription()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->emptyStateDescription('Once you write your first post, it will appear here.');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Setting the empty state icon",
                "content": "To customize the icon of the empty state, use the emptyStateIcon() method:\n\n`emptyStateIcon()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->emptyStateIcon('heroicon-o-bookmark');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Adding empty state actions",
                "content": "You can add Actions to the empty state to prompt users to take action. Pass these to the emptyStateActions() method:\n\n`emptyStateActions()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->emptyStateActions([\n            Action::make('create')\n                ->label('Create post')\n                ->url(route('posts.create'))\n                ->icon('heroicon-m-plus')\n                ->button(),\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Using a custom empty state view",
                "content": "You may use a completely custom empty state view by passing it to the emptyState() method:\n\n`emptyState()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->emptyState(view('tables.posts.empty-state'));\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Setting the empty state heading",
              "Setting the empty state description",
              "Setting the empty state icon",
              "Adding empty state actions",
              "Using a custom empty state view"
            ],
            "code_examples_count": 10,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "advanced": {
          "metadata": {
            "title": "Advanced",
            "url": "https://filamentphp.com/docs/3.x/tables/advanced",
            "section": "tables",
            "word_count": 1516,
            "character_count": 12452
          },
          "content": {
            "full_text": "\n# Advanced - Tables - Filament\n\nTables\n\n# Advanced\n\n## #Pagination\n\n### #Disabling pagination\n\nBy default, tables will be paginated. To disable this, you should use the $table->paginated(false) method:\n\n`$table->paginated(false)````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->paginated(false);\n}\n```\n\n### #Customizing the pagination options\n\nYou may customize the options for the paginated records per page select by passing them to the paginated() method:\n\n`paginated()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->paginated([10, 25, 50, 100, 'all']);\n}\n```\n\n### #Customizing the default pagination page option\n\nTo customize the default number of records shown use the defaultPaginationPageOption() method:\n\n`defaultPaginationPageOption()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->defaultPaginationPageOption(25);\n}\n```\n\n### #Preventing query string conflicts with the pagination page\n\nBy default, Livewire stores the pagination state in a page parameter of the URL query string. If you have multiple tables on the same page, this will mean that the pagination state of one table may be overwritten by the state of another table.\n\n`page`To fix this, you may define a $table->queryStringIdentifier(), to return a unique query string identifier for that table:\n\n`$table->queryStringIdentifier()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->queryStringIdentifier('users');\n}\n```\n\n### #Displaying links to the first and the last pagination page\n\nTo add “extreme” links to the first and the last page using the extremePaginationLinks() method:\n\n`extremePaginationLinks()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->extremePaginationLinks();\n}\n```\n\n### #Using simple pagination\n\nYou may use simple pagination by overriding paginateTableQuery() method.\n\n`paginateTableQuery()`First, locate your Livewire component. If you’re using a resource from the Panel Builder and you want to add simple pagination to the List page, you’ll want to open the Pages/List.php file in the resource, not the resource class itself.\n\n`Pages/List.php````\nuse Illuminate\\Contracts\\Pagination\\Paginator;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nprotected function paginateTableQuery(Builder $query): Paginator\n{\n    return $query->simplePaginate(($this->getTableRecordsPerPage() === 'all') ? $query->count() : $this->getTableRecordsPerPage());\n}\n```\n\n### #Using cursor pagination\n\nYou may use cursor pagination by overriding paginateTableQuery() method.\n\n`paginateTableQuery()`First, locate your Livewire component. If you’re using a resource from the Panel Builder and you want to add simple pagination to the List page, you’ll want to open the Pages/List.php file in the resource, not the resource class itself.\n\n`Pages/List.php````\nuse Illuminate\\Contracts\\Pagination\\CursorPaginator;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nprotected function paginateTableQuery(Builder $query): CursorPaginator\n{\n    return $query->cursorPaginate(($this->getTableRecordsPerPage() === 'all') ? $query->count() : $this->getTableRecordsPerPage());\n}\n```\n\n## #Record URLs (clickable rows)\n\nYou may allow table rows to be completely clickable by using the $table->recordUrl() method:\n\n`$table->recordUrl()````\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Model;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->recordUrl(\n            fn (Model $record): string => route('posts.edit', ['record' => $record]),\n        );\n}\n```\n\nIn this example, clicking on each post will take you to the posts.edit route.\n\n`posts.edit`You may also open the URL in a new tab:\n\n```\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->openRecordUrlInNewTab();\n}\n```\n\nIf you’d like to override the URL for a specific column, or instead run an action when a column is clicked, see the columns documentation.\n\n## #Reordering records\n\nTo allow the user to reorder records using drag and drop in your table, you can use the $table->reorderable() method:\n\n`$table->reorderable()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->reorderable('sort');\n}\n```\n\nIf you’re using mass assignment protection on your model, you will also need to add the sort attribute to the $fillable array there.\n\n`sort``$fillable`When making the table reorderable, a new button will be available on the table to toggle reordering.\n\nThe reorderable() method accepts the name of a column to store the record order in. If you use something like spatie/eloquent-sortable with an order column such as order_column, you may use this instead:\n\n`reorderable()``spatie/eloquent-sortable``order_column````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->reorderable('order_column');\n}\n```\n\nThe reorderable() method also accepts a boolean condition as its second parameter, allowing you to conditionally enable reordering:\n\n`reorderable()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->reorderable('sort', auth()->user()->isAdmin());\n}\n```\n\n### #Enabling pagination while reordering\n\nPagination will be disabled in reorder mode to allow you to move records between pages. It is generally bad UX to re-enable pagination while reordering, but if you are sure then you can use $table->paginatedWhileReordering():\n\n`$table->paginatedWhileReordering()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->paginatedWhileReordering();\n}\n```\n\n### #Customizing the reordering trigger action\n\nTo customize the reordering trigger button, you may use the reorderRecordsTriggerAction() method, passing a closure that returns an action. All methods that are available to customize action trigger buttons can be used:\n\n`reorderRecordsTriggerAction()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->reorderRecordsTriggerAction(\n            fn (Action $action, bool $isReordering) => $action\n                ->button()\n                ->label($isReordering ? 'Disable reordering' : 'Enable reordering'),\n        );\n}\n```\n\n## #Customizing the table header\n\nYou can add a heading to a table using the $table->heading() method:\n\n`$table->heading()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->heading('Clients')\n        ->columns([\n            // ...\n        ]);\n```\n\nYou can also add a description below the heading using the $table->description() method:\n\n`$table->description()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->heading('Clients')\n        ->description('Manage your clients here.')\n        ->columns([\n            // ...\n        ]);\n```\n\nYou can pass a view to the $table->header() method to customize the entire header:\n\n`$table->header()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->header(view('tables.header', [\n            'heading' => 'Clients',\n        ]))\n        ->columns([\n            // ...\n        ]);\n```\n\n## #Polling table content\n\nYou may poll table content so that it refreshes at a set interval, using the $table->poll() method:\n\n`$table->poll()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->poll('10s');\n}\n```\n\n## #Deferring loading\n\nTables with lots of data might take a while to load, in which case you can load the table data asynchronously using the deferLoading() method:\n\n`deferLoading()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->deferLoading();\n}\n```\n\n## #Searching records with Laravel Scout\n\nWhile Filament doesn’t provide a direct integration with Laravel Scout, you may override methods to integrate it.\n\nUse a whereIn() clause to filter the query for Scout results:\n\n`whereIn()````\nuse App\\Models\\Post;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nprotected function applySearchToTableQuery(Builder $query): Builder\n{\n    $this->applyColumnSearchesToTableQuery($query);\n    \n    if (filled($search = $this->getTableSearch())) {\n        $query->whereIn('id', Post::search($search)->keys());\n    }\n\n    return $query;\n}\n```\n\nScout uses this whereIn() method to retrieve results internally, so there is no performance penalty for using it.\n\n`whereIn()`The applyColumnSearchesToTableQuery() method ensures that searching individual columns will still work. You can replace that method with your own implementation if you want to use Scout for those search inputs as well.\n\n`applyColumnSearchesToTableQuery()`For the global search input to show, at least one column in the table needs to be searchable(). Alternatively, if you are using Scout to control which columns are searchable already, you can simply pass searchable() to the entire table instead:\n\n`searchable()``searchable()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->searchable();\n}\n```\n\n## #Query string\n\nLivewire ships with a feature to store data in the URL’s query string, to access across requests.\n\nWith Filament, this allows you to store your table’s filters, sort, search and pagination state in the URL.\n\nTo store the filters, sorting, and search state of your table in the query string:\n\n```\nuse Livewire\\Attributes\\Url;\n\n#[Url]\npublic bool $isTableReordering = false;\n\n/**\n * @var array<string, mixed> | null\n */\n#[Url]\npublic ?array $tableFilters = null;\n\n#[Url]\npublic ?string $tableGrouping = null;\n\n#[Url]\npublic ?string $tableGroupingDirection = null;\n\n/**\n * @var ?string\n */\n#[Url]\npublic $tableSearch = '';\n\n#[Url]\npublic ?string $tableSortColumn = null;\n\n#[Url]\npublic ?string $tableSortDirection = null;\n```\n\n## #Styling table rows\n\n### #Striped table rows\n\nTo enable striped table rows, you can use the striped() method:\n\n`striped()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->striped();\n}\n```\n\n### #Custom row classes\n\nYou may want to conditionally style rows based on the record data. This can be achieved by specifying a string or array of CSS classes to be applied to the row using the $table->recordClasses() method:\n\n`$table->recordClasses()````\nuse Closure;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Model;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->recordClasses(fn (Model $record) => match ($record->status) {\n            'draft' => 'opacity-30',\n            'reviewing' => 'border-s-2 border-orange-600 dark:border-orange-300',\n            'published' => 'border-s-2 border-green-600 dark:border-green-300',\n            default => null,\n        });\n}\n```\n\nThese classes are not automatically compiled by Tailwind CSS. If you want to apply Tailwind CSS classes that are not already used in Blade files, you should update your content configuration in tailwind.config.js to also scan for classes inside your directory: './app/Filament/**/*.php'\n\n`content``tailwind.config.js``'./app/Filament/**/*.php'`## #Resetting the table\n\nIf you make changes to the table definition during a Livewire request, for example, when consuming a public property in the table() method, you may need to reset the table to ensure that the changes are applied. To do this, you can call the resetTable() method on the Livewire component:\n\n`table()``resetTable()````\n$this->resetTable();\n```\n\n## #Global settings\n\nTo customize the default configuration that is used for all tables, you can call the static configureUsing() method from the boot() method of a service provider. The function will be run for each table that gets created:\n\n`configureUsing()``boot()````\nuse Filament\\Tables\\Enums\\FiltersLayout;\nuse Filament\\Tables\\Table;\n\nTable::configureUsing(function (Table $table): void {\n    $table\n        ->filtersLayout(FiltersLayout::AboveContentCollapsible)\n        ->paginationPageOptions([10, 25, 50]);\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Advanced - Tables - Filament",
                "content": "Tables",
                "level": 1
              },
              {
                "title": "# Advanced",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Pagination",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Disabling pagination",
                "content": "By default, tables will be paginated. To disable this, you should use the $table->paginated(false) method:\n\n`$table->paginated(false)````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->paginated(false);\n}\n```",
                "level": 4
              },
              {
                "title": "### #Customizing the pagination options",
                "content": "You may customize the options for the paginated records per page select by passing them to the paginated() method:\n\n`paginated()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->paginated([10, 25, 50, 100, 'all']);\n}\n```",
                "level": 4
              },
              {
                "title": "### #Customizing the default pagination page option",
                "content": "To customize the default number of records shown use the defaultPaginationPageOption() method:\n\n`defaultPaginationPageOption()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->defaultPaginationPageOption(25);\n}\n```",
                "level": 4
              },
              {
                "title": "### #Preventing query string conflicts with the pagination page",
                "content": "By default, Livewire stores the pagination state in a page parameter of the URL query string. If you have multiple tables on the same page, this will mean that the pagination state of one table may be overwritten by the state of another table.\n\n`page`To fix this, you may define a $table->queryStringIdentifier(), to return a unique query string identifier for that table:\n\n`$table->queryStringIdentifier()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->queryStringIdentifier('users');\n}\n```",
                "level": 4
              },
              {
                "title": "### #Displaying links to the first and the last pagination page",
                "content": "To add “extreme” links to the first and the last page using the extremePaginationLinks() method:\n\n`extremePaginationLinks()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->extremePaginationLinks();\n}\n```",
                "level": 4
              },
              {
                "title": "### #Using simple pagination",
                "content": "You may use simple pagination by overriding paginateTableQuery() method.\n\n`paginateTableQuery()`First, locate your Livewire component. If you’re using a resource from the Panel Builder and you want to add simple pagination to the List page, you’ll want to open the Pages/List.php file in the resource, not the resource class itself.\n\n`Pages/List.php````\nuse Illuminate\\Contracts\\Pagination\\Paginator;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nprotected function paginateTableQuery(Builder $query): Paginator\n{\n    return $query->simplePaginate(($this->getTableRecordsPerPage() === 'all') ? $query->count() : $this->getTableRecordsPerPage());\n}\n```",
                "level": 4
              },
              {
                "title": "### #Using cursor pagination",
                "content": "You may use cursor pagination by overriding paginateTableQuery() method.\n\n`paginateTableQuery()`First, locate your Livewire component. If you’re using a resource from the Panel Builder and you want to add simple pagination to the List page, you’ll want to open the Pages/List.php file in the resource, not the resource class itself.\n\n`Pages/List.php````\nuse Illuminate\\Contracts\\Pagination\\CursorPaginator;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nprotected function paginateTableQuery(Builder $query): CursorPaginator\n{\n    return $query->cursorPaginate(($this->getTableRecordsPerPage() === 'all') ? $query->count() : $this->getTableRecordsPerPage());\n}\n```",
                "level": 4
              },
              {
                "title": "## #Record URLs (clickable rows)",
                "content": "You may allow table rows to be completely clickable by using the $table->recordUrl() method:\n\n`$table->recordUrl()````\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Model;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->recordUrl(\n            fn (Model $record): string => route('posts.edit', ['record' => $record]),\n        );\n}\n```\n\nIn this example, clicking on each post will take you to the posts.edit route.\n\n`posts.edit`You may also open the URL in a new tab:\n\n```\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->openRecordUrlInNewTab();\n}\n```\n\nIf you’d like to override the URL for a specific column, or instead run an action when a column is clicked, see the columns documentation.",
                "level": 3
              },
              {
                "title": "## #Reordering records",
                "content": "To allow the user to reorder records using drag and drop in your table, you can use the $table->reorderable() method:\n\n`$table->reorderable()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->reorderable('sort');\n}\n```\n\nIf you’re using mass assignment protection on your model, you will also need to add the sort attribute to the $fillable array there.\n\n`sort``$fillable`When making the table reorderable, a new button will be available on the table to toggle reordering.\n\nThe reorderable() method accepts the name of a column to store the record order in. If you use something like spatie/eloquent-sortable with an order column such as order_column, you may use this instead:\n\n`reorderable()``spatie/eloquent-sortable``order_column````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->reorderable('order_column');\n}\n```\n\nThe reorderable() method also accepts a boolean condition as its second parameter, allowing you to conditionally enable reordering:\n\n`reorderable()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->reorderable('sort', auth()->user()->isAdmin());\n}\n```",
                "level": 3
              },
              {
                "title": "### #Enabling pagination while reordering",
                "content": "Pagination will be disabled in reorder mode to allow you to move records between pages. It is generally bad UX to re-enable pagination while reordering, but if you are sure then you can use $table->paginatedWhileReordering():\n\n`$table->paginatedWhileReordering()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->paginatedWhileReordering();\n}\n```",
                "level": 4
              },
              {
                "title": "### #Customizing the reordering trigger action",
                "content": "To customize the reordering trigger button, you may use the reorderRecordsTriggerAction() method, passing a closure that returns an action. All methods that are available to customize action trigger buttons can be used:\n\n`reorderRecordsTriggerAction()````\nuse Filament\\Tables\\Actions\\Action;\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->reorderRecordsTriggerAction(\n            fn (Action $action, bool $isReordering) => $action\n                ->button()\n                ->label($isReordering ? 'Disable reordering' : 'Enable reordering'),\n        );\n}\n```",
                "level": 4
              },
              {
                "title": "## #Customizing the table header",
                "content": "You can add a heading to a table using the $table->heading() method:\n\n`$table->heading()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->heading('Clients')\n        ->columns([\n            // ...\n        ]);\n```\n\nYou can also add a description below the heading using the $table->description() method:\n\n`$table->description()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->heading('Clients')\n        ->description('Manage your clients here.')\n        ->columns([\n            // ...\n        ]);\n```\n\nYou can pass a view to the $table->header() method to customize the entire header:\n\n`$table->header()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->header(view('tables.header', [\n            'heading' => 'Clients',\n        ]))\n        ->columns([\n            // ...\n        ]);\n```",
                "level": 3
              },
              {
                "title": "## #Polling table content",
                "content": "You may poll table content so that it refreshes at a set interval, using the $table->poll() method:\n\n`$table->poll()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->poll('10s');\n}\n```",
                "level": 3
              },
              {
                "title": "## #Deferring loading",
                "content": "Tables with lots of data might take a while to load, in which case you can load the table data asynchronously using the deferLoading() method:\n\n`deferLoading()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->deferLoading();\n}\n```",
                "level": 3
              },
              {
                "title": "## #Searching records with Laravel Scout",
                "content": "While Filament doesn’t provide a direct integration with Laravel Scout, you may override methods to integrate it.\n\nUse a whereIn() clause to filter the query for Scout results:\n\n`whereIn()````\nuse App\\Models\\Post;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nprotected function applySearchToTableQuery(Builder $query): Builder\n{\n    $this->applyColumnSearchesToTableQuery($query);\n    \n    if (filled($search = $this->getTableSearch())) {\n        $query->whereIn('id', Post::search($search)->keys());\n    }\n\n    return $query;\n}\n```\n\nScout uses this whereIn() method to retrieve results internally, so there is no performance penalty for using it.\n\n`whereIn()`The applyColumnSearchesToTableQuery() method ensures that searching individual columns will still work. You can replace that method with your own implementation if you want to use Scout for those search inputs as well.\n\n`applyColumnSearchesToTableQuery()`For the global search input to show, at least one column in the table needs to be searchable(). Alternatively, if you are using Scout to control which columns are searchable already, you can simply pass searchable() to the entire table instead:\n\n`searchable()``searchable()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->searchable();\n}\n```",
                "level": 3
              },
              {
                "title": "## #Query string",
                "content": "Livewire ships with a feature to store data in the URL’s query string, to access across requests.\n\nWith Filament, this allows you to store your table’s filters, sort, search and pagination state in the URL.\n\nTo store the filters, sorting, and search state of your table in the query string:\n\n```\nuse Livewire\\Attributes\\Url;\n\n#[Url]\npublic bool $isTableReordering = false;\n\n/**\n * @var array<string, mixed> | null\n */\n#[Url]\npublic ?array $tableFilters = null;\n\n#[Url]\npublic ?string $tableGrouping = null;\n\n#[Url]\npublic ?string $tableGroupingDirection = null;\n\n/**\n * @var ?string\n */\n#[Url]\npublic $tableSearch = '';\n\n#[Url]\npublic ?string $tableSortColumn = null;\n\n#[Url]\npublic ?string $tableSortDirection = null;\n```",
                "level": 3
              },
              {
                "title": "## #Styling table rows",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Striped table rows",
                "content": "To enable striped table rows, you can use the striped() method:\n\n`striped()````\nuse Filament\\Tables\\Table;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->striped();\n}\n```",
                "level": 4
              },
              {
                "title": "### #Custom row classes",
                "content": "You may want to conditionally style rows based on the record data. This can be achieved by specifying a string or array of CSS classes to be applied to the row using the $table->recordClasses() method:\n\n`$table->recordClasses()````\nuse Closure;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Model;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->recordClasses(fn (Model $record) => match ($record->status) {\n            'draft' => 'opacity-30',\n            'reviewing' => 'border-s-2 border-orange-600 dark:border-orange-300',\n            'published' => 'border-s-2 border-green-600 dark:border-green-300',\n            default => null,\n        });\n}\n```\n\nThese classes are not automatically compiled by Tailwind CSS. If you want to apply Tailwind CSS classes that are not already used in Blade files, you should update your content configuration in tailwind.config.js to also scan for classes inside your directory: './app/Filament/**/*.php'\n\n`content``tailwind.config.js``'./app/Filament/**/*.php'`## #Resetting the table\n\nIf you make changes to the table definition during a Livewire request, for example, when consuming a public property in the table() method, you may need to reset the table to ensure that the changes are applied. To do this, you can call the resetTable() method on the Livewire component:\n\n`table()``resetTable()````\n$this->resetTable();\n```",
                "level": 4
              },
              {
                "title": "## #Global settings",
                "content": "To customize the default configuration that is used for all tables, you can call the static configureUsing() method from the boot() method of a service provider. The function will be run for each table that gets created:\n\n`configureUsing()``boot()````\nuse Filament\\Tables\\Enums\\FiltersLayout;\nuse Filament\\Tables\\Table;\n\nTable::configureUsing(function (Table $table): void {\n    $table\n        ->filtersLayout(FiltersLayout::AboveContentCollapsible)\n        ->paginationPageOptions([10, 25, 50]);\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Pagination",
              "Disabling pagination",
              "Customizing the pagination options",
              "Customizing the default pagination page option",
              "Preventing query string conflicts with the pagination page",
              "Displaying links to the first and the last pagination page",
              "Using simple pagination",
              "Using cursor pagination",
              "Record URLs (clickable rows)",
              "Reordering records"
            ],
            "code_examples_count": 52,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "adding-a-table-to-a-livewire-component": {
          "metadata": {
            "title": "Adding A Table To A Livewire Component",
            "url": "https://filamentphp.com/docs/3.x/tables/adding-a-table-to-a-livewire-component",
            "section": "tables",
            "word_count": 632,
            "character_count": 5299
          },
          "content": {
            "full_text": "\n# Adding a table to a Livewire component - Tables - Filament\n\nTables\n\n# Adding a table to a Livewire component\n\n## #Setting up the Livewire component\n\nFirst, generate a new Livewire component:\n\n```\nphp artisan make:livewire ListProducts\n```\n\nThen, render your Livewire component on the page:\n\n```\n@livewire('list-products')\n```\n\nAlternatively, you can use a full-page Livewire component:\n\n```\nuse App\\Livewire\\ListProducts;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('products', ListProducts::class);\n```\n\n## #Adding the table\n\nThere are 3 tasks when adding a table to a Livewire component class:\n\n- Implement the HasTable and HasForms interfaces, and use the InteractsWithTable and InteractsWithForms traits.\n- Add a table() method, which is where you configure the table. Add the table’s columns, filters, and actions.\n- Make sure to define the base query that will be used to fetch rows in the table. For example, if you’re listing products from your Product model, you will want to return Product::query().\n\n`HasTable``HasForms``InteractsWithTable``InteractsWithForms``table()``Product``Product::query()````\n<?php\n\nnamespace App\\Livewire;\n\nuse App\\Models\\Shop\\Product;\nuse Filament\\Forms\\Concerns\\InteractsWithForms;\nuse Filament\\Forms\\Contracts\\HasForms;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Filament\\Tables\\Concerns\\InteractsWithTable;\nuse Filament\\Tables\\Contracts\\HasTable;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Contracts\\View\\View;\nuse Livewire\\Component;\n\nclass ListProducts extends Component implements HasForms, HasTable\n{\n    use InteractsWithTable;\n    use InteractsWithForms;\n    \n    public function table(Table $table): Table\n    {\n        return $table\n            ->query(Product::query())\n            ->columns([\n                TextColumn::make('name'),\n            ])\n            ->filters([\n                // ...\n            ])\n            ->actions([\n                // ...\n            ])\n            ->bulkActions([\n                // ...\n            ]);\n    }\n    \n    public function render(): View\n    {\n        return view('livewire.list-products');\n    }\n}\n```\n\nFinally, in your Livewire component’s view, render the table:\n\n```\n<div>\n    {{ $this->table }}\n</div>\n```\n\nVisit your Livewire component in the browser, and you should see the table.\n\n## #Building a table for an Eloquent relationship\n\nIf you want to build a table for an Eloquent relationship, you can use the relationship() and inverseRelationship() methods on the $table instead of passing a query(). HasMany, HasManyThrough, BelongsToMany, MorphMany and MorphToMany relationships are compatible:\n\n`relationship()``inverseRelationship()``$table``query()``HasMany``HasManyThrough``BelongsToMany``MorphMany``MorphToMany````\nuse App\\Models\\Category;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany;\n\npublic Category $category;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->relationship(fn (): BelongsToMany => $this->category->products())\n        ->inverseRelationship('categories')\n        ->columns([\n            TextColumn::make('name'),\n        ]);\n}\n```\n\nIn this example, we have a $category property which holds a Category model instance. The category has a relationship named products. We use a function to return the relationship instance. This is a many-to-many relationship, so the inverse relationship is called categories, and is defined on the Product model. We just need to pass the name of this relationship to the inverseRelationship() method, not the whole instance.\n\n`$category``Category``products``categories``Product``inverseRelationship()`Now that the table is using a relationship instead of a plain Eloquent query, all actions will be performed on the relationship instead of the query. For example, if you use a CreateAction, the new product will be automatically attached to the category.\n\n`CreateAction`If your relationship uses a pivot table, you can use all pivot columns as if they were normal columns on your table, as long as they are listed in the withPivot() method of the relationship and inverse relationship definition.\n\n`withPivot()`Relationship tables are used in the Panel Builder as “relation managers”. Most of the documented features for relation managers are also available for relationship tables. For instance, attaching and detaching and associating and dissociating actions.\n\n## #Generating table Livewire components with the CLI\n\nIt’s advised that you learn how to set up a Livewire component with the Table Builder manually, but once you are confident, you can use the CLI to generate a table for you.\n\n```\nphp artisan make:livewire-table Products/ListProducts\n```\n\nThis will ask you for the name of a prebuilt model, for example Product. Finally, it will generate a new app/Livewire/Products/ListProducts.php component, which you can customize.\n\n`Product``app/Livewire/Products/ListProducts.php`### #Automatically generating table columns\n\nFilament is also able to guess which table columns you want in the table, based on the model’s database columns. You can use the --generate flag when generating your table:\n\n`--generate````\nphp artisan make:livewire-table Products/ListProducts --generate\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Adding a table to a Livewire component - Tables - Filament",
                "content": "Tables",
                "level": 1
              },
              {
                "title": "# Adding a table to a Livewire component",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Setting up the Livewire component",
                "content": "First, generate a new Livewire component:\n\n```\nphp artisan make:livewire ListProducts\n```\n\nThen, render your Livewire component on the page:\n\n```\n@livewire('list-products')\n```\n\nAlternatively, you can use a full-page Livewire component:\n\n```\nuse App\\Livewire\\ListProducts;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('products', ListProducts::class);\n```",
                "level": 3
              },
              {
                "title": "## #Adding the table",
                "content": "There are 3 tasks when adding a table to a Livewire component class:\n\n- Implement the HasTable and HasForms interfaces, and use the InteractsWithTable and InteractsWithForms traits.\n- Add a table() method, which is where you configure the table. Add the table’s columns, filters, and actions.\n- Make sure to define the base query that will be used to fetch rows in the table. For example, if you’re listing products from your Product model, you will want to return Product::query().\n\n`HasTable``HasForms``InteractsWithTable``InteractsWithForms``table()``Product``Product::query()````\n<?php\n\nnamespace App\\Livewire;\n\nuse App\\Models\\Shop\\Product;\nuse Filament\\Forms\\Concerns\\InteractsWithForms;\nuse Filament\\Forms\\Contracts\\HasForms;\nuse Filament\\Tables\\Columns\\TextColumn;\nuse Filament\\Tables\\Concerns\\InteractsWithTable;\nuse Filament\\Tables\\Contracts\\HasTable;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Contracts\\View\\View;\nuse Livewire\\Component;\n\nclass ListProducts extends Component implements HasForms, HasTable\n{\n    use InteractsWithTable;\n    use InteractsWithForms;\n    \n    public function table(Table $table): Table\n    {\n        return $table\n            ->query(Product::query())\n            ->columns([\n                TextColumn::make('name'),\n            ])\n            ->filters([\n                // ...\n            ])\n            ->actions([\n                // ...\n            ])\n            ->bulkActions([\n                // ...\n            ]);\n    }\n    \n    public function render(): View\n    {\n        return view('livewire.list-products');\n    }\n}\n```\n\nFinally, in your Livewire component’s view, render the table:\n\n```\n<div>\n    {{ $this->table }}\n</div>\n```\n\nVisit your Livewire component in the browser, and you should see the table.",
                "level": 3
              },
              {
                "title": "## #Building a table for an Eloquent relationship",
                "content": "If you want to build a table for an Eloquent relationship, you can use the relationship() and inverseRelationship() methods on the $table instead of passing a query(). HasMany, HasManyThrough, BelongsToMany, MorphMany and MorphToMany relationships are compatible:\n\n`relationship()``inverseRelationship()``$table``query()``HasMany``HasManyThrough``BelongsToMany``MorphMany``MorphToMany````\nuse App\\Models\\Category;\nuse Filament\\Tables\\Table;\nuse Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany;\n\npublic Category $category;\n\npublic function table(Table $table): Table\n{\n    return $table\n        ->relationship(fn (): BelongsToMany => $this->category->products())\n        ->inverseRelationship('categories')\n        ->columns([\n            TextColumn::make('name'),\n        ]);\n}\n```\n\nIn this example, we have a $category property which holds a Category model instance. The category has a relationship named products. We use a function to return the relationship instance. This is a many-to-many relationship, so the inverse relationship is called categories, and is defined on the Product model. We just need to pass the name of this relationship to the inverseRelationship() method, not the whole instance.\n\n`$category``Category``products``categories``Product``inverseRelationship()`Now that the table is using a relationship instead of a plain Eloquent query, all actions will be performed on the relationship instead of the query. For example, if you use a CreateAction, the new product will be automatically attached to the category.\n\n`CreateAction`If your relationship uses a pivot table, you can use all pivot columns as if they were normal columns on your table, as long as they are listed in the withPivot() method of the relationship and inverse relationship definition.\n\n`withPivot()`Relationship tables are used in the Panel Builder as “relation managers”. Most of the documented features for relation managers are also available for relationship tables. For instance, attaching and detaching and associating and dissociating actions.",
                "level": 3
              },
              {
                "title": "## #Generating table Livewire components with the CLI",
                "content": "It’s advised that you learn how to set up a Livewire component with the Table Builder manually, but once you are confident, you can use the CLI to generate a table for you.\n\n```\nphp artisan make:livewire-table Products/ListProducts\n```\n\nThis will ask you for the name of a prebuilt model, for example Product. Finally, it will generate a new app/Livewire/Products/ListProducts.php component, which you can customize.\n\n`Product``app/Livewire/Products/ListProducts.php`### #Automatically generating table columns\n\nFilament is also able to guess which table columns you want in the table, based on the model’s database columns. You can use the --generate flag when generating your table:\n\n`--generate````\nphp artisan make:livewire-table Products/ListProducts --generate\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Setting up the Livewire component",
              "Adding the table",
              "Building a table for an Eloquent relationship",
              "Generating table Livewire components with the CLI"
            ],
            "code_examples_count": 16,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "testing": {
          "metadata": {
            "title": "Testing",
            "url": "https://filamentphp.com/docs/3.x/tables/testing",
            "section": "tables",
            "word_count": 2324,
            "character_count": 27802
          },
          "content": {
            "full_text": "\n# Testing - Tables - Filament\n\nTables\n\n# Testing\n\n## #Overview\n\nAll examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\nSince the Table Builder works on Livewire components, you can use the Livewire testing helpers. However, we have many custom testing helpers that you can use for tables:\n\n## #Render\n\nTo ensure a table component renders, use the assertSuccessful() Livewire helper:\n\n`assertSuccessful()````\nuse function Pest\\Livewire\\livewire;\n\nit('can render page', function () {\n    livewire(ListPosts::class)->assertSuccessful();\n});\n```\n\nTo test which records are shown, you can use assertCanSeeTableRecords(), assertCanNotSeeTableRecords() and assertCountTableRecords():\n\n`assertCanSeeTableRecords()``assertCanNotSeeTableRecords()``assertCountTableRecords()````\nuse function Pest\\Livewire\\livewire;\n\nit('cannot display trashed posts by default', function () {\n    $posts = Post::factory()->count(4)->create();\n    $trashedPosts = Post::factory()->trashed()->count(6)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts)\n        ->assertCanNotSeeTableRecords($trashedPosts)\n        ->assertCountTableRecords(4);\n});\n```\n\n> If your table uses pagination, assertCanSeeTableRecords() will only check for records on the first page. To switch page, call call('gotoPage', 2).\n\nIf your table uses pagination, assertCanSeeTableRecords() will only check for records on the first page. To switch page, call call('gotoPage', 2).\n\n`assertCanSeeTableRecords()``call('gotoPage', 2)`> If your table uses deferLoading(), you should call loadTable() before assertCanSeeTableRecords().\n\nIf your table uses deferLoading(), you should call loadTable() before assertCanSeeTableRecords().\n\n`deferLoading()``loadTable()``assertCanSeeTableRecords()`## #Columns\n\nTo ensure that a certain column is rendered, pass the column name to assertCanRenderTableColumn():\n\n`assertCanRenderTableColumn()````\nuse function Pest\\Livewire\\livewire;\n\nit('can render post titles', function () {\n    Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanRenderTableColumn('title');\n});\n```\n\nThis helper will get the HTML for this column, and check that it is present in the table.\n\nFor testing that a column is not rendered, you can use assertCanNotRenderTableColumn():\n\n`assertCanNotRenderTableColumn()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not render post comments', function () {\n    Post::factory()->count(10)->create()\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanNotRenderTableColumn('comments');\n});\n```\n\nThis helper will assert that the HTML for this column is not shown by default in the present table.\n\n### #Sorting\n\nTo sort table records, you can call sortTable(), passing the name of the column to sort by. You can use 'desc' in the second parameter of sortTable() to reverse the sorting direction.\n\n`sortTable()``'desc'``sortTable()`Once the table is sorted, you can ensure that the table records are rendered in order using assertCanSeeTableRecords() with the inOrder parameter:\n\n`assertCanSeeTableRecords()``inOrder````\nuse function Pest\\Livewire\\livewire;\n\nit('can sort posts by title', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->sortTable('title')\n        ->assertCanSeeTableRecords($posts->sortBy('title'), inOrder: true)\n        ->sortTable('title', 'desc')\n        ->assertCanSeeTableRecords($posts->sortByDesc('title'), inOrder: true);\n});\n```\n\n### #Searching\n\nTo search the table, call the searchTable() method with your search query.\n\n`searchTable()`You can then use assertCanSeeTableRecords() to check your filtered table records, and use assertCanNotSeeTableRecords() to assert that some records are no longer in the table:\n\n`assertCanSeeTableRecords()``assertCanNotSeeTableRecords()````\nuse function Pest\\Livewire\\livewire;\n\nit('can search posts by title', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    $title = $posts->first()->title;\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->searchTable($title)\n        ->assertCanSeeTableRecords($posts->where('title', $title))\n        ->assertCanNotSeeTableRecords($posts->where('title', '!=', $title));\n});\n```\n\nTo search individual columns, you can pass an array of searches to searchTableColumns():\n\n`searchTableColumns()````\nuse function Pest\\Livewire\\livewire;\n\nit('can search posts by title column', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    $title = $posts->first()->title;\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->searchTableColumns(['title' => $title])\n        ->assertCanSeeTableRecords($posts->where('title', $title))\n        ->assertCanNotSeeTableRecords($posts->where('title', '!=', $title));\n});\n```\n\n### #State\n\nTo assert that a certain column has a state or does not have a state for a record you can use assertTableColumnStateSet() and assertTableColumnStateNotSet():\n\n`assertTableColumnStateSet()``assertTableColumnStateNotSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can get post author names', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    $post = $posts->first();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableColumnStateSet('author.name', $post->author->name, record: $post)\n        ->assertTableColumnStateNotSet('author.name', 'Anonymous', record: $post);\n});\n```\n\nTo assert that a certain column has a formatted state or does not have a formatted state for a record you can use assertTableColumnFormattedStateSet() and assertTableColumnFormattedStateNotSet():\n\n`assertTableColumnFormattedStateSet()``assertTableColumnFormattedStateNotSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can get post author names', function () {\n    $post = Post::factory(['name' => 'John Smith'])->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableColumnFormattedStateSet('author.name', 'Smith, John', record: $post)\n        ->assertTableColumnFormattedStateNotSet('author.name', $post->author->name, record: $post);\n});\n```\n\n### #Existence\n\nTo ensure that a column exists, you can use the assertTableColumnExists() method:\n\n`assertTableColumnExists()````\nuse function Pest\\Livewire\\livewire;\n\nit('has an author column', function () {\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableColumnExists('author');\n});\n```\n\nYou may pass a function as an additional argument in order to assert that a column passes a given “truth test”. This is useful for asserting that a column has a specific configuration. You can also pass in a record as the third parameter, which is useful if your check is dependant on which table row is being rendered:\n\n```\nuse function Pest\\Livewire\\livewire;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nit('has an author column', function () {\n    $post = Post::factory()->create();\n    \n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableColumnExists('author', function (TextColumn $column): bool {\n            return $column->getDescriptionBelow() === $post->subtitle;\n        }, $post);\n});\n```\n\n### #Authorization\n\nTo ensure that a particular user cannot see a column, you can use the assertTableColumnVisible() and assertTableColumnHidden() methods:\n\n`assertTableColumnVisible()``assertTableColumnHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('shows the correct columns', function () {\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableColumnVisible('created_at')\n        ->assertTableColumnHidden('author');\n});\n```\n\n### #Descriptions\n\nTo ensure a column has the correct description above or below you can use the assertTableColumnHasDescription() and assertTableColumnDoesNotHaveDescription() methods:\n\n`assertTableColumnHasDescription()``assertTableColumnDoesNotHaveDescription()````\nuse function Pest\\Livewire\\livewire;\n\nit('has the correct descriptions above and below author', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostsTable::class)\n        ->assertTableColumnHasDescription('author', 'Author! ↓↓↓', $post, 'above')\n        ->assertTableColumnHasDescription('author', 'Author! ↑↑↑', $post)\n        ->assertTableColumnDoesNotHaveDescription('author', 'Author! ↑↑↑', $post, 'above')\n        ->assertTableColumnDoesNotHaveDescription('author', 'Author! ↓↓↓', $post);\n});\n```\n\n### #Extra Attributes\n\nTo ensure that a column has the correct extra attributes, you can use the assertTableColumnHasExtraAttributes() and assertTableColumnDoesNotHaveExtraAttributes() methods:\n\n`assertTableColumnHasExtraAttributes()``assertTableColumnDoesNotHaveExtraAttributes()````\nuse function Pest\\Livewire\\livewire;\n\nit('displays author in red', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostsTable::class)\n        ->assertTableColumnHasExtraAttributes('author', ['class' => 'text-danger-500'], $post)\n        ->assertTableColumnDoesNotHaveExtraAttributes('author', ['class' => 'text-primary-500'], $post);\n});\n```\n\n### #Select Columns\n\nIf you have a select column, you can ensure it has the correct options with assertTableSelectColumnHasOptions() and assertTableSelectColumnDoesNotHaveOptions():\n\n`assertTableSelectColumnHasOptions()``assertTableSelectColumnDoesNotHaveOptions()````\nuse function Pest\\Livewire\\livewire;\n\nit('has the correct statuses', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostsTable::class)\n        ->assertTableSelectColumnHasOptions('status', ['unpublished' => 'Unpublished', 'published' => 'Published'], $post)\n        ->assertTableSelectColumnDoesNotHaveOptions('status', ['archived' => 'Archived'], $post);\n});\n```\n\n## #Filters\n\nTo filter the table records, you can use the filterTable() method, along with assertCanSeeTableRecords() and assertCanNotSeeTableRecords():\n\n`filterTable()``assertCanSeeTableRecords()``assertCanNotSeeTableRecords()````\nuse function Pest\\Livewire\\livewire;\n\nit('can filter posts by `is_published`', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts)\n        ->filterTable('is_published')\n        ->assertCanSeeTableRecords($posts->where('is_published', true))\n        ->assertCanNotSeeTableRecords($posts->where('is_published', false));\n});\n```\n\nFor a simple filter, this will just enable the filter.\n\nIf you’d like to set the value of a SelectFilter or TernaryFilter, pass the value as a second argument:\n\n`SelectFilter``TernaryFilter````\nuse function Pest\\Livewire\\livewire;\n\nit('can filter posts by `author_id`', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    $authorId = $posts->first()->author_id;\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts)\n        ->filterTable('author_id', $authorId)\n        ->assertCanSeeTableRecords($posts->where('author_id', $authorId))\n        ->assertCanNotSeeTableRecords($posts->where('author_id', '!=', $authorId));\n});\n```\n\n### #Resetting filters\n\nTo reset all filters to their original state, call resetTableFilters():\n\n`resetTableFilters()````\nuse function Pest\\Livewire\\livewire;\n\nit('can reset table filters', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->resetTableFilters();\n});\n```\n\n### #Removing Filters\n\nTo remove a single filter you can use removeTableFilter():\n\n`removeTableFilter()````\nuse function Pest\\Livewire\\livewire;\n\nit('filters list by published', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    $unpublishedPosts = $posts->where('is_published', false)->get();\n\n    livewire(PostsTable::class)\n        ->filterTable('is_published')\n        ->assertCanNotSeeTableRecords($unpublishedPosts)\n        ->removeTableFilter('is_published')\n        ->assertCanSeeTableRecords($posts);\n});\n```\n\nTo remove all filters you can use removeTableFilters():\n\n`removeTableFilters()````\nuse function Pest\\Livewire\\livewire;\n\nit('can remove all table filters', function () {\n    $posts = Post::factory()->count(10)->forAuthor()->create();\n\n    $unpublishedPosts = $posts\n        ->where('is_published', false)\n        ->where('author_id', $posts->first()->author->getKey());\n\n    livewire(PostsTable::class)\n        ->filterTable('is_published')\n        ->filterTable('author', $author)\n        ->assertCanNotSeeTableRecords($unpublishedPosts)\n        ->removeTableFilters()\n        ->assertCanSeeTableRecords($posts);\n});\n```\n\n### #Hidden filters\n\nTo ensure that a particular user cannot see a filter, you can use the assertTableFilterVisible() and assertTableFilterHidden() methods:\n\n`assertTableFilterVisible()``assertTableFilterHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('shows the correct filters', function () {\n    livewire(PostsTable::class)\n        ->assertTableFilterVisible('created_at')\n        ->assertTableFilterHidden('author');\n```\n\n### #Filter existence\n\nTo ensure that a filter exists, you can use the assertTableFilterExists() method:\n\n`assertTableFilterExists()````\nuse function Pest\\Livewire\\livewire;\n\nit('has an author filter', function () {\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableFilterExists('author');\n});\n```\n\nYou may pass a function as an additional argument in order to assert that a filter passes a given “truth test”. This is useful for asserting that a filter has a specific configuration:\n\n```\nuse function Pest\\Livewire\\livewire;\nuse Filament\\Tables\\Filters\\SelectFilter;\n\nit('has an author filter', function () {    \n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableFilterExists('author', function (SelectFilter $column): bool {\n            return $column->getLabel() === 'Select author';\n        });\n});\n```\n\n## #Actions\n\n### #Calling actions\n\nYou can call an action by passing its name or class to callTableAction():\n\n`callTableAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can delete posts', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableAction(DeleteAction::class, $post);\n\n    $this->assertModelMissing($post);\n});\n```\n\nThis example assumes that you have a DeleteAction on your table. If you have a custom Action::make('reorder'), you may use callTableAction('reorder').\n\n`DeleteAction``Action::make('reorder')``callTableAction('reorder')`For column actions, you may do the same, using callTableColumnAction():\n\n`callTableColumnAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can copy posts', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableColumnAction('copy', $post);\n\n    $this->assertDatabaseCount((new Post)->getTable(), 2);\n});\n```\n\nFor bulk actions, you may do the same, passing in multiple records to execute the bulk action against with callTableBulkAction():\n\n`callTableBulkAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can bulk delete posts', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableBulkAction(DeleteBulkAction::class, $posts);\n\n    foreach ($posts as $post) {\n        $this->assertModelMissing($post);\n    }\n});\n```\n\nTo pass an array of data into an action, use the data parameter:\n\n`data````\nuse function Pest\\Livewire\\livewire;\n\nit('can edit posts', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableAction(EditAction::class, $post, data: [\n            'title' => $title = fake()->words(asText: true),\n        ])\n        ->assertHasNoTableActionErrors();\n\n    expect($post->refresh())\n        ->title->toBe($title);\n});\n```\n\n### #Execution\n\nTo check if an action or bulk action has been halted, you can use assertTableActionHalted() / assertTableBulkActionHalted():\n\n`assertTableActionHalted()``assertTableBulkActionHalted()````\nuse function Pest\\Livewire\\livewire;\n\nit('will halt delete if post is flagged', function () {\n    $posts= Post::factory()->count(2)->flagged()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableAction('delete', $posts->first())\n        ->callTableBulkAction('delete', $posts)\n        ->assertTableActionHalted('delete')\n        ->assertTableBulkActionHalted('delete');\n\n    $this->assertModelExists($post);\n});\n```\n\n### #Errors\n\nassertHasNoTableActionErrors() is used to assert that no validation errors occurred when submitting the action form.\n\n`assertHasNoTableActionErrors()`To check if a validation error has occurred with the data, use assertHasTableActionErrors(), similar to assertHasErrors() in Livewire:\n\n`assertHasTableActionErrors()``assertHasErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate edited post data', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableAction(EditAction::class, $post, data: [\n            'title' => null,\n        ])\n        ->assertHasTableActionErrors(['title' => ['required']]);\n});\n```\n\nFor bulk actions these methods are called assertHasTableBulkActionErrors() and assertHasNoTableBulkActionErrors().\n\n`assertHasTableBulkActionErrors()``assertHasNoTableBulkActionErrors()`### #Pre-filled data\n\nTo check if an action or bulk action is pre-filled with data, you can use the assertTableActionDataSet() or assertTableBulkActionDataSet() method:\n\n`assertTableActionDataSet()``assertTableBulkActionDataSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can load existing post data for editing', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->mountTableAction(EditAction::class, $post)\n        ->assertTableActionDataSet([\n            'title' => $post->title,\n        ])\n        ->setTableActionData([\n            'title' => $title = fake()->words(asText: true),\n        ])\n        ->callMountedTableAction()\n        ->assertHasNoTableActionErrors();\n\n    expect($post->refresh())\n        ->title->toBe($title);\n});\n```\n\nYou may also find it useful to pass a function to the assertTableActionDataSet() and assertTableBulkActionDataSet() methods, which allow you to access the form $state and perform additional assertions:\n\n`assertTableActionDataSet()``assertTableBulkActionDataSet()``$state````\nuse Illuminate\\Support\\Str;\nuse function Pest\\Livewire\\livewire;\n\nit('can automatically generate a slug from the title without any spaces', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->mountTableAction(EditAction::class, $post)\n        ->assertTableActionDataSet(function (array $state) use ($post): array {\n            expect($state['slug'])\n                ->not->toContain(' ');\n                \n            return [\n                'slug' => Str::slug($post->title),\n            ];\n        });\n});\n```\n\n### #Action state\n\nTo ensure that an action or bulk action exists or doesn’t in a table, you can use the assertTableActionExists() / assertTableActionDoesNotExist() or  assertTableBulkActionExists() / assertTableBulkActionDoesNotExist() method:\n\n`assertTableActionExists()``assertTableActionDoesNotExist()``assertTableBulkActionExists()``assertTableBulkActionDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('can publish but not unpublish posts', function () {\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionExists('publish')\n        ->assertTableActionDoesNotExist('unpublish')\n        ->assertTableBulkActionExists('publish')\n        ->assertTableBulkActionDoesNotExist('unpublish');\n});\n```\n\nTo ensure different sets of actions exist in the correct order, you can use the various “InOrder” assertions\n\n```\nuse function Pest\\Livewire\\livewire;\n\nit('has all actions in expected order', function () {\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionsExistInOrder(['edit', 'delete'])\n        ->assertTableBulkActionsExistInOrder(['restore', 'forceDelete'])\n        ->assertTableHeaderActionsExistInOrder(['create', 'attach'])\n        ->assertTableEmptyStateActionsExistInOrder(['create', 'toggle-trashed-filter'])\n});\n```\n\nTo ensure that an action or bulk action is enabled or disabled for a user, you can use the assertTableActionEnabled() / assertTableActionDisabled() or assertTableBulkActionEnabled() / assertTableBulkActionDisabled() methods:\n\n`assertTableActionEnabled()``assertTableActionDisabled()``assertTableBulkActionEnabled()``assertTableBulkActionDisabled()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not publish, but can delete posts', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionDisabled('publish', $post)\n        ->assertTableActionEnabled('delete', $post)\n        ->assertTableBulkActionDisabled('publish')\n        ->assertTableBulkActionEnabled('delete');\n});\n```\n\nTo ensure that an action or bulk action is visible or hidden for a user, you can use the assertTableActionVisible() / assertTableActionHidden() or assertTableBulkActionVisible() / assertTableBulkActionHidden() methods:\n\n`assertTableActionVisible()``assertTableActionHidden()``assertTableBulkActionVisible()``assertTableBulkActionHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not publish, but can delete posts', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionHidden('publish', $post)\n        ->assertTableActionVisible('delete', $post)\n        ->assertTableBulkActionHidden('publish')\n        ->assertTableBulkActionVisible('delete');\n});\n```\n\n### #Button Style\n\nTo ensure an action or bulk action has the correct label, you can use assertTableActionHasLabel() / assertTableBulkActionHasLabel() and assertTableActionDoesNotHaveLabel() / assertTableBulkActionDoesNotHaveLabel():\n\n`assertTableActionHasLabel()``assertTableBulkActionHasLabel()``assertTableActionDoesNotHaveLabel()``assertTableBulkActionDoesNotHaveLabel()````\nuse function Pest\\Livewire\\livewire;\n\nit('delete actions have correct labels', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionHasLabel('delete', 'Archive Post', $post)\n        ->assertTableActionDoesNotHaveLabel('delete', 'Delete', $post);\n        ->assertTableBulkActionHasLabel('delete', 'Archive Post', $post)\n        ->assertTableBulkActionDoesNotHaveLabel('delete', 'Delete', $post);\n});\n```\n\nTo ensure an action or bulk action’s button is showing the correct icon, you can use assertTableActionHasIcon() / assertTableBulkActionHasIcon() or assertTableActionDoesNotHaveIcon() / assertTableBulkActionDoesNotHaveIcon():\n\n`assertTableActionHasIcon()``assertTableBulkActionHasIcon()``assertTableActionDoesNotHaveIcon()``assertTableBulkActionDoesNotHaveIcon()````\nuse function Pest\\Livewire\\livewire;\n\nit('delete actions have correct icons', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionHasIcon('delete', 'heroicon-m-archive-box', $post)\n        ->assertTableActionDoesNotHaveIcon('delete', 'heroicon-m-trash', $post);\n        ->assertTableBulkActionHasIcon('delete', 'heroicon-m-archive-box', $post)\n        ->assertTableBulkActionDoesNotHaveIcon('delete', 'heroicon-m-trash', $post);\n});\n```\n\nTo ensure that an action or bulk action’s button is displaying the right color, you can use assertTableActionHasColor() / assertTableBulkActionHasColor() or assertTableActionDoesNotHaveColor() / assertTableBulkActionDoesNotHaveColor():\n\n`assertTableActionHasColor()``assertTableBulkActionHasColor()``assertTableActionDoesNotHaveColor()``assertTableBulkActionDoesNotHaveColor()````\nuse function Pest\\Livewire\\livewire;\n\nit('delete actions have correct colors', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionHasColor('delete', 'warning', $post)\n        ->assertTableActionDoesNotHaveColor('delete', 'danger', $post);\n        ->assertTableBulkActionHasColor('delete', 'warning', $post)\n        ->assertTableBulkActionDoesNotHaveColor('delete', 'danger', $post);\n});\n```\n\n### #URL\n\nTo ensure an action or bulk action has the correct URL traits, you can use assertTableActionHasUrl(), assertTableActionDoesNotHaveUrl(), assertTableActionShouldOpenUrlInNewTab(), and assertTableActionShouldNotOpenUrlInNewTab():\n\n`assertTableActionHasUrl()``assertTableActionDoesNotHaveUrl()``assertTableActionShouldOpenUrlInNewTab()``assertTableActionShouldNotOpenUrlInNewTab()````\nuse function Pest\\Livewire\\livewire;\n\nit('links to the correct Filament sites', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionHasUrl('filament', 'https://filamentphp.com/', $post)\n        ->assertTableActionDoesNotHaveUrl('filament', 'https://github.com/filamentphp/filament', $post)\n        ->assertTableActionShouldOpenUrlInNewTab('filament', $post)\n        ->assertTableActionShouldNotOpenUrlInNewTab('github', $post);\n});\n```\n\n## #Summaries\n\nTo test that a summary calculation is working, you may use the assertTableColumnSummarySet() method:\n\n`assertTableColumnSummarySet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can average values in a column', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts)\n        ->assertTableColumnSummarySet('rating', 'average', $posts->avg('rating'));\n});\n```\n\nThe first argument is the column name, the second is the summarizer ID, and the third is the expected value.\n\nNote that the expected and actual values are normalized, such that 123.12 is considered the same as \"123.12\", and ['Fred', 'Jim'] is the same as ['Jim', 'Fred'].\n\n`123.12``\"123.12\"``['Fred', 'Jim']``['Jim', 'Fred']`You may set a summarizer ID by passing it to the make() method:\n\n`make()````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make('average'))\n```\n\nThe ID should be unique between summarizers in that column.\n\n### #Summarizing only one pagination page\n\nTo calculate the average for only one pagination page, use the isCurrentPaginationPageOnly argument:\n\n`isCurrentPaginationPageOnly````\nuse function Pest\\Livewire\\livewire;\n\nit('can average values in a column', function () {\n    $posts = Post::factory()->count(20)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts->take(10))\n        ->assertTableColumnSummarySet('rating', 'average', $posts->take(10)->avg('rating'), isCurrentPaginationPageOnly: true);\n});\n```\n\n### #Testing a range summarizer\n\nTo test a range, pass the minimum and maximum value into a tuple-style [$minimum, $maximum] array:\n\n`[$minimum, $maximum]````\nuse function Pest\\Livewire\\livewire;\n\nit('can average values in a column', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts)\n        ->assertTableColumnSummarySet('rating', 'range', [$posts->min('rating'), $posts->max('rating')]);\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Testing - Tables - Filament",
                "content": "Tables",
                "level": 1
              },
              {
                "title": "# Testing",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "All examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\nSince the Table Builder works on Livewire components, you can use the Livewire testing helpers. However, we have many custom testing helpers that you can use for tables:",
                "level": 3
              },
              {
                "title": "## #Render",
                "content": "To ensure a table component renders, use the assertSuccessful() Livewire helper:\n\n`assertSuccessful()````\nuse function Pest\\Livewire\\livewire;\n\nit('can render page', function () {\n    livewire(ListPosts::class)->assertSuccessful();\n});\n```\n\nTo test which records are shown, you can use assertCanSeeTableRecords(), assertCanNotSeeTableRecords() and assertCountTableRecords():\n\n`assertCanSeeTableRecords()``assertCanNotSeeTableRecords()``assertCountTableRecords()````\nuse function Pest\\Livewire\\livewire;\n\nit('cannot display trashed posts by default', function () {\n    $posts = Post::factory()->count(4)->create();\n    $trashedPosts = Post::factory()->trashed()->count(6)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts)\n        ->assertCanNotSeeTableRecords($trashedPosts)\n        ->assertCountTableRecords(4);\n});\n```\n\n> If your table uses pagination, assertCanSeeTableRecords() will only check for records on the first page. To switch page, call call('gotoPage', 2).\n\nIf your table uses pagination, assertCanSeeTableRecords() will only check for records on the first page. To switch page, call call('gotoPage', 2).\n\n`assertCanSeeTableRecords()``call('gotoPage', 2)`> If your table uses deferLoading(), you should call loadTable() before assertCanSeeTableRecords().\n\nIf your table uses deferLoading(), you should call loadTable() before assertCanSeeTableRecords().\n\n`deferLoading()``loadTable()``assertCanSeeTableRecords()`## #Columns\n\nTo ensure that a certain column is rendered, pass the column name to assertCanRenderTableColumn():\n\n`assertCanRenderTableColumn()````\nuse function Pest\\Livewire\\livewire;\n\nit('can render post titles', function () {\n    Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanRenderTableColumn('title');\n});\n```\n\nThis helper will get the HTML for this column, and check that it is present in the table.\n\nFor testing that a column is not rendered, you can use assertCanNotRenderTableColumn():\n\n`assertCanNotRenderTableColumn()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not render post comments', function () {\n    Post::factory()->count(10)->create()\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanNotRenderTableColumn('comments');\n});\n```\n\nThis helper will assert that the HTML for this column is not shown by default in the present table.",
                "level": 3
              },
              {
                "title": "### #Sorting",
                "content": "To sort table records, you can call sortTable(), passing the name of the column to sort by. You can use 'desc' in the second parameter of sortTable() to reverse the sorting direction.\n\n`sortTable()``'desc'``sortTable()`Once the table is sorted, you can ensure that the table records are rendered in order using assertCanSeeTableRecords() with the inOrder parameter:\n\n`assertCanSeeTableRecords()``inOrder````\nuse function Pest\\Livewire\\livewire;\n\nit('can sort posts by title', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->sortTable('title')\n        ->assertCanSeeTableRecords($posts->sortBy('title'), inOrder: true)\n        ->sortTable('title', 'desc')\n        ->assertCanSeeTableRecords($posts->sortByDesc('title'), inOrder: true);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Searching",
                "content": "To search the table, call the searchTable() method with your search query.\n\n`searchTable()`You can then use assertCanSeeTableRecords() to check your filtered table records, and use assertCanNotSeeTableRecords() to assert that some records are no longer in the table:\n\n`assertCanSeeTableRecords()``assertCanNotSeeTableRecords()````\nuse function Pest\\Livewire\\livewire;\n\nit('can search posts by title', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    $title = $posts->first()->title;\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->searchTable($title)\n        ->assertCanSeeTableRecords($posts->where('title', $title))\n        ->assertCanNotSeeTableRecords($posts->where('title', '!=', $title));\n});\n```\n\nTo search individual columns, you can pass an array of searches to searchTableColumns():\n\n`searchTableColumns()````\nuse function Pest\\Livewire\\livewire;\n\nit('can search posts by title column', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    $title = $posts->first()->title;\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->searchTableColumns(['title' => $title])\n        ->assertCanSeeTableRecords($posts->where('title', $title))\n        ->assertCanNotSeeTableRecords($posts->where('title', '!=', $title));\n});\n```",
                "level": 4
              },
              {
                "title": "### #State",
                "content": "To assert that a certain column has a state or does not have a state for a record you can use assertTableColumnStateSet() and assertTableColumnStateNotSet():\n\n`assertTableColumnStateSet()``assertTableColumnStateNotSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can get post author names', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    $post = $posts->first();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableColumnStateSet('author.name', $post->author->name, record: $post)\n        ->assertTableColumnStateNotSet('author.name', 'Anonymous', record: $post);\n});\n```\n\nTo assert that a certain column has a formatted state or does not have a formatted state for a record you can use assertTableColumnFormattedStateSet() and assertTableColumnFormattedStateNotSet():\n\n`assertTableColumnFormattedStateSet()``assertTableColumnFormattedStateNotSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can get post author names', function () {\n    $post = Post::factory(['name' => 'John Smith'])->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableColumnFormattedStateSet('author.name', 'Smith, John', record: $post)\n        ->assertTableColumnFormattedStateNotSet('author.name', $post->author->name, record: $post);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Existence",
                "content": "To ensure that a column exists, you can use the assertTableColumnExists() method:\n\n`assertTableColumnExists()````\nuse function Pest\\Livewire\\livewire;\n\nit('has an author column', function () {\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableColumnExists('author');\n});\n```\n\nYou may pass a function as an additional argument in order to assert that a column passes a given “truth test”. This is useful for asserting that a column has a specific configuration. You can also pass in a record as the third parameter, which is useful if your check is dependant on which table row is being rendered:\n\n```\nuse function Pest\\Livewire\\livewire;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nit('has an author column', function () {\n    $post = Post::factory()->create();\n    \n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableColumnExists('author', function (TextColumn $column): bool {\n            return $column->getDescriptionBelow() === $post->subtitle;\n        }, $post);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Authorization",
                "content": "To ensure that a particular user cannot see a column, you can use the assertTableColumnVisible() and assertTableColumnHidden() methods:\n\n`assertTableColumnVisible()``assertTableColumnHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('shows the correct columns', function () {\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableColumnVisible('created_at')\n        ->assertTableColumnHidden('author');\n});\n```",
                "level": 4
              },
              {
                "title": "### #Descriptions",
                "content": "To ensure a column has the correct description above or below you can use the assertTableColumnHasDescription() and assertTableColumnDoesNotHaveDescription() methods:\n\n`assertTableColumnHasDescription()``assertTableColumnDoesNotHaveDescription()````\nuse function Pest\\Livewire\\livewire;\n\nit('has the correct descriptions above and below author', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostsTable::class)\n        ->assertTableColumnHasDescription('author', 'Author! ↓↓↓', $post, 'above')\n        ->assertTableColumnHasDescription('author', 'Author! ↑↑↑', $post)\n        ->assertTableColumnDoesNotHaveDescription('author', 'Author! ↑↑↑', $post, 'above')\n        ->assertTableColumnDoesNotHaveDescription('author', 'Author! ↓↓↓', $post);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Extra Attributes",
                "content": "To ensure that a column has the correct extra attributes, you can use the assertTableColumnHasExtraAttributes() and assertTableColumnDoesNotHaveExtraAttributes() methods:\n\n`assertTableColumnHasExtraAttributes()``assertTableColumnDoesNotHaveExtraAttributes()````\nuse function Pest\\Livewire\\livewire;\n\nit('displays author in red', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostsTable::class)\n        ->assertTableColumnHasExtraAttributes('author', ['class' => 'text-danger-500'], $post)\n        ->assertTableColumnDoesNotHaveExtraAttributes('author', ['class' => 'text-primary-500'], $post);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Select Columns",
                "content": "If you have a select column, you can ensure it has the correct options with assertTableSelectColumnHasOptions() and assertTableSelectColumnDoesNotHaveOptions():\n\n`assertTableSelectColumnHasOptions()``assertTableSelectColumnDoesNotHaveOptions()````\nuse function Pest\\Livewire\\livewire;\n\nit('has the correct statuses', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostsTable::class)\n        ->assertTableSelectColumnHasOptions('status', ['unpublished' => 'Unpublished', 'published' => 'Published'], $post)\n        ->assertTableSelectColumnDoesNotHaveOptions('status', ['archived' => 'Archived'], $post);\n});\n```",
                "level": 4
              },
              {
                "title": "## #Filters",
                "content": "To filter the table records, you can use the filterTable() method, along with assertCanSeeTableRecords() and assertCanNotSeeTableRecords():\n\n`filterTable()``assertCanSeeTableRecords()``assertCanNotSeeTableRecords()````\nuse function Pest\\Livewire\\livewire;\n\nit('can filter posts by `is_published`', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts)\n        ->filterTable('is_published')\n        ->assertCanSeeTableRecords($posts->where('is_published', true))\n        ->assertCanNotSeeTableRecords($posts->where('is_published', false));\n});\n```\n\nFor a simple filter, this will just enable the filter.\n\nIf you’d like to set the value of a SelectFilter or TernaryFilter, pass the value as a second argument:\n\n`SelectFilter``TernaryFilter````\nuse function Pest\\Livewire\\livewire;\n\nit('can filter posts by `author_id`', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    $authorId = $posts->first()->author_id;\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts)\n        ->filterTable('author_id', $authorId)\n        ->assertCanSeeTableRecords($posts->where('author_id', $authorId))\n        ->assertCanNotSeeTableRecords($posts->where('author_id', '!=', $authorId));\n});\n```",
                "level": 3
              },
              {
                "title": "### #Resetting filters",
                "content": "To reset all filters to their original state, call resetTableFilters():\n\n`resetTableFilters()````\nuse function Pest\\Livewire\\livewire;\n\nit('can reset table filters', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->resetTableFilters();\n});\n```",
                "level": 4
              },
              {
                "title": "### #Removing Filters",
                "content": "To remove a single filter you can use removeTableFilter():\n\n`removeTableFilter()````\nuse function Pest\\Livewire\\livewire;\n\nit('filters list by published', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    $unpublishedPosts = $posts->where('is_published', false)->get();\n\n    livewire(PostsTable::class)\n        ->filterTable('is_published')\n        ->assertCanNotSeeTableRecords($unpublishedPosts)\n        ->removeTableFilter('is_published')\n        ->assertCanSeeTableRecords($posts);\n});\n```\n\nTo remove all filters you can use removeTableFilters():\n\n`removeTableFilters()````\nuse function Pest\\Livewire\\livewire;\n\nit('can remove all table filters', function () {\n    $posts = Post::factory()->count(10)->forAuthor()->create();\n\n    $unpublishedPosts = $posts\n        ->where('is_published', false)\n        ->where('author_id', $posts->first()->author->getKey());\n\n    livewire(PostsTable::class)\n        ->filterTable('is_published')\n        ->filterTable('author', $author)\n        ->assertCanNotSeeTableRecords($unpublishedPosts)\n        ->removeTableFilters()\n        ->assertCanSeeTableRecords($posts);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Hidden filters",
                "content": "To ensure that a particular user cannot see a filter, you can use the assertTableFilterVisible() and assertTableFilterHidden() methods:\n\n`assertTableFilterVisible()``assertTableFilterHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('shows the correct filters', function () {\n    livewire(PostsTable::class)\n        ->assertTableFilterVisible('created_at')\n        ->assertTableFilterHidden('author');\n```",
                "level": 4
              },
              {
                "title": "### #Filter existence",
                "content": "To ensure that a filter exists, you can use the assertTableFilterExists() method:\n\n`assertTableFilterExists()````\nuse function Pest\\Livewire\\livewire;\n\nit('has an author filter', function () {\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableFilterExists('author');\n});\n```\n\nYou may pass a function as an additional argument in order to assert that a filter passes a given “truth test”. This is useful for asserting that a filter has a specific configuration:\n\n```\nuse function Pest\\Livewire\\livewire;\nuse Filament\\Tables\\Filters\\SelectFilter;\n\nit('has an author filter', function () {    \n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableFilterExists('author', function (SelectFilter $column): bool {\n            return $column->getLabel() === 'Select author';\n        });\n});\n```",
                "level": 4
              },
              {
                "title": "## #Actions",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Calling actions",
                "content": "You can call an action by passing its name or class to callTableAction():\n\n`callTableAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can delete posts', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableAction(DeleteAction::class, $post);\n\n    $this->assertModelMissing($post);\n});\n```\n\nThis example assumes that you have a DeleteAction on your table. If you have a custom Action::make('reorder'), you may use callTableAction('reorder').\n\n`DeleteAction``Action::make('reorder')``callTableAction('reorder')`For column actions, you may do the same, using callTableColumnAction():\n\n`callTableColumnAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can copy posts', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableColumnAction('copy', $post);\n\n    $this->assertDatabaseCount((new Post)->getTable(), 2);\n});\n```\n\nFor bulk actions, you may do the same, passing in multiple records to execute the bulk action against with callTableBulkAction():\n\n`callTableBulkAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can bulk delete posts', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableBulkAction(DeleteBulkAction::class, $posts);\n\n    foreach ($posts as $post) {\n        $this->assertModelMissing($post);\n    }\n});\n```\n\nTo pass an array of data into an action, use the data parameter:\n\n`data````\nuse function Pest\\Livewire\\livewire;\n\nit('can edit posts', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableAction(EditAction::class, $post, data: [\n            'title' => $title = fake()->words(asText: true),\n        ])\n        ->assertHasNoTableActionErrors();\n\n    expect($post->refresh())\n        ->title->toBe($title);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Execution",
                "content": "To check if an action or bulk action has been halted, you can use assertTableActionHalted() / assertTableBulkActionHalted():\n\n`assertTableActionHalted()``assertTableBulkActionHalted()````\nuse function Pest\\Livewire\\livewire;\n\nit('will halt delete if post is flagged', function () {\n    $posts= Post::factory()->count(2)->flagged()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableAction('delete', $posts->first())\n        ->callTableBulkAction('delete', $posts)\n        ->assertTableActionHalted('delete')\n        ->assertTableBulkActionHalted('delete');\n\n    $this->assertModelExists($post);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Errors",
                "content": "assertHasNoTableActionErrors() is used to assert that no validation errors occurred when submitting the action form.\n\n`assertHasNoTableActionErrors()`To check if a validation error has occurred with the data, use assertHasTableActionErrors(), similar to assertHasErrors() in Livewire:\n\n`assertHasTableActionErrors()``assertHasErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate edited post data', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->callTableAction(EditAction::class, $post, data: [\n            'title' => null,\n        ])\n        ->assertHasTableActionErrors(['title' => ['required']]);\n});\n```\n\nFor bulk actions these methods are called assertHasTableBulkActionErrors() and assertHasNoTableBulkActionErrors().\n\n`assertHasTableBulkActionErrors()``assertHasNoTableBulkActionErrors()`### #Pre-filled data\n\nTo check if an action or bulk action is pre-filled with data, you can use the assertTableActionDataSet() or assertTableBulkActionDataSet() method:\n\n`assertTableActionDataSet()``assertTableBulkActionDataSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can load existing post data for editing', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->mountTableAction(EditAction::class, $post)\n        ->assertTableActionDataSet([\n            'title' => $post->title,\n        ])\n        ->setTableActionData([\n            'title' => $title = fake()->words(asText: true),\n        ])\n        ->callMountedTableAction()\n        ->assertHasNoTableActionErrors();\n\n    expect($post->refresh())\n        ->title->toBe($title);\n});\n```\n\nYou may also find it useful to pass a function to the assertTableActionDataSet() and assertTableBulkActionDataSet() methods, which allow you to access the form $state and perform additional assertions:\n\n`assertTableActionDataSet()``assertTableBulkActionDataSet()``$state````\nuse Illuminate\\Support\\Str;\nuse function Pest\\Livewire\\livewire;\n\nit('can automatically generate a slug from the title without any spaces', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->mountTableAction(EditAction::class, $post)\n        ->assertTableActionDataSet(function (array $state) use ($post): array {\n            expect($state['slug'])\n                ->not->toContain(' ');\n                \n            return [\n                'slug' => Str::slug($post->title),\n            ];\n        });\n});\n```",
                "level": 4
              },
              {
                "title": "### #Action state",
                "content": "To ensure that an action or bulk action exists or doesn’t in a table, you can use the assertTableActionExists() / assertTableActionDoesNotExist() or  assertTableBulkActionExists() / assertTableBulkActionDoesNotExist() method:\n\n`assertTableActionExists()``assertTableActionDoesNotExist()``assertTableBulkActionExists()``assertTableBulkActionDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('can publish but not unpublish posts', function () {\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionExists('publish')\n        ->assertTableActionDoesNotExist('unpublish')\n        ->assertTableBulkActionExists('publish')\n        ->assertTableBulkActionDoesNotExist('unpublish');\n});\n```\n\nTo ensure different sets of actions exist in the correct order, you can use the various “InOrder” assertions\n\n```\nuse function Pest\\Livewire\\livewire;\n\nit('has all actions in expected order', function () {\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionsExistInOrder(['edit', 'delete'])\n        ->assertTableBulkActionsExistInOrder(['restore', 'forceDelete'])\n        ->assertTableHeaderActionsExistInOrder(['create', 'attach'])\n        ->assertTableEmptyStateActionsExistInOrder(['create', 'toggle-trashed-filter'])\n});\n```\n\nTo ensure that an action or bulk action is enabled or disabled for a user, you can use the assertTableActionEnabled() / assertTableActionDisabled() or assertTableBulkActionEnabled() / assertTableBulkActionDisabled() methods:\n\n`assertTableActionEnabled()``assertTableActionDisabled()``assertTableBulkActionEnabled()``assertTableBulkActionDisabled()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not publish, but can delete posts', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionDisabled('publish', $post)\n        ->assertTableActionEnabled('delete', $post)\n        ->assertTableBulkActionDisabled('publish')\n        ->assertTableBulkActionEnabled('delete');\n});\n```\n\nTo ensure that an action or bulk action is visible or hidden for a user, you can use the assertTableActionVisible() / assertTableActionHidden() or assertTableBulkActionVisible() / assertTableBulkActionHidden() methods:\n\n`assertTableActionVisible()``assertTableActionHidden()``assertTableBulkActionVisible()``assertTableBulkActionHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not publish, but can delete posts', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionHidden('publish', $post)\n        ->assertTableActionVisible('delete', $post)\n        ->assertTableBulkActionHidden('publish')\n        ->assertTableBulkActionVisible('delete');\n});\n```",
                "level": 4
              },
              {
                "title": "### #Button Style",
                "content": "To ensure an action or bulk action has the correct label, you can use assertTableActionHasLabel() / assertTableBulkActionHasLabel() and assertTableActionDoesNotHaveLabel() / assertTableBulkActionDoesNotHaveLabel():\n\n`assertTableActionHasLabel()``assertTableBulkActionHasLabel()``assertTableActionDoesNotHaveLabel()``assertTableBulkActionDoesNotHaveLabel()````\nuse function Pest\\Livewire\\livewire;\n\nit('delete actions have correct labels', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionHasLabel('delete', 'Archive Post', $post)\n        ->assertTableActionDoesNotHaveLabel('delete', 'Delete', $post);\n        ->assertTableBulkActionHasLabel('delete', 'Archive Post', $post)\n        ->assertTableBulkActionDoesNotHaveLabel('delete', 'Delete', $post);\n});\n```\n\nTo ensure an action or bulk action’s button is showing the correct icon, you can use assertTableActionHasIcon() / assertTableBulkActionHasIcon() or assertTableActionDoesNotHaveIcon() / assertTableBulkActionDoesNotHaveIcon():\n\n`assertTableActionHasIcon()``assertTableBulkActionHasIcon()``assertTableActionDoesNotHaveIcon()``assertTableBulkActionDoesNotHaveIcon()````\nuse function Pest\\Livewire\\livewire;\n\nit('delete actions have correct icons', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionHasIcon('delete', 'heroicon-m-archive-box', $post)\n        ->assertTableActionDoesNotHaveIcon('delete', 'heroicon-m-trash', $post);\n        ->assertTableBulkActionHasIcon('delete', 'heroicon-m-archive-box', $post)\n        ->assertTableBulkActionDoesNotHaveIcon('delete', 'heroicon-m-trash', $post);\n});\n```\n\nTo ensure that an action or bulk action’s button is displaying the right color, you can use assertTableActionHasColor() / assertTableBulkActionHasColor() or assertTableActionDoesNotHaveColor() / assertTableBulkActionDoesNotHaveColor():\n\n`assertTableActionHasColor()``assertTableBulkActionHasColor()``assertTableActionDoesNotHaveColor()``assertTableBulkActionDoesNotHaveColor()````\nuse function Pest\\Livewire\\livewire;\n\nit('delete actions have correct colors', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionHasColor('delete', 'warning', $post)\n        ->assertTableActionDoesNotHaveColor('delete', 'danger', $post);\n        ->assertTableBulkActionHasColor('delete', 'warning', $post)\n        ->assertTableBulkActionDoesNotHaveColor('delete', 'danger', $post);\n});\n```",
                "level": 4
              },
              {
                "title": "### #URL",
                "content": "To ensure an action or bulk action has the correct URL traits, you can use assertTableActionHasUrl(), assertTableActionDoesNotHaveUrl(), assertTableActionShouldOpenUrlInNewTab(), and assertTableActionShouldNotOpenUrlInNewTab():\n\n`assertTableActionHasUrl()``assertTableActionDoesNotHaveUrl()``assertTableActionShouldOpenUrlInNewTab()``assertTableActionShouldNotOpenUrlInNewTab()````\nuse function Pest\\Livewire\\livewire;\n\nit('links to the correct Filament sites', function () {\n    $post = Post::factory()->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertTableActionHasUrl('filament', 'https://filamentphp.com/', $post)\n        ->assertTableActionDoesNotHaveUrl('filament', 'https://github.com/filamentphp/filament', $post)\n        ->assertTableActionShouldOpenUrlInNewTab('filament', $post)\n        ->assertTableActionShouldNotOpenUrlInNewTab('github', $post);\n});\n```",
                "level": 4
              },
              {
                "title": "## #Summaries",
                "content": "To test that a summary calculation is working, you may use the assertTableColumnSummarySet() method:\n\n`assertTableColumnSummarySet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can average values in a column', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts)\n        ->assertTableColumnSummarySet('rating', 'average', $posts->avg('rating'));\n});\n```\n\nThe first argument is the column name, the second is the summarizer ID, and the third is the expected value.\n\nNote that the expected and actual values are normalized, such that 123.12 is considered the same as \"123.12\", and ['Fred', 'Jim'] is the same as ['Jim', 'Fred'].\n\n`123.12``\"123.12\"``['Fred', 'Jim']``['Jim', 'Fred']`You may set a summarizer ID by passing it to the make() method:\n\n`make()````\nuse Filament\\Tables\\Columns\\Summarizers\\Average;\nuse Filament\\Tables\\Columns\\TextColumn;\n\nTextColumn::make('rating')\n    ->summarize(Average::make('average'))\n```\n\nThe ID should be unique between summarizers in that column.",
                "level": 3
              },
              {
                "title": "### #Summarizing only one pagination page",
                "content": "To calculate the average for only one pagination page, use the isCurrentPaginationPageOnly argument:\n\n`isCurrentPaginationPageOnly````\nuse function Pest\\Livewire\\livewire;\n\nit('can average values in a column', function () {\n    $posts = Post::factory()->count(20)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts->take(10))\n        ->assertTableColumnSummarySet('rating', 'average', $posts->take(10)->avg('rating'), isCurrentPaginationPageOnly: true);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Testing a range summarizer",
                "content": "To test a range, pass the minimum and maximum value into a tuple-style [$minimum, $maximum] array:\n\n`[$minimum, $maximum]````\nuse function Pest\\Livewire\\livewire;\n\nit('can average values in a column', function () {\n    $posts = Post::factory()->count(10)->create();\n\n    livewire(PostResource\\Pages\\ListPosts::class)\n        ->assertCanSeeTableRecords($posts)\n        ->assertTableColumnSummarySet('rating', 'range', [$posts->min('rating'), $posts->max('rating')]);\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Render",
              "Sorting",
              "Searching",
              "State",
              "Existence",
              "Authorization",
              "Descriptions",
              "Extra Attributes",
              "Select Columns"
            ],
            "code_examples_count": 86,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "upgrading": {
          "metadata": {
            "title": "Upgrading",
            "url": "https://filamentphp.com/docs/3.x/tables/upgrading",
            "section": "tables",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        }
      }
    },
    "forms": {
      "section_info": {
        "name": "forms",
        "page_count": 10,
        "description": "Dynamic form builder with validation and field components"
      },
      "pages": {
        "installation": {
          "metadata": {
            "title": "Installation",
            "url": "https://filamentphp.com/docs/3.x/forms/installation",
            "section": "forms",
            "word_count": 677,
            "character_count": 5610
          },
          "content": {
            "full_text": "\n# Installation - Forms - Filament\n\nForms\n\n# Installation\n\nThe Form Builder package is pre-installed with the Panel Builder. This guide is for using the Form Builder in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)\n\n## #Installation\n\nRequire the Form Builder package using Composer:\n\n```\ncomposer require filament/forms:\"^3.3\" -W\n```\n\n## #New Laravel projects\n\nTo quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --forms\n\nnpm install\n\nnpm run dev\n```\n\n## #Existing Laravel projects\n\nRun the following command to install the Form Builder assets:\n\n```\nphp artisan filament:install --forms\n```\n\n### #Installing Tailwind CSS\n\n> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```\n\n### #Configuring styles\n\nAdd Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```\n\n### #Automatically refreshing the browser\n\nYou may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```\n\n### #Compiling assets\n\nCompile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```\n\n## #Publishing configuration\n\nYou can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Forms - Filament",
                "content": "Forms",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "The Form Builder package is pre-installed with the Panel Builder. This guide is for using the Form Builder in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "Require the Form Builder package using Composer:\n\n```\ncomposer require filament/forms:\"^3.3\" -W\n```",
                "level": 3
              },
              {
                "title": "## #New Laravel projects",
                "content": "To quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --forms\n\nnpm install\n\nnpm run dev\n```",
                "level": 3
              },
              {
                "title": "## #Existing Laravel projects",
                "content": "Run the following command to install the Form Builder assets:\n\n```\nphp artisan filament:install --forms\n```",
                "level": 3
              },
              {
                "title": "### #Installing Tailwind CSS",
                "content": "> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```",
                "level": 4
              },
              {
                "title": "### #Configuring styles",
                "content": "Add Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```",
                "level": 4
              },
              {
                "title": "### #Automatically refreshing the browser",
                "content": "You may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```",
                "level": 4
              },
              {
                "title": "### #Compiling assets",
                "content": "Compile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```",
                "level": 4
              },
              {
                "title": "## #Publishing configuration",
                "content": "You can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "New Laravel projects",
              "Existing Laravel projects",
              "Installing Tailwind CSS",
              "Configuring styles",
              "Automatically refreshing the browser",
              "Compiling assets",
              "Publishing configuration",
              "Upgrading"
            ],
            "code_examples_count": 24,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "getting-started": {
          "metadata": {
            "title": "Getting Started",
            "url": "https://filamentphp.com/docs/3.x/forms/getting-started",
            "section": "forms",
            "word_count": 1181,
            "character_count": 9221
          },
          "content": {
            "full_text": "\n# Getting started - Forms - Filament\n\nForms\n\n# Getting started\n\n## #Overview\n\nFilament’s form package allows you to easily build dynamic forms in your app. You can use it to add a form to any Livewire component. Additionally, it’s used within other Filament packages to render forms within app resources, action modals, table filters, and more. Learning how to build forms is essential to learning how to use these Filament packages.\n\nThis guide will walk you through the basics of building forms with Filament’s form package. If you’re planning to add a new form to your own Livewire component, you should do that first and then come back. If you’re adding a form to an app resource, or another Filament package, you’re ready to go!\n\n## #Form schemas\n\nAll Filament forms have a “schema”. This is an array, which contains fields and layout components.\n\nFields are the inputs that your user will fill their data into. For example, HTML’s <input> or <select> elements. Each field has its own PHP class. For example, the TextInput class is used to render a text input field, and the Select class is used to render a select field. You can see a full list of available fields here.\n\n`<input>``<select>``TextInput``Select`Layout components are used to group fields together, and to control how they are displayed. For example, you can use a Grid component to display multiple fields side-by-side, or a Wizard to separate fields into a multistep form. You can deeply nest layout components within each other to create very complex responsive UIs. You can see a full list of available layout components here.\n\n`Grid``Wizard`### #Adding fields to a form schema\n\nInitialise a field or layout component with the make() method, and build a schema array with multiple fields:\n\n`make()````\nuse Filament\\Forms\\Components\\RichEditor;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Form;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            TextInput::make('title'),\n            TextInput::make('slug'),\n            RichEditor::make('content'),\n        ]);\n}\n```\n\nForms within a panel and other packages usually have 2 columns by default. For custom forms, you can use the columns() method to achieve the same effect:\n\n`columns()````\n$form\n    ->schema([\n        // ...\n    ])\n    ->columns(2);\n```\n\nNow, the RichEditor will only consume half of the available width. We can use the columnSpan() method to make it span the full width:\n\n`RichEditor``columnSpan()````\nuse Filament\\Forms\\Components\\RichEditor;\nuse Filament\\Forms\\Components\\TextInput;\n\n[\n    TextInput::make('title'),\n    TextInput::make('slug'),\n    RichEditor::make('content')\n        ->columnSpan(2), // or `columnSpan('full')`\n]\n```\n\nYou can learn more about columns and spans in the layout documentation. You can even make them responsive!\n\n### #Adding layout components to a form schema\n\nLet’s add a new Section to our form. Section is a layout component, and it allows you to add a heading and description to a set of fields. It can also allow fields inside it to collapse, which saves space in long forms.\n\n`Section``Section````\nuse Filament\\Forms\\Components\\RichEditor;\nuse Filament\\Forms\\Components\\Section;\nuse Filament\\Forms\\Components\\TextInput;\n\n[\n    TextInput::make('title'),\n    TextInput::make('slug'),\n    RichEditor::make('content')\n        ->columnSpan(2),\n    Section::make('Publishing')\n        ->description('Settings for publishing this post.')\n        ->schema([\n            // ...\n        ]),\n]\n```\n\nIn this example, you can see how the Section component has its own schema() method. You can use this to nest other fields and layout components inside:\n\n`Section``schema()````\nuse Filament\\Forms\\Components\\DateTimePicker;\nuse Filament\\Forms\\Components\\Section;\nuse Filament\\Forms\\Components\\Select;\n\nSection::make('Publishing')\n    ->description('Settings for publishing this post.')\n    ->schema([\n        Select::make('status')\n            ->options([\n                'draft' => 'Draft',\n                'reviewing' => 'Reviewing',\n                'published' => 'Published',\n            ]),\n        DateTimePicker::make('published_at'),\n    ])\n```\n\nThis section now contains a Select field and a DateTimePicker field. You can learn more about those fields and their functionalities on the respective docs pages.\n\n`Select``DateTimePicker`## #Validating fields\n\nIn Laravel, validation rules are usually defined in arrays like ['required', 'max:255'] or a combined string like required|max:255. This is fine if you’re exclusively working in the backend with simple form requests. But Filament is also able to give your users frontend validation, so they can fix their mistakes before any backend requests are made.\n\n`['required', 'max:255']``required|max:255`In Filament, you can add validation rules to your fields by using methods like required() and maxLength(). This is also advantageous over Laravel’s validation syntax, since your IDE can autocomplete these methods:\n\n`required()``maxLength()````\nuse Filament\\Forms\\Components\\DateTimePicker;\nuse Filament\\Forms\\Components\\RichEditor;\nuse Filament\\Forms\\Components\\Section;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Forms\\Components\\TextInput;\n\n[\n    TextInput::make('title')\n        ->required()\n        ->maxLength(255),\n    TextInput::make('slug')\n        ->required()\n        ->maxLength(255),\n    RichEditor::make('content')\n        ->columnSpan(2)\n        ->maxLength(65535),\n    Section::make('Publishing')\n        ->description('Settings for publishing this post.')\n        ->schema([\n            Select::make('status')\n                ->options([\n                    'draft' => 'Draft',\n                    'reviewing' => 'Reviewing',\n                    'published' => 'Published',\n                ])\n                ->required(),\n            DateTimePicker::make('published_at'),\n        ]),\n]\n```\n\nIn this example, some fields are required(), and some have a maxLength(). We have methods for most of Laravel’s validation rules, and you can even add your own custom rules.\n\n`required()``maxLength()`## #Dependant fields\n\nSince all Filament forms are built on top of Livewire, form schemas are completely dynamic. There are so many possibilities, but here are a couple of examples of how you can use this to your advantage:\n\nFields can hide or show based on another field’s values. In our form, we can hide the published_at timestamp field until the status field is set to published. This is done by passing a closure to the hidden() method, which allows you to dynamically hide or show a field while the form is being used. Closures have access to many useful arguments like $get, and you can find a full list here. The field that you depend on (the status in this case) needs to be set to live(), which tells the form to reload the schema each time it gets changed.\n\n`published_at``status``published``hidden()``$get``status``live()````\nuse Filament\\Forms\\Components\\DateTimePicker;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Forms\\Get;\n\n[\n    Select::make('status')\n        ->options([\n            'draft' => 'Draft',\n            'reviewing' => 'Reviewing',\n            'published' => 'Published',\n        ])\n        ->required()\n        ->live(),\n    DateTimePicker::make('published_at')\n        ->hidden(fn (Get $get) => $get('status') !== 'published'),\n]\n```\n\nIt’s not just hidden() - all Filament form methods support closures like this. You can use them to change the label, placeholder, or even the options of a field, based on another. You can even use them to add new fields to the form, or remove them. This is a powerful tool that allows you to create complex forms with minimal effort.\n\n`hidden()`Fields can also write data to other fields. For example, we can set the title to automatically generate a slug when the title is changed. This is done by passing a closure to the afterStateUpdated() method, which gets run each time the title is changed. This closure has access to the title ($state) and a function ($set) to set the slug field’s state. You can find a full list of closure arguments here. The field that you depend on (the title in this case) needs to be set to live(), which tells the form to reload and set the slug each time it gets changed.\n\n`afterStateUpdated()``$state``$set``title``live()````\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Set;\nuse Illuminate\\Support\\Str;\n\n[\n    TextInput::make('title')\n        ->required()\n        ->maxLength(255)\n        ->live()\n        ->afterStateUpdated(function (Set $set, $state) {\n            $set('slug', Str::slug($state));\n        }),\n    TextInput::make('slug')\n        ->required()\n        ->maxLength(255),\n]\n```\n\n## #Next steps with the forms package\n\nNow you’ve finished reading this guide, where to next? Here are some suggestions:\n\n- Explore the available fields to collect input from your users.\n- Check out the list of layout components to craft intuitive form structures with.\n- Find out about all advanced techniques that you can customize forms to your needs.\n- Write automated tests for your forms using our suite of helper methods.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Forms - Filament",
                "content": "Forms",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament’s form package allows you to easily build dynamic forms in your app. You can use it to add a form to any Livewire component. Additionally, it’s used within other Filament packages to render forms within app resources, action modals, table filters, and more. Learning how to build forms is essential to learning how to use these Filament packages.\n\nThis guide will walk you through the basics of building forms with Filament’s form package. If you’re planning to add a new form to your own Livewire component, you should do that first and then come back. If you’re adding a form to an app resource, or another Filament package, you’re ready to go!",
                "level": 3
              },
              {
                "title": "## #Form schemas",
                "content": "All Filament forms have a “schema”. This is an array, which contains fields and layout components.\n\nFields are the inputs that your user will fill their data into. For example, HTML’s <input> or <select> elements. Each field has its own PHP class. For example, the TextInput class is used to render a text input field, and the Select class is used to render a select field. You can see a full list of available fields here.\n\n`<input>``<select>``TextInput``Select`Layout components are used to group fields together, and to control how they are displayed. For example, you can use a Grid component to display multiple fields side-by-side, or a Wizard to separate fields into a multistep form. You can deeply nest layout components within each other to create very complex responsive UIs. You can see a full list of available layout components here.\n\n`Grid``Wizard`### #Adding fields to a form schema\n\nInitialise a field or layout component with the make() method, and build a schema array with multiple fields:\n\n`make()````\nuse Filament\\Forms\\Components\\RichEditor;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Form;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            TextInput::make('title'),\n            TextInput::make('slug'),\n            RichEditor::make('content'),\n        ]);\n}\n```\n\nForms within a panel and other packages usually have 2 columns by default. For custom forms, you can use the columns() method to achieve the same effect:\n\n`columns()````\n$form\n    ->schema([\n        // ...\n    ])\n    ->columns(2);\n```\n\nNow, the RichEditor will only consume half of the available width. We can use the columnSpan() method to make it span the full width:\n\n`RichEditor``columnSpan()````\nuse Filament\\Forms\\Components\\RichEditor;\nuse Filament\\Forms\\Components\\TextInput;\n\n[\n    TextInput::make('title'),\n    TextInput::make('slug'),\n    RichEditor::make('content')\n        ->columnSpan(2), // or `columnSpan('full')`\n]\n```\n\nYou can learn more about columns and spans in the layout documentation. You can even make them responsive!",
                "level": 3
              },
              {
                "title": "### #Adding layout components to a form schema",
                "content": "Let’s add a new Section to our form. Section is a layout component, and it allows you to add a heading and description to a set of fields. It can also allow fields inside it to collapse, which saves space in long forms.\n\n`Section``Section````\nuse Filament\\Forms\\Components\\RichEditor;\nuse Filament\\Forms\\Components\\Section;\nuse Filament\\Forms\\Components\\TextInput;\n\n[\n    TextInput::make('title'),\n    TextInput::make('slug'),\n    RichEditor::make('content')\n        ->columnSpan(2),\n    Section::make('Publishing')\n        ->description('Settings for publishing this post.')\n        ->schema([\n            // ...\n        ]),\n]\n```\n\nIn this example, you can see how the Section component has its own schema() method. You can use this to nest other fields and layout components inside:\n\n`Section``schema()````\nuse Filament\\Forms\\Components\\DateTimePicker;\nuse Filament\\Forms\\Components\\Section;\nuse Filament\\Forms\\Components\\Select;\n\nSection::make('Publishing')\n    ->description('Settings for publishing this post.')\n    ->schema([\n        Select::make('status')\n            ->options([\n                'draft' => 'Draft',\n                'reviewing' => 'Reviewing',\n                'published' => 'Published',\n            ]),\n        DateTimePicker::make('published_at'),\n    ])\n```\n\nThis section now contains a Select field and a DateTimePicker field. You can learn more about those fields and their functionalities on the respective docs pages.\n\n`Select``DateTimePicker`## #Validating fields\n\nIn Laravel, validation rules are usually defined in arrays like ['required', 'max:255'] or a combined string like required|max:255. This is fine if you’re exclusively working in the backend with simple form requests. But Filament is also able to give your users frontend validation, so they can fix their mistakes before any backend requests are made.\n\n`['required', 'max:255']``required|max:255`In Filament, you can add validation rules to your fields by using methods like required() and maxLength(). This is also advantageous over Laravel’s validation syntax, since your IDE can autocomplete these methods:\n\n`required()``maxLength()````\nuse Filament\\Forms\\Components\\DateTimePicker;\nuse Filament\\Forms\\Components\\RichEditor;\nuse Filament\\Forms\\Components\\Section;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Forms\\Components\\TextInput;\n\n[\n    TextInput::make('title')\n        ->required()\n        ->maxLength(255),\n    TextInput::make('slug')\n        ->required()\n        ->maxLength(255),\n    RichEditor::make('content')\n        ->columnSpan(2)\n        ->maxLength(65535),\n    Section::make('Publishing')\n        ->description('Settings for publishing this post.')\n        ->schema([\n            Select::make('status')\n                ->options([\n                    'draft' => 'Draft',\n                    'reviewing' => 'Reviewing',\n                    'published' => 'Published',\n                ])\n                ->required(),\n            DateTimePicker::make('published_at'),\n        ]),\n]\n```\n\nIn this example, some fields are required(), and some have a maxLength(). We have methods for most of Laravel’s validation rules, and you can even add your own custom rules.\n\n`required()``maxLength()`## #Dependant fields\n\nSince all Filament forms are built on top of Livewire, form schemas are completely dynamic. There are so many possibilities, but here are a couple of examples of how you can use this to your advantage:\n\nFields can hide or show based on another field’s values. In our form, we can hide the published_at timestamp field until the status field is set to published. This is done by passing a closure to the hidden() method, which allows you to dynamically hide or show a field while the form is being used. Closures have access to many useful arguments like $get, and you can find a full list here. The field that you depend on (the status in this case) needs to be set to live(), which tells the form to reload the schema each time it gets changed.\n\n`published_at``status``published``hidden()``$get``status``live()````\nuse Filament\\Forms\\Components\\DateTimePicker;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Forms\\Get;\n\n[\n    Select::make('status')\n        ->options([\n            'draft' => 'Draft',\n            'reviewing' => 'Reviewing',\n            'published' => 'Published',\n        ])\n        ->required()\n        ->live(),\n    DateTimePicker::make('published_at')\n        ->hidden(fn (Get $get) => $get('status') !== 'published'),\n]\n```\n\nIt’s not just hidden() - all Filament form methods support closures like this. You can use them to change the label, placeholder, or even the options of a field, based on another. You can even use them to add new fields to the form, or remove them. This is a powerful tool that allows you to create complex forms with minimal effort.\n\n`hidden()`Fields can also write data to other fields. For example, we can set the title to automatically generate a slug when the title is changed. This is done by passing a closure to the afterStateUpdated() method, which gets run each time the title is changed. This closure has access to the title ($state) and a function ($set) to set the slug field’s state. You can find a full list of closure arguments here. The field that you depend on (the title in this case) needs to be set to live(), which tells the form to reload and set the slug each time it gets changed.\n\n`afterStateUpdated()``$state``$set``title``live()````\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Set;\nuse Illuminate\\Support\\Str;\n\n[\n    TextInput::make('title')\n        ->required()\n        ->maxLength(255)\n        ->live()\n        ->afterStateUpdated(function (Set $set, $state) {\n            $set('slug', Str::slug($state));\n        }),\n    TextInput::make('slug')\n        ->required()\n        ->maxLength(255),\n]\n```",
                "level": 4
              },
              {
                "title": "## #Next steps with the forms package",
                "content": "Now you’ve finished reading this guide, where to next? Here are some suggestions:\n\n- Explore the available fields to collect input from your users.\n- Check out the list of layout components to craft intuitive form structures with.\n- Find out about all advanced techniques that you can customize forms to your needs.\n- Write automated tests for your forms using our suite of helper methods.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Form schemas",
              "Adding layout components to a form schema",
              "Next steps with the forms package"
            ],
            "code_examples_count": 16,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "fields": {
          "metadata": {
            "title": "Fields",
            "url": "https://filamentphp.com/docs/3.x/forms/fields",
            "section": "forms",
            "word_count": 1261,
            "character_count": 10157
          },
          "content": {
            "full_text": "\n# Getting started - Forms - Filament\n\nForms  \n-  Fields\n\n# Getting started\n\n## #Overview\n\nField classes can be found in the Filament\\Form\\Components namespace.\n\n`Filament\\Form\\Components`Fields reside within the schema of your form, alongside any layout components.\n\nFields may be created using the static make() method, passing its unique name. The name of the field should correspond to a property on your Livewire component. You may use “dot notation” to bind fields to keys in arrays.\n\n`make()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n```\n\n## #Available fields\n\nFilament ships with many types of field, suitable for editing different types of data:\n\n- Text input\n- Select\n- Checkbox\n- Toggle\n- Checkbox list\n- Radio\n- Date-time picker\n- File upload\n- Rich editor\n- Markdown editor\n- Repeater\n- Builder\n- Tags input\n- Textarea\n- Key-value\n- Color picker\n- Toggle buttons\n- Hidden\n\nYou may also create your own custom fields to edit data however you wish.\n\n## #Setting a label\n\nBy default, the label of the field will be automatically determined based on its name. To override the field’s label, you may use the label() method. Customizing the label in this way is useful if you wish to use a translation string for localization:\n\n`label()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->label(__('fields.name'))\n```\n\nOptionally, you can have the label automatically translated using Laravel’s localization features with the translateLabel() method:\n\n`translateLabel()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->translateLabel() // Equivalent to `label(__('Name'))`\n```\n\n## #Setting an ID\n\nIn the same way as labels, field IDs are also automatically determined based on their names. To override a field ID, use the id() method:\n\n`id()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->id('name-field')\n```\n\n## #Setting a default value\n\nFields may have a default value. This will be filled if the form’s fill() method is called without any arguments. To define a default value, use the default() method:\n\n`fill()``default()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->default('John')\n```\n\nNote that these defaults are only used when the form is loaded without existing data. Inside panel resources this only works on Create Pages, as Edit Pages will always fill the data from the model.\n\n## #Adding helper text below the field\n\nSometimes, you may wish to provide extra information for the user of the form. For this purpose, you may add helper text below the field.\n\nThe helperText() method is used to add helper text:\n\n`helperText()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->helperText('Your full name here, including any middle names.')\n```\n\nThis method accepts a plain text string, or an instance of Illuminate\\Support\\HtmlString or Illuminate\\Contracts\\Support\\Htmlable. This allows you to render HTML, or even markdown, in the helper text:\n\n`Illuminate\\Support\\HtmlString``Illuminate\\Contracts\\Support\\Htmlable````\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\HtmlString;\n\nTextInput::make('name')\n    ->helperText(new HtmlString('Your <strong>full name</strong> here, including any middle names.'))\n\nTextInput::make('name')\n    ->helperText(str('Your **full name** here, including any middle names.')->inlineMarkdown()->toHtmlString())\n\nTextInput::make('name')\n    ->helperText(view('name-helper-text'))\n```\n\n## #Adding a hint next to the label\n\nAs well as helper text below the field, you may also add a “hint” next to the label of the field. This is useful for displaying additional information about the field, such as a link to a help page.\n\nThe hint() method is used to add a hint:\n\n`hint()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('password')\n    ->hint('Forgotten your password? Bad luck.')\n```\n\nThis method accepts a plain text string, or an instance of Illuminate\\Support\\HtmlString or Illuminate\\Contracts\\Support\\Htmlable. This allows you to render HTML, or even markdown, in the helper text:\n\n`Illuminate\\Support\\HtmlString``Illuminate\\Contracts\\Support\\Htmlable````\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\HtmlString;\n\nTextInput::make('password')\n    ->hint(new HtmlString('<a href=\"/forgotten-password\">Forgotten your password?</a>'))\n\nTextInput::make('password')\n    ->hint(str('[Forgotten your password?](/forgotten-password)')->inlineMarkdown()->toHtmlString())\n\nTextInput::make('password')\n    ->hint(view('forgotten-password-hint'))\n```\n\n### #Changing the text color of the hint\n\nYou can change the text color of the hint. By default, it’s gray, but you may use danger, info, primary, success and warning:\n\n`danger``info``primary``success``warning````\nuse Filament\\Forms\\Components\\RichEditor;\n\nRichEditor::make('content')\n    ->hint('Translatable')\n    ->hintColor('primary')\n```\n\n### #Adding an icon aside the hint\n\nHints may also have an icon rendered next to them:\n\n```\nuse Filament\\Forms\\Components\\RichEditor;\n\nRichEditor::make('content')\n    ->hint('Translatable')\n    ->hintIcon('heroicon-m-language')\n```\n\n#### #Adding a tooltip to a hint icon\n\nAdditionally, you can add a tooltip to display when you hover over the hint icon, using the tooltip parameter of hintIcon():\n\n`tooltip``hintIcon()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->hintIcon('heroicon-m-question-mark-circle', tooltip: 'Need some more information?')\n```\n\n## #Adding extra HTML attributes\n\nYou can pass extra HTML attributes to the field, which will be merged onto the outer DOM element. Pass an array of attributes to the extraAttributes() method, where the key is the attribute name and the value is the attribute value:\n\n`extraAttributes()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->extraAttributes(['title' => 'Text input'])\n```\n\nSome fields use an underlying <input> or <select> DOM element, but this is often not the outer element in the field, so the extraAttributes() method may not work as you wish. In this case, you may use the extraInputAttributes() method, which will merge the attributes onto the <input> or <select> element:\n\n`<input>``<select>``extraAttributes()``extraInputAttributes()``<input>``<select>````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('categories')\n    ->extraInputAttributes(['width' => 200])\n```\n\nYou can also pass extra HTML attributes to the field wrapper which surrounds the label, entry, and any other text:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('categories')\n    ->extraFieldWrapperAttributes(['class' => 'components-locked'])\n```\n\n## #Disabling a field\n\nYou may disable a field to prevent it from being edited by the user:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->disabled()\n```\n\nOptionally, you may pass a boolean value to control if the field should be disabled or not:\n\n```\nuse Filament\\Forms\\Components\\Toggle;\n\nToggle::make('is_admin')\n    ->disabled(! auth()->user()->isAdmin())\n```\n\nDisabling a field will prevent it from being saved. If you’d like it to be saved, but still not editable, use the dehydrated() method:\n\n`dehydrated()````\nToggle::make('is_admin')\n    ->disabled()\n    ->dehydrated()\n```\n\n> If you choose to dehydrate the field, a skilled user could still edit the field’s value by manipulating Livewire’s JavaScript.\n\nIf you choose to dehydrate the field, a skilled user could still edit the field’s value by manipulating Livewire’s JavaScript.\n\n### #Hiding a field\n\nYou may hide a field:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n   ->hidden()\n```\n\nOptionally, you may pass a boolean value to control if the field should be hidden or not:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n   ->hidden(! auth()->user()->isAdmin())\n```\n\n## #Autofocusing a field when the form is loaded\n\nMost fields are autofocusable. Typically, you should aim for the first significant field in your form to be autofocused for the best user experience. You can nominate a field to be autofocused using the autofocus() method:\n\n`autofocus()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->autofocus()\n```\n\n## #Setting a placeholder\n\nMany fields will also include a placeholder value for when it has no value. This is displayed in the UI but not saved if the field is submitted with no value. You may customize this placeholder using the placeholder() method:\n\n`placeholder()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->placeholder('John Doe')\n```\n\n## #Marking a field as required\n\nBy default, required fields will show an asterisk * next to their label. You may want to hide the asterisk on forms where all fields are required, or where it makes sense to add a hint to optional fields instead:\n\n`*````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->required() // Adds validation to ensure the field is required\n    ->markAsRequired(false) // Removes the asterisk\n```\n\nIf your field is not required(), but you still wish to show an asterisk * you can use markAsRequired() too:\n\n`required()``*``markAsRequired()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->markAsRequired()\n```\n\n## #Global settings\n\nIf you wish to change the default behavior of a field globally, then you can call the static configureUsing() method inside a service provider’s boot() method or a middleware. Pass a closure which is able to modify the component. For example, if you wish to make all checkboxes inline(false), you can do it like so:\n\n`configureUsing()``boot()``inline(false)````\nuse Filament\\Forms\\Components\\Checkbox;\n\nCheckbox::configureUsing(function (Checkbox $checkbox): void {\n    $checkbox->inline(false);\n});\n```\n\nOf course, you are still able to overwrite this behavior on each field individually:\n\n```\nuse Filament\\Forms\\Components\\Checkbox;\n\nCheckbox::make('is_admin')\n    ->inline()\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Forms - Filament",
                "content": "Forms  \n-  Fields",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Field classes can be found in the Filament\\Form\\Components namespace.\n\n`Filament\\Form\\Components`Fields reside within the schema of your form, alongside any layout components.\n\nFields may be created using the static make() method, passing its unique name. The name of the field should correspond to a property on your Livewire component. You may use “dot notation” to bind fields to keys in arrays.\n\n`make()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n```",
                "level": 3
              },
              {
                "title": "## #Available fields",
                "content": "Filament ships with many types of field, suitable for editing different types of data:\n\n- Text input\n- Select\n- Checkbox\n- Toggle\n- Checkbox list\n- Radio\n- Date-time picker\n- File upload\n- Rich editor\n- Markdown editor\n- Repeater\n- Builder\n- Tags input\n- Textarea\n- Key-value\n- Color picker\n- Toggle buttons\n- Hidden\n\nYou may also create your own custom fields to edit data however you wish.",
                "level": 3
              },
              {
                "title": "## #Setting a label",
                "content": "By default, the label of the field will be automatically determined based on its name. To override the field’s label, you may use the label() method. Customizing the label in this way is useful if you wish to use a translation string for localization:\n\n`label()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->label(__('fields.name'))\n```\n\nOptionally, you can have the label automatically translated using Laravel’s localization features with the translateLabel() method:\n\n`translateLabel()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->translateLabel() // Equivalent to `label(__('Name'))`\n```",
                "level": 3
              },
              {
                "title": "## #Setting an ID",
                "content": "In the same way as labels, field IDs are also automatically determined based on their names. To override a field ID, use the id() method:\n\n`id()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->id('name-field')\n```",
                "level": 3
              },
              {
                "title": "## #Setting a default value",
                "content": "Fields may have a default value. This will be filled if the form’s fill() method is called without any arguments. To define a default value, use the default() method:\n\n`fill()``default()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->default('John')\n```\n\nNote that these defaults are only used when the form is loaded without existing data. Inside panel resources this only works on Create Pages, as Edit Pages will always fill the data from the model.",
                "level": 3
              },
              {
                "title": "## #Adding helper text below the field",
                "content": "Sometimes, you may wish to provide extra information for the user of the form. For this purpose, you may add helper text below the field.\n\nThe helperText() method is used to add helper text:\n\n`helperText()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->helperText('Your full name here, including any middle names.')\n```\n\nThis method accepts a plain text string, or an instance of Illuminate\\Support\\HtmlString or Illuminate\\Contracts\\Support\\Htmlable. This allows you to render HTML, or even markdown, in the helper text:\n\n`Illuminate\\Support\\HtmlString``Illuminate\\Contracts\\Support\\Htmlable````\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\HtmlString;\n\nTextInput::make('name')\n    ->helperText(new HtmlString('Your <strong>full name</strong> here, including any middle names.'))\n\nTextInput::make('name')\n    ->helperText(str('Your **full name** here, including any middle names.')->inlineMarkdown()->toHtmlString())\n\nTextInput::make('name')\n    ->helperText(view('name-helper-text'))\n```",
                "level": 3
              },
              {
                "title": "## #Adding a hint next to the label",
                "content": "As well as helper text below the field, you may also add a “hint” next to the label of the field. This is useful for displaying additional information about the field, such as a link to a help page.\n\nThe hint() method is used to add a hint:\n\n`hint()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('password')\n    ->hint('Forgotten your password? Bad luck.')\n```\n\nThis method accepts a plain text string, or an instance of Illuminate\\Support\\HtmlString or Illuminate\\Contracts\\Support\\Htmlable. This allows you to render HTML, or even markdown, in the helper text:\n\n`Illuminate\\Support\\HtmlString``Illuminate\\Contracts\\Support\\Htmlable````\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\HtmlString;\n\nTextInput::make('password')\n    ->hint(new HtmlString('<a href=\"/forgotten-password\">Forgotten your password?</a>'))\n\nTextInput::make('password')\n    ->hint(str('[Forgotten your password?](/forgotten-password)')->inlineMarkdown()->toHtmlString())\n\nTextInput::make('password')\n    ->hint(view('forgotten-password-hint'))\n```",
                "level": 3
              },
              {
                "title": "### #Changing the text color of the hint",
                "content": "You can change the text color of the hint. By default, it’s gray, but you may use danger, info, primary, success and warning:\n\n`danger``info``primary``success``warning````\nuse Filament\\Forms\\Components\\RichEditor;\n\nRichEditor::make('content')\n    ->hint('Translatable')\n    ->hintColor('primary')\n```",
                "level": 4
              },
              {
                "title": "### #Adding an icon aside the hint",
                "content": "Hints may also have an icon rendered next to them:\n\n```\nuse Filament\\Forms\\Components\\RichEditor;\n\nRichEditor::make('content')\n    ->hint('Translatable')\n    ->hintIcon('heroicon-m-language')\n```",
                "level": 4
              },
              {
                "title": "#### #Adding a tooltip to a hint icon",
                "content": "Additionally, you can add a tooltip to display when you hover over the hint icon, using the tooltip parameter of hintIcon():\n\n`tooltip``hintIcon()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->hintIcon('heroicon-m-question-mark-circle', tooltip: 'Need some more information?')\n```",
                "level": 5
              },
              {
                "title": "## #Adding extra HTML attributes",
                "content": "You can pass extra HTML attributes to the field, which will be merged onto the outer DOM element. Pass an array of attributes to the extraAttributes() method, where the key is the attribute name and the value is the attribute value:\n\n`extraAttributes()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->extraAttributes(['title' => 'Text input'])\n```\n\nSome fields use an underlying <input> or <select> DOM element, but this is often not the outer element in the field, so the extraAttributes() method may not work as you wish. In this case, you may use the extraInputAttributes() method, which will merge the attributes onto the <input> or <select> element:\n\n`<input>``<select>``extraAttributes()``extraInputAttributes()``<input>``<select>````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('categories')\n    ->extraInputAttributes(['width' => 200])\n```\n\nYou can also pass extra HTML attributes to the field wrapper which surrounds the label, entry, and any other text:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('categories')\n    ->extraFieldWrapperAttributes(['class' => 'components-locked'])\n```",
                "level": 3
              },
              {
                "title": "## #Disabling a field",
                "content": "You may disable a field to prevent it from being edited by the user:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->disabled()\n```\n\nOptionally, you may pass a boolean value to control if the field should be disabled or not:\n\n```\nuse Filament\\Forms\\Components\\Toggle;\n\nToggle::make('is_admin')\n    ->disabled(! auth()->user()->isAdmin())\n```\n\nDisabling a field will prevent it from being saved. If you’d like it to be saved, but still not editable, use the dehydrated() method:\n\n`dehydrated()````\nToggle::make('is_admin')\n    ->disabled()\n    ->dehydrated()\n```\n\n> If you choose to dehydrate the field, a skilled user could still edit the field’s value by manipulating Livewire’s JavaScript.\n\nIf you choose to dehydrate the field, a skilled user could still edit the field’s value by manipulating Livewire’s JavaScript.",
                "level": 3
              },
              {
                "title": "### #Hiding a field",
                "content": "You may hide a field:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n   ->hidden()\n```\n\nOptionally, you may pass a boolean value to control if the field should be hidden or not:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n   ->hidden(! auth()->user()->isAdmin())\n```",
                "level": 4
              },
              {
                "title": "## #Autofocusing a field when the form is loaded",
                "content": "Most fields are autofocusable. Typically, you should aim for the first significant field in your form to be autofocused for the best user experience. You can nominate a field to be autofocused using the autofocus() method:\n\n`autofocus()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->autofocus()\n```",
                "level": 3
              },
              {
                "title": "## #Setting a placeholder",
                "content": "Many fields will also include a placeholder value for when it has no value. This is displayed in the UI but not saved if the field is submitted with no value. You may customize this placeholder using the placeholder() method:\n\n`placeholder()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->placeholder('John Doe')\n```",
                "level": 3
              },
              {
                "title": "## #Marking a field as required",
                "content": "By default, required fields will show an asterisk * next to their label. You may want to hide the asterisk on forms where all fields are required, or where it makes sense to add a hint to optional fields instead:\n\n`*````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->required() // Adds validation to ensure the field is required\n    ->markAsRequired(false) // Removes the asterisk\n```\n\nIf your field is not required(), but you still wish to show an asterisk * you can use markAsRequired() too:\n\n`required()``*``markAsRequired()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->markAsRequired()\n```",
                "level": 3
              },
              {
                "title": "## #Global settings",
                "content": "If you wish to change the default behavior of a field globally, then you can call the static configureUsing() method inside a service provider’s boot() method or a middleware. Pass a closure which is able to modify the component. For example, if you wish to make all checkboxes inline(false), you can do it like so:\n\n`configureUsing()``boot()``inline(false)````\nuse Filament\\Forms\\Components\\Checkbox;\n\nCheckbox::configureUsing(function (Checkbox $checkbox): void {\n    $checkbox->inline(false);\n});\n```\n\nOf course, you are still able to overwrite this behavior on each field individually:\n\n```\nuse Filament\\Forms\\Components\\Checkbox;\n\nCheckbox::make('is_admin')\n    ->inline()\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Available fields",
              "Setting a label",
              "Setting an ID",
              "Setting a default value",
              "Adding helper text below the field",
              "Adding a hint next to the label",
              "Changing the text color of the hint",
              "Adding an icon aside the hint",
              "Adding extra HTML attributes"
            ],
            "code_examples_count": 52,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "layout": {
          "metadata": {
            "title": "Layout",
            "url": "https://filamentphp.com/docs/3.x/forms/layout",
            "section": "forms",
            "word_count": 335,
            "character_count": 2436
          },
          "content": {
            "full_text": "\n# Getting started - Forms - Filament\n\nForms  \n-  Layout\n\n# Getting started\n\n## #Overview\n\nFilament forms are not limited to just displaying fields. You can also use “layout components” to organize them into an infinitely nestable structure.\n\nLayout component classes can be found in the Filament\\Forms\\Components namespace. They reside within the schema of your form, alongside any fields.\n\n`Filament\\Forms\\Components`Components may be created using the static make() method. Usually, you will then define the child component schema() to display inside:\n\n`make()``schema()````\nuse Filament\\Forms\\Components\\Grid;\n\nGrid::make(2)\n    ->schema([\n        // ...\n    ])\n```\n\n## #Available layout components\n\nFilament ships with some layout components, suitable for arranging your form fields depending on your needs:\n\n- Grid\n- Fieldset\n- Tabs\n- Wizard\n- Section\n- Split\n- Placeholder\n\nYou may also create your own custom layout components to organize fields however you wish.\n\n## #Setting an ID\n\nYou may define an ID for the component using the id() method:\n\n`id()````\nuse Filament\\Forms\\Components\\Section;\n\nSection::make()\n    ->id('main-section')\n```\n\n## #Adding extra HTML attributes\n\nYou can pass extra HTML attributes to the component, which will be merged onto the outer DOM element. Pass an array of attributes to the extraAttributes() method, where the key is the attribute name and the value is the attribute value:\n\n`extraAttributes()````\nuse Filament\\Forms\\Components\\Section;\n\nSection::make()\n    ->extraAttributes(['class' => 'custom-section-style'])\n```\n\nClasses will be merged with the default classes, and any other attributes will override the default attributes.\n\n## #Global settings\n\nIf you wish to change the default behavior of a component globally, then you can call the static configureUsing() method inside a service provider’s boot() method, to which you pass a Closure to modify the component using. For example, if you wish to make all section components have 2 columns by default, you can do it like so:\n\n`configureUsing()``boot()````\nuse Filament\\Forms\\Components\\Section;\n\nSection::configureUsing(function (Section $section): void {\n    $section\n        ->columns(2);\n});\n```\n\nOf course, you are still able to overwrite this on each field individually:\n\n```\nuse Filament\\Forms\\Components\\Section;\n\nSection::make()\n    ->columns(1)\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Forms - Filament",
                "content": "Forms  \n-  Layout",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament forms are not limited to just displaying fields. You can also use “layout components” to organize them into an infinitely nestable structure.\n\nLayout component classes can be found in the Filament\\Forms\\Components namespace. They reside within the schema of your form, alongside any fields.\n\n`Filament\\Forms\\Components`Components may be created using the static make() method. Usually, you will then define the child component schema() to display inside:\n\n`make()``schema()````\nuse Filament\\Forms\\Components\\Grid;\n\nGrid::make(2)\n    ->schema([\n        // ...\n    ])\n```",
                "level": 3
              },
              {
                "title": "## #Available layout components",
                "content": "Filament ships with some layout components, suitable for arranging your form fields depending on your needs:\n\n- Grid\n- Fieldset\n- Tabs\n- Wizard\n- Section\n- Split\n- Placeholder\n\nYou may also create your own custom layout components to organize fields however you wish.",
                "level": 3
              },
              {
                "title": "## #Setting an ID",
                "content": "You may define an ID for the component using the id() method:\n\n`id()````\nuse Filament\\Forms\\Components\\Section;\n\nSection::make()\n    ->id('main-section')\n```",
                "level": 3
              },
              {
                "title": "## #Adding extra HTML attributes",
                "content": "You can pass extra HTML attributes to the component, which will be merged onto the outer DOM element. Pass an array of attributes to the extraAttributes() method, where the key is the attribute name and the value is the attribute value:\n\n`extraAttributes()````\nuse Filament\\Forms\\Components\\Section;\n\nSection::make()\n    ->extraAttributes(['class' => 'custom-section-style'])\n```\n\nClasses will be merged with the default classes, and any other attributes will override the default attributes.",
                "level": 3
              },
              {
                "title": "## #Global settings",
                "content": "If you wish to change the default behavior of a component globally, then you can call the static configureUsing() method inside a service provider’s boot() method, to which you pass a Closure to modify the component using. For example, if you wish to make all section components have 2 columns by default, you can do it like so:\n\n`configureUsing()``boot()````\nuse Filament\\Forms\\Components\\Section;\n\nSection::configureUsing(function (Section $section): void {\n    $section\n        ->columns(2);\n});\n```\n\nOf course, you are still able to overwrite this on each field individually:\n\n```\nuse Filament\\Forms\\Components\\Section;\n\nSection::make()\n    ->columns(1)\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Available layout components",
              "Setting an ID",
              "Adding extra HTML attributes",
              "Global settings"
            ],
            "code_examples_count": 10,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "validation": {
          "metadata": {
            "title": "Validation",
            "url": "https://filamentphp.com/docs/3.x/forms/validation",
            "section": "forms",
            "word_count": 1870,
            "character_count": 14800
          },
          "content": {
            "full_text": "\n# Validation - Forms - Filament\n\nForms\n\n# Validation\n\n## #Overview\n\nValidation rules may be added to any field.\n\nIn Laravel, validation rules are usually defined in arrays like ['required', 'max:255'] or a combined string like required|max:255. This is fine if you’re exclusively working in the backend with simple form requests. But Filament is also able to give your users frontend validation, so they can fix their mistakes before any backend requests are made.\n\n`['required', 'max:255']``required|max:255`Filament includes several dedicated validation methods, but you can also use any other Laravel validation rules, including custom validation rules.\n\n> Beware that some validations rely on the field name and therefore won’t work when passed via ->rule()/->rules(). Use the dedicated validation methods whenever you can.\n\nBeware that some validations rely on the field name and therefore won’t work when passed via ->rule()/->rules(). Use the dedicated validation methods whenever you can.\n\n`->rule()``->rules()`## #Available rules\n\n### #Active URL\n\nThe field must have a valid A or AAAA record according to the dns_get_record() PHP function. See the Laravel documentation.\n\n`dns_get_record()````\nField::make('name')->activeUrl()\n```\n\n### #After (date)\n\nThe field value must be a value after a given date. See the Laravel documentation.\n\n```\nField::make('start_date')->after('tomorrow')\n```\n\nAlternatively, you may pass the name of another field to compare against:\n\n```\nField::make('start_date')\nField::make('end_date')->after('start_date')\n```\n\n### #After or equal to (date)\n\nThe field value must be a date after or equal to the given date. See the Laravel documentation.\n\n```\nField::make('start_date')->afterOrEqual('tomorrow')\n```\n\nAlternatively, you may pass the name of another field to compare against:\n\n```\nField::make('start_date')\nField::make('end_date')->afterOrEqual('start_date')\n```\n\n### #Alpha\n\nThe field must be entirely alphabetic characters. See the Laravel documentation.\n\n```\nField::make('name')->alpha()\n```\n\n### #Alpha Dash\n\nThe field may have alphanumeric characters, as well as dashes and underscores. See the Laravel documentation.\n\n```\nField::make('name')->alphaDash()\n```\n\n### #Alpha Numeric\n\nThe field must be entirely alphanumeric characters. See the Laravel documentation.\n\n```\nField::make('name')->alphaNum()\n```\n\n### #ASCII\n\nThe field must be entirely 7-bit ASCII characters. See the Laravel documentation.\n\n```\nField::make('name')->ascii()\n```\n\n### #Before (date)\n\nThe field value must be a date before a given date. See the Laravel documentation.\n\n```\nField::make('start_date')->before('first day of next month')\n```\n\nAlternatively, you may pass the name of another field to compare against:\n\n```\nField::make('start_date')->before('end_date')\nField::make('end_date')\n```\n\n### #Before or equal to (date)\n\nThe field value must be a date before or equal to the given date. See the Laravel documentation.\n\n```\nField::make('start_date')->beforeOrEqual('end of this month')\n```\n\nAlternatively, you may pass the name of another field to compare against:\n\n```\nField::make('start_date')->beforeOrEqual('end_date')\nField::make('end_date')\n```\n\n### #Confirmed\n\nThe field must have a matching field of {field}_confirmation. See the Laravel documentation.\n\n`{field}_confirmation````\nField::make('password')->confirmed()\nField::make('password_confirmation')\n```\n\n### #Different\n\nThe field value must be different to another. See the Laravel documentation.\n\n```\nField::make('backup_email')->different('email')\n```\n\n### #Doesnt Start With\n\nThe field must not start with one of the given values. See the Laravel documentation.\n\n```\nField::make('name')->doesntStartWith(['admin'])\n```\n\n### #Doesnt End With\n\nThe field must not end with one of the given values. See the Laravel documentation.\n\n```\nField::make('name')->doesntEndWith(['admin'])\n```\n\n### #Ends With\n\nThe field must end with one of the given values. See the Laravel documentation.\n\n```\nField::make('name')->endsWith(['bot'])\n```\n\n### #Enum\n\nThe field must contain a valid enum value. See the Laravel documentation.\n\n```\nField::make('status')->enum(MyStatus::class)\n```\n\n### #Exists\n\nThe field value must exist in the database. See the Laravel documentation.\n\n```\nField::make('invitation')->exists()\n```\n\nBy default, the form’s model will be searched, if it is registered. You may specify a custom table name or model to search:\n\n```\nuse App\\Models\\Invitation;\n\nField::make('invitation')->exists(table: Invitation::class)\n```\n\nBy default, the field name will be used as the column to search. You may specify a custom column to search:\n\n```\nField::make('invitation')->exists(column: 'id')\n```\n\nYou can further customize the rule by passing a closure to the modifyRuleUsing parameter:\n\n`modifyRuleUsing````\nuse Illuminate\\Validation\\Rules\\Exists;\n\nField::make('invitation')\n    ->exists(modifyRuleUsing: function (Exists $rule) {\n        return $rule->where('is_active', 1);\n    })\n```\n\n### #Filled\n\nThe field must not be empty when it is present. See the Laravel documentation.\n\n```\nField::make('name')->filled()\n```\n\n### #Greater than\n\nThe field value must be greater than another. See the Laravel documentation.\n\n```\nField::make('newNumber')->gt('oldNumber')\n```\n\n### #Greater than or equal to\n\nThe field value must be greater than or equal to another. See the Laravel documentation.\n\n```\nField::make('newNumber')->gte('oldNumber')\n```\n\n### #Hex color\n\nThe field value must be a valid color in hexadecimal format. See the Laravel documentation.\n\n```\nField::make('color')->hexColor()\n```\n\n### #In\n\nThe field must be included in the given list of values. See the Laravel documentation.\n\n```\nField::make('status')->in(['pending', 'completed'])\n```\n\n### #Ip Address\n\nThe field must be an IP address. See the Laravel documentation.\n\n```\nField::make('ip_address')->ip()\nField::make('ip_address')->ipv4()\nField::make('ip_address')->ipv6()\n```\n\n### #JSON\n\nThe field must be a valid JSON string. See the Laravel documentation.\n\n```\nField::make('ip_address')->json()\n```\n\n### #Less than\n\nThe field value must be less than another. See the Laravel documentation.\n\n```\nField::make('newNumber')->lt('oldNumber')\n```\n\n### #Less than or equal to\n\nThe field value must be less than or equal to another. See the Laravel documentation.\n\n```\nField::make('newNumber')->lte('oldNumber')\n```\n\n### #Mac Address\n\nThe field must be a MAC address. See the Laravel documentation.\n\n```\nField::make('mac_address')->macAddress()\n```\n\n### #Multiple Of\n\nThe field must be a multiple of value. See the Laravel documentation.\n\n```\nField::make('number')->multipleOf(2)\n```\n\n### #Not In\n\nThe field must not be included in the given list of values. See the Laravel documentation.\n\n```\nField::make('status')->notIn(['cancelled', 'rejected'])\n```\n\n### #Not Regex\n\nThe field must not match the given regular expression. See the Laravel documentation.\n\n```\nField::make('email')->notRegex('/^.+$/i')\n```\n\n### #Nullable\n\nThe field value can be empty. This rule is applied by default if the required rule is not present. See the Laravel documentation.\n\n`required````\nField::make('name')->nullable()\n```\n\n### #Prohibited\n\nThe field value must be empty. See the Laravel documentation.\n\n```\nField::make('name')->prohibited()\n```\n\n### #Prohibited If\n\nThe field must be empty only if the other specified field has any of the given values. See the Laravel documentation.\n\n```\nField::make('name')->prohibitedIf('field', 'value')\n```\n\n### #Prohibited Unless\n\nThe field must be empty unless the other specified field has any of the given values. See the Laravel documentation.\n\n```\nField::make('name')->prohibitedUnless('field', 'value')\n```\n\n### #Prohibits\n\nIf the field is not empty, all other specified fields must be empty. See the Laravel documentation.\n\n```\nField::make('name')->prohibits('field')\n\nField::make('name')->prohibits(['field', 'another_field'])\n```\n\n### #Required\n\nThe field value must not be empty. See the Laravel documentation.\n\n```\nField::make('name')->required()\n```\n\n### #Required If\n\nThe field value must not be empty only if the other specified field has any of the given values. See the Laravel documentation.\n\n```\nField::make('name')->requiredIf('field', 'value')\n```\n\n### #Required If Accepted\n\nThe field value must not be empty only if the other specified field is equal to “yes”, “on”, 1, “1”, true, or “true”. See the Laravel documentation.\n\n```\nField::make('name')->requiredIfAccepted('field')\n```\n\n### #Required Unless\n\nThe field value must not be empty unless the other specified field has any of the given values. See the Laravel documentation.\n\n```\nField::make('name')->requiredUnless('field', 'value')\n```\n\n### #Required With\n\nThe field value must not be empty only if any of the other specified fields are not empty. See the Laravel documentation.\n\n```\nField::make('name')->requiredWith('field,another_field')\n```\n\n### #Required With All\n\nThe field value must not be empty only if all the other specified fields are not empty. See the Laravel documentation.\n\n```\nField::make('name')->requiredWithAll('field,another_field')\n```\n\n### #Required Without\n\nThe field value must not be empty only when any of the other specified fields are empty. See the Laravel documentation.\n\n```\nField::make('name')->requiredWithout('field,another_field')\n```\n\n### #Required Without All\n\nThe field value must not be empty only when all the other specified fields are empty. See the Laravel documentation.\n\n```\nField::make('name')->requiredWithoutAll('field,another_field')\n```\n\n### #Regex\n\nThe field must match the given regular expression. See the Laravel documentation.\n\n```\nField::make('email')->regex('/^.+@.+$/i')\n```\n\n### #Same\n\nThe field value must be the same as another. See the Laravel documentation.\n\n```\nField::make('password')->same('passwordConfirmation')\n```\n\n### #Starts With\n\nThe field must start with one of the given values. See the Laravel documentation.\n\n```\nField::make('name')->startsWith(['a'])\n```\n\n### #String\n\nThe field must be a string. See the Laravel documentation.\n\n```\nField::make('name')->string()\n```\n\n### #Unique\n\nThe field value must not exist in the database. See the Laravel documentation.\n\n```\nField::make('email')->unique()\n```\n\nBy default, the form’s model will be searched, if it is registered. You may specify a custom table name or model to search:\n\n```\nuse App\\Models\\User;\n\nField::make('email')->unique(table: User::class)\n```\n\nBy default, the field name will be used as the column to search. You may specify a custom column to search:\n\n```\nField::make('email')->unique(column: 'email_address')\n```\n\nSometimes, you may wish to ignore a given model during unique validation. For example, consider an “update profile” form that includes the user’s name, email address, and location. You will probably want to verify that the email address is unique. However, if the user only changes the name field and not the email field, you do not want a validation error to be thrown because the user is already the owner of the email address in question.\n\n```\nField::make('email')->unique(ignorable: $ignoredUser)\n```\n\nIf you’re using the Panel Builder, you can easily ignore the current record by using ignoreRecord instead:\n\n`ignoreRecord````\nField::make('email')->unique(ignoreRecord: true)\n```\n\nYou can further customize the rule by passing a closure to the modifyRuleUsing parameter:\n\n`modifyRuleUsing````\nuse Illuminate\\Validation\\Rules\\Unique;\n\nField::make('email')\n    ->unique(modifyRuleUsing: function (Unique $rule) {\n        return $rule->where('is_active', 1);\n    })\n```\n\n### #ULID\n\nThe field under validation must be a valid Universally Unique Lexicographically Sortable Identifier (ULID). See the Laravel documentation.\n\n```\nField::make('identifier')->ulid()\n```\n\n### #UUID\n\nThe field must be a valid RFC 4122 (version 1, 3, 4, or 5) universally unique identifier (UUID). See the Laravel documentation.\n\n```\nField::make('identifier')->uuid()\n```\n\n## #Other rules\n\nYou may add other validation rules to any field using the rules() method:\n\n`rules()````\nTextInput::make('slug')->rules(['alpha_dash'])\n```\n\nA full list of validation rules may be found in the Laravel documentation.\n\n## #Custom rules\n\nYou may use any custom validation rules as you would do in Laravel:\n\n```\nTextInput::make('slug')->rules([new Uppercase()])\n```\n\nYou may also use closure rules:\n\n```\nuse Closure;\n\nTextInput::make('slug')->rules([\n    fn (): Closure => function (string $attribute, $value, Closure $fail) {\n        if ($value === 'foo') {\n            $fail('The :attribute is invalid.');\n        }\n    },\n])\n```\n\nYou may inject utilities like $get into your custom rules, for example if you need to reference other field values in your form:\n\n`$get````\nuse Closure;\nuse Filament\\Forms\\Get;\n\nTextInput::make('slug')->rules([\n    fn (Get $get): Closure => function (string $attribute, $value, Closure $fail) use ($get) {\n        if ($get('other_field') === 'foo' && $value !== 'bar') {\n            $fail(\"The {$attribute} is invalid.\");\n        }\n    },\n])\n```\n\n## #Customizing validation attributes\n\nWhen fields fail validation, their label is used in the error message. To customize the label used in field error messages, use the validationAttribute() method:\n\n`validationAttribute()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')->validationAttribute('full name')\n```\n\n## #Validation messages\n\nBy default Laravel’s validation error message is used. To customize the error messages, use the validationMessages() method:\n\n`validationMessages()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('email')\n    ->unique(// ...)\n    ->validationMessages([\n        'unique' => 'The :attribute has already been registered.',\n    ])\n```\n\n## #Sending validation notifications\n\nIf you want to send a notification when validation error occurs, you may do so by using the onValidationError() method on your Livewire component:\n\n`onValidationError()````\nuse Filament\\Notifications\\Notification;\nuse Illuminate\\Validation\\ValidationException;\n\nprotected function onValidationError(ValidationException $exception): void\n{\n    Notification::make()\n        ->title($exception->getMessage())\n        ->danger()\n        ->send();\n}\n```\n\nAlternatively, if you are using the Panel Builder and want this behavior on all the pages, add this inside the boot() method of your AppServiceProvider:\n\n`boot()``AppServiceProvider````\nuse Filament\\Notifications\\Notification;\nuse Filament\\Pages\\Page;\nuse Illuminate\\Validation\\ValidationException;\n\nPage::$reportValidationErrorUsing = function (ValidationException $exception) {\n    Notification::make()\n        ->title($exception->getMessage())\n        ->danger()\n        ->send();\n};\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Validation - Forms - Filament",
                "content": "Forms",
                "level": 1
              },
              {
                "title": "# Validation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Validation rules may be added to any field.\n\nIn Laravel, validation rules are usually defined in arrays like ['required', 'max:255'] or a combined string like required|max:255. This is fine if you’re exclusively working in the backend with simple form requests. But Filament is also able to give your users frontend validation, so they can fix their mistakes before any backend requests are made.\n\n`['required', 'max:255']``required|max:255`Filament includes several dedicated validation methods, but you can also use any other Laravel validation rules, including custom validation rules.\n\n> Beware that some validations rely on the field name and therefore won’t work when passed via ->rule()/->rules(). Use the dedicated validation methods whenever you can.\n\nBeware that some validations rely on the field name and therefore won’t work when passed via ->rule()/->rules(). Use the dedicated validation methods whenever you can.\n\n`->rule()``->rules()`## #Available rules",
                "level": 3
              },
              {
                "title": "### #Active URL",
                "content": "The field must have a valid A or AAAA record according to the dns_get_record() PHP function. See the Laravel documentation.\n\n`dns_get_record()````\nField::make('name')->activeUrl()\n```",
                "level": 4
              },
              {
                "title": "### #After (date)",
                "content": "The field value must be a value after a given date. See the Laravel documentation.\n\n```\nField::make('start_date')->after('tomorrow')\n```\n\nAlternatively, you may pass the name of another field to compare against:\n\n```\nField::make('start_date')\nField::make('end_date')->after('start_date')\n```",
                "level": 4
              },
              {
                "title": "### #After or equal to (date)",
                "content": "The field value must be a date after or equal to the given date. See the Laravel documentation.\n\n```\nField::make('start_date')->afterOrEqual('tomorrow')\n```\n\nAlternatively, you may pass the name of another field to compare against:\n\n```\nField::make('start_date')\nField::make('end_date')->afterOrEqual('start_date')\n```",
                "level": 4
              },
              {
                "title": "### #Alpha",
                "content": "The field must be entirely alphabetic characters. See the Laravel documentation.\n\n```\nField::make('name')->alpha()\n```",
                "level": 4
              },
              {
                "title": "### #Alpha Dash",
                "content": "The field may have alphanumeric characters, as well as dashes and underscores. See the Laravel documentation.\n\n```\nField::make('name')->alphaDash()\n```",
                "level": 4
              },
              {
                "title": "### #Alpha Numeric",
                "content": "The field must be entirely alphanumeric characters. See the Laravel documentation.\n\n```\nField::make('name')->alphaNum()\n```",
                "level": 4
              },
              {
                "title": "### #ASCII",
                "content": "The field must be entirely 7-bit ASCII characters. See the Laravel documentation.\n\n```\nField::make('name')->ascii()\n```",
                "level": 4
              },
              {
                "title": "### #Before (date)",
                "content": "The field value must be a date before a given date. See the Laravel documentation.\n\n```\nField::make('start_date')->before('first day of next month')\n```\n\nAlternatively, you may pass the name of another field to compare against:\n\n```\nField::make('start_date')->before('end_date')\nField::make('end_date')\n```",
                "level": 4
              },
              {
                "title": "### #Before or equal to (date)",
                "content": "The field value must be a date before or equal to the given date. See the Laravel documentation.\n\n```\nField::make('start_date')->beforeOrEqual('end of this month')\n```\n\nAlternatively, you may pass the name of another field to compare against:\n\n```\nField::make('start_date')->beforeOrEqual('end_date')\nField::make('end_date')\n```",
                "level": 4
              },
              {
                "title": "### #Confirmed",
                "content": "The field must have a matching field of {field}_confirmation. See the Laravel documentation.\n\n`{field}_confirmation````\nField::make('password')->confirmed()\nField::make('password_confirmation')\n```",
                "level": 4
              },
              {
                "title": "### #Different",
                "content": "The field value must be different to another. See the Laravel documentation.\n\n```\nField::make('backup_email')->different('email')\n```",
                "level": 4
              },
              {
                "title": "### #Doesnt Start With",
                "content": "The field must not start with one of the given values. See the Laravel documentation.\n\n```\nField::make('name')->doesntStartWith(['admin'])\n```",
                "level": 4
              },
              {
                "title": "### #Doesnt End With",
                "content": "The field must not end with one of the given values. See the Laravel documentation.\n\n```\nField::make('name')->doesntEndWith(['admin'])\n```",
                "level": 4
              },
              {
                "title": "### #Ends With",
                "content": "The field must end with one of the given values. See the Laravel documentation.\n\n```\nField::make('name')->endsWith(['bot'])\n```",
                "level": 4
              },
              {
                "title": "### #Enum",
                "content": "The field must contain a valid enum value. See the Laravel documentation.\n\n```\nField::make('status')->enum(MyStatus::class)\n```",
                "level": 4
              },
              {
                "title": "### #Exists",
                "content": "The field value must exist in the database. See the Laravel documentation.\n\n```\nField::make('invitation')->exists()\n```\n\nBy default, the form’s model will be searched, if it is registered. You may specify a custom table name or model to search:\n\n```\nuse App\\Models\\Invitation;\n\nField::make('invitation')->exists(table: Invitation::class)\n```\n\nBy default, the field name will be used as the column to search. You may specify a custom column to search:\n\n```\nField::make('invitation')->exists(column: 'id')\n```\n\nYou can further customize the rule by passing a closure to the modifyRuleUsing parameter:\n\n`modifyRuleUsing````\nuse Illuminate\\Validation\\Rules\\Exists;\n\nField::make('invitation')\n    ->exists(modifyRuleUsing: function (Exists $rule) {\n        return $rule->where('is_active', 1);\n    })\n```",
                "level": 4
              },
              {
                "title": "### #Filled",
                "content": "The field must not be empty when it is present. See the Laravel documentation.\n\n```\nField::make('name')->filled()\n```",
                "level": 4
              },
              {
                "title": "### #Greater than",
                "content": "The field value must be greater than another. See the Laravel documentation.\n\n```\nField::make('newNumber')->gt('oldNumber')\n```",
                "level": 4
              },
              {
                "title": "### #Greater than or equal to",
                "content": "The field value must be greater than or equal to another. See the Laravel documentation.\n\n```\nField::make('newNumber')->gte('oldNumber')\n```",
                "level": 4
              },
              {
                "title": "### #Hex color",
                "content": "The field value must be a valid color in hexadecimal format. See the Laravel documentation.\n\n```\nField::make('color')->hexColor()\n```",
                "level": 4
              },
              {
                "title": "### #In",
                "content": "The field must be included in the given list of values. See the Laravel documentation.\n\n```\nField::make('status')->in(['pending', 'completed'])\n```",
                "level": 4
              },
              {
                "title": "### #Ip Address",
                "content": "The field must be an IP address. See the Laravel documentation.\n\n```\nField::make('ip_address')->ip()\nField::make('ip_address')->ipv4()\nField::make('ip_address')->ipv6()\n```",
                "level": 4
              },
              {
                "title": "### #JSON",
                "content": "The field must be a valid JSON string. See the Laravel documentation.\n\n```\nField::make('ip_address')->json()\n```",
                "level": 4
              },
              {
                "title": "### #Less than",
                "content": "The field value must be less than another. See the Laravel documentation.\n\n```\nField::make('newNumber')->lt('oldNumber')\n```",
                "level": 4
              },
              {
                "title": "### #Less than or equal to",
                "content": "The field value must be less than or equal to another. See the Laravel documentation.\n\n```\nField::make('newNumber')->lte('oldNumber')\n```",
                "level": 4
              },
              {
                "title": "### #Mac Address",
                "content": "The field must be a MAC address. See the Laravel documentation.\n\n```\nField::make('mac_address')->macAddress()\n```",
                "level": 4
              },
              {
                "title": "### #Multiple Of",
                "content": "The field must be a multiple of value. See the Laravel documentation.\n\n```\nField::make('number')->multipleOf(2)\n```",
                "level": 4
              },
              {
                "title": "### #Not In",
                "content": "The field must not be included in the given list of values. See the Laravel documentation.\n\n```\nField::make('status')->notIn(['cancelled', 'rejected'])\n```",
                "level": 4
              },
              {
                "title": "### #Not Regex",
                "content": "The field must not match the given regular expression. See the Laravel documentation.\n\n```\nField::make('email')->notRegex('/^.+$/i')\n```",
                "level": 4
              },
              {
                "title": "### #Nullable",
                "content": "The field value can be empty. This rule is applied by default if the required rule is not present. See the Laravel documentation.\n\n`required````\nField::make('name')->nullable()\n```",
                "level": 4
              },
              {
                "title": "### #Prohibited",
                "content": "The field value must be empty. See the Laravel documentation.\n\n```\nField::make('name')->prohibited()\n```",
                "level": 4
              },
              {
                "title": "### #Prohibited If",
                "content": "The field must be empty only if the other specified field has any of the given values. See the Laravel documentation.\n\n```\nField::make('name')->prohibitedIf('field', 'value')\n```",
                "level": 4
              },
              {
                "title": "### #Prohibited Unless",
                "content": "The field must be empty unless the other specified field has any of the given values. See the Laravel documentation.\n\n```\nField::make('name')->prohibitedUnless('field', 'value')\n```",
                "level": 4
              },
              {
                "title": "### #Prohibits",
                "content": "If the field is not empty, all other specified fields must be empty. See the Laravel documentation.\n\n```\nField::make('name')->prohibits('field')\n\nField::make('name')->prohibits(['field', 'another_field'])\n```",
                "level": 4
              },
              {
                "title": "### #Required",
                "content": "The field value must not be empty. See the Laravel documentation.\n\n```\nField::make('name')->required()\n```",
                "level": 4
              },
              {
                "title": "### #Required If",
                "content": "The field value must not be empty only if the other specified field has any of the given values. See the Laravel documentation.\n\n```\nField::make('name')->requiredIf('field', 'value')\n```",
                "level": 4
              },
              {
                "title": "### #Required If Accepted",
                "content": "The field value must not be empty only if the other specified field is equal to “yes”, “on”, 1, “1”, true, or “true”. See the Laravel documentation.\n\n```\nField::make('name')->requiredIfAccepted('field')\n```",
                "level": 4
              },
              {
                "title": "### #Required Unless",
                "content": "The field value must not be empty unless the other specified field has any of the given values. See the Laravel documentation.\n\n```\nField::make('name')->requiredUnless('field', 'value')\n```",
                "level": 4
              },
              {
                "title": "### #Required With",
                "content": "The field value must not be empty only if any of the other specified fields are not empty. See the Laravel documentation.\n\n```\nField::make('name')->requiredWith('field,another_field')\n```",
                "level": 4
              },
              {
                "title": "### #Required With All",
                "content": "The field value must not be empty only if all the other specified fields are not empty. See the Laravel documentation.\n\n```\nField::make('name')->requiredWithAll('field,another_field')\n```",
                "level": 4
              },
              {
                "title": "### #Required Without",
                "content": "The field value must not be empty only when any of the other specified fields are empty. See the Laravel documentation.\n\n```\nField::make('name')->requiredWithout('field,another_field')\n```",
                "level": 4
              },
              {
                "title": "### #Required Without All",
                "content": "The field value must not be empty only when all the other specified fields are empty. See the Laravel documentation.\n\n```\nField::make('name')->requiredWithoutAll('field,another_field')\n```",
                "level": 4
              },
              {
                "title": "### #Regex",
                "content": "The field must match the given regular expression. See the Laravel documentation.\n\n```\nField::make('email')->regex('/^.+@.+$/i')\n```",
                "level": 4
              },
              {
                "title": "### #Same",
                "content": "The field value must be the same as another. See the Laravel documentation.\n\n```\nField::make('password')->same('passwordConfirmation')\n```",
                "level": 4
              },
              {
                "title": "### #Starts With",
                "content": "The field must start with one of the given values. See the Laravel documentation.\n\n```\nField::make('name')->startsWith(['a'])\n```",
                "level": 4
              },
              {
                "title": "### #String",
                "content": "The field must be a string. See the Laravel documentation.\n\n```\nField::make('name')->string()\n```",
                "level": 4
              },
              {
                "title": "### #Unique",
                "content": "The field value must not exist in the database. See the Laravel documentation.\n\n```\nField::make('email')->unique()\n```\n\nBy default, the form’s model will be searched, if it is registered. You may specify a custom table name or model to search:\n\n```\nuse App\\Models\\User;\n\nField::make('email')->unique(table: User::class)\n```\n\nBy default, the field name will be used as the column to search. You may specify a custom column to search:\n\n```\nField::make('email')->unique(column: 'email_address')\n```\n\nSometimes, you may wish to ignore a given model during unique validation. For example, consider an “update profile” form that includes the user’s name, email address, and location. You will probably want to verify that the email address is unique. However, if the user only changes the name field and not the email field, you do not want a validation error to be thrown because the user is already the owner of the email address in question.\n\n```\nField::make('email')->unique(ignorable: $ignoredUser)\n```\n\nIf you’re using the Panel Builder, you can easily ignore the current record by using ignoreRecord instead:\n\n`ignoreRecord````\nField::make('email')->unique(ignoreRecord: true)\n```\n\nYou can further customize the rule by passing a closure to the modifyRuleUsing parameter:\n\n`modifyRuleUsing````\nuse Illuminate\\Validation\\Rules\\Unique;\n\nField::make('email')\n    ->unique(modifyRuleUsing: function (Unique $rule) {\n        return $rule->where('is_active', 1);\n    })\n```",
                "level": 4
              },
              {
                "title": "### #ULID",
                "content": "The field under validation must be a valid Universally Unique Lexicographically Sortable Identifier (ULID). See the Laravel documentation.\n\n```\nField::make('identifier')->ulid()\n```",
                "level": 4
              },
              {
                "title": "### #UUID",
                "content": "The field must be a valid RFC 4122 (version 1, 3, 4, or 5) universally unique identifier (UUID). See the Laravel documentation.\n\n```\nField::make('identifier')->uuid()\n```",
                "level": 4
              },
              {
                "title": "## #Other rules",
                "content": "You may add other validation rules to any field using the rules() method:\n\n`rules()````\nTextInput::make('slug')->rules(['alpha_dash'])\n```\n\nA full list of validation rules may be found in the Laravel documentation.",
                "level": 3
              },
              {
                "title": "## #Custom rules",
                "content": "You may use any custom validation rules as you would do in Laravel:\n\n```\nTextInput::make('slug')->rules([new Uppercase()])\n```\n\nYou may also use closure rules:\n\n```\nuse Closure;\n\nTextInput::make('slug')->rules([\n    fn (): Closure => function (string $attribute, $value, Closure $fail) {\n        if ($value === 'foo') {\n            $fail('The :attribute is invalid.');\n        }\n    },\n])\n```\n\nYou may inject utilities like $get into your custom rules, for example if you need to reference other field values in your form:\n\n`$get````\nuse Closure;\nuse Filament\\Forms\\Get;\n\nTextInput::make('slug')->rules([\n    fn (Get $get): Closure => function (string $attribute, $value, Closure $fail) use ($get) {\n        if ($get('other_field') === 'foo' && $value !== 'bar') {\n            $fail(\"The {$attribute} is invalid.\");\n        }\n    },\n])\n```",
                "level": 3
              },
              {
                "title": "## #Customizing validation attributes",
                "content": "When fields fail validation, their label is used in the error message. To customize the label used in field error messages, use the validationAttribute() method:\n\n`validationAttribute()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')->validationAttribute('full name')\n```",
                "level": 3
              },
              {
                "title": "## #Validation messages",
                "content": "By default Laravel’s validation error message is used. To customize the error messages, use the validationMessages() method:\n\n`validationMessages()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('email')\n    ->unique(// ...)\n    ->validationMessages([\n        'unique' => 'The :attribute has already been registered.',\n    ])\n```",
                "level": 3
              },
              {
                "title": "## #Sending validation notifications",
                "content": "If you want to send a notification when validation error occurs, you may do so by using the onValidationError() method on your Livewire component:\n\n`onValidationError()````\nuse Filament\\Notifications\\Notification;\nuse Illuminate\\Validation\\ValidationException;\n\nprotected function onValidationError(ValidationException $exception): void\n{\n    Notification::make()\n        ->title($exception->getMessage())\n        ->danger()\n        ->send();\n}\n```\n\nAlternatively, if you are using the Panel Builder and want this behavior on all the pages, add this inside the boot() method of your AppServiceProvider:\n\n`boot()``AppServiceProvider````\nuse Filament\\Notifications\\Notification;\nuse Filament\\Pages\\Page;\nuse Illuminate\\Validation\\ValidationException;\n\nPage::$reportValidationErrorUsing = function (ValidationException $exception) {\n    Notification::make()\n        ->title($exception->getMessage())\n        ->danger()\n        ->send();\n};\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Active URL",
              "After (date)",
              "After or equal to (date)",
              "Alpha",
              "Alpha Dash",
              "Alpha Numeric",
              "ASCII",
              "Before (date)",
              "Before or equal to (date)"
            ],
            "code_examples_count": 138,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "actions": {
          "metadata": {
            "title": "Actions",
            "url": "https://filamentphp.com/docs/3.x/forms/actions",
            "section": "forms",
            "word_count": 820,
            "character_count": 7650
          },
          "content": {
            "full_text": "\n# Actions - Forms - Filament\n\nForms\n\n# Actions\n\n## #Overview\n\nFilament’s forms can use Actions. They are buttons that can be added to any form component. For instance, you may want an action to call an API endpoint to generate content with AI, or to create a new option for a select dropdown. Also, you can render anonymous sets of actions on their own which are not attached to a particular form component.\n\n## #Defining a form component action\n\nAction objects inside a form component are instances of Filament/Forms/Components/Actions/Action. You must pass a unique name to the action’s make() method, which is used to identify it amongst others internally within Filament. You can customize the trigger button of an action, and even open a modal with little effort:\n\n`Filament/Forms/Components/Actions/Action``make()````\nuse App\\Actions\\ResetStars;\nuse Filament\\Forms\\Components\\Actions\\Action;\n\nAction::make('resetStars')\n    ->icon('heroicon-m-x-mark')\n    ->color('danger')\n    ->requiresConfirmation()\n    ->action(function (ResetStars $resetStars) {\n        $resetStars();\n    })\n```\n\n### #Adding an affix action to a field\n\nCertain fields support “affix actions”, which are buttons that can be placed before or after its input area. The following fields support affix actions:\n\n- Text input\n- Select\n- Date-time picker\n- Color picker\n\nTo define an affix action, you can pass it to either prefixAction() or suffixAction():\n\n`prefixAction()``suffixAction()````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Set;\n\nTextInput::make('cost')\n    ->prefix('€')\n    ->suffixAction(\n        Action::make('copyCostToPrice')\n            ->icon('heroicon-m-clipboard')\n            ->requiresConfirmation()\n            ->action(function (Set $set, $state) {\n                $set('price', $state);\n            })\n    )\n```\n\nNotice $set and $state injected into the action() function in this example. This is form component action utility injection.\n\n`$set``$state``action()`#### #Passing multiple affix actions to a field\n\nYou may pass multiple affix actions to a field by passing them in an array to either prefixActions() or suffixActions(). Either method can be used, or both at once, Filament will render all the registered actions in order:\n\n`prefixActions()``suffixActions()````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('cost')\n    ->prefix('€')\n    ->prefixActions([\n        Action::make('...'),\n        Action::make('...'),\n        Action::make('...'),\n    ])\n    ->suffixActions([\n        Action::make('...'),\n        Action::make('...'),\n    ])\n```\n\n### #Adding a hint action to a field\n\nAll fields support “hint actions”, which are rendered aside the field’s hint. To add a hint action to a field, you may pass it to hintAction():\n\n`hintAction()````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Set;\n\nTextInput::make('cost')\n    ->prefix('€')\n    ->hintAction(\n        Action::make('copyCostToPrice')\n            ->icon('heroicon-m-clipboard')\n            ->requiresConfirmation()\n            ->action(function (Set $set, $state) {\n                $set('price', $state);\n            })\n    )\n```\n\nNotice $set and $state injected into the action() function in this example. This is form component action utility injection.\n\n`$set``$state``action()`#### #Passing multiple hint actions to a field\n\nYou may pass multiple hint actions to a field by passing them in an array to hintActions(). Filament will render all the registered actions in order:\n\n`hintActions()````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('cost')\n    ->prefix('€')\n    ->hintActions([\n        Action::make('...'),\n        Action::make('...'),\n        Action::make('...'),\n    ])\n```\n\n### #Adding an action to a custom form component\n\nIf you wish to render an action within a custom form component, ViewField object, or View component object, you may do so using the registerActions() method:\n\n`ViewField``View``registerActions()````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Components\\ViewField;\nuse Filament\\Forms\\Set;\n\nViewField::make('rating')\n    ->view('filament.forms.components.range-slider')\n    ->registerActions([\n        Action::make('setMaximum')\n            ->icon('heroicon-m-star')\n            ->action(function (Set $set) {\n                $set('rating', 5);\n            }),\n    ])\n```\n\nNotice $set injected into the action() function in this example. This is form component action utility injection.\n\n`$set``action()`Now, to render the action in the view of the custom component, you need to call $getAction(), passing the name of the action you registered:\n\n`$getAction()````\n<div x-data=\"{ state: $wire.$entangle('{{ $getStatePath() }}') }\">\n    <input x-model=\"state\" type=\"range\" />\n    \n    {{ $getAction('setMaximum') }}\n</div>\n```\n\n### #Adding “anonymous” actions to a form without attaching them to a component\n\nYou may use an Actions component to render a set of actions anywhere in the form, avoiding the need to register them to any particular component:\n\n`Actions````\nuse App\\Actions\\Star;\nuse App\\Actions\\ResetStars;\nuse Filament\\Forms\\Components\\Actions;\nuse Filament\\Forms\\Components\\Actions\\Action;\n\nActions::make([\n    Action::make('star')\n        ->icon('heroicon-m-star')\n        ->requiresConfirmation()\n        ->action(function (Star $star) {\n            $star();\n        }),\n    Action::make('resetStars')\n        ->icon('heroicon-m-x-mark')\n        ->color('danger')\n        ->requiresConfirmation()\n        ->action(function (ResetStars $resetStars) {\n            $resetStars();\n        }),\n]),\n```\n\n#### #Making the independent form actions consume the full width of the form\n\nYou can stretch the independent form actions to consume the full width of the form using fullWidth():\n\n`fullWidth()````\nuse Filament\\Forms\\Components\\Actions;\n\nActions::make([\n    // ...\n])->fullWidth(),\n```\n\n#### #Controlling the horizontal alignment of independent form actions\n\nIndependent form actions are aligned to the start of the component by default. You may change this by passing Alignment::Center or Alignment::End to alignment():\n\n`Alignment::Center``Alignment::End``alignment()````\nuse Filament\\Forms\\Components\\Actions;\nuse Filament\\Support\\Enums\\Alignment;\n\nActions::make([\n    // ...\n])->alignment(Alignment::Center),\n```\n\n#### #Controlling the vertical alignment of independent form actions\n\nIndependent form actions are vertically aligned to the start of the component by default. You may change this by passing Alignment::Center or Alignment::End to verticalAlignment():\n\n`Alignment::Center``Alignment::End``verticalAlignment()````\nuse Filament\\Forms\\Components\\Actions;\nuse Filament\\Support\\Enums\\VerticalAlignment;\n\nActions::make([\n    // ...\n])->verticalAlignment(VerticalAlignment::End),\n```\n\n## #Form component action utility injection\n\nIf an action is attached to a form component, the action() function is able to inject utilities directly from that form component. For instance, you can inject $set and $state:\n\n`action()``$set``$state````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Set;\n\nAction::make('copyCostToPrice')\n    ->icon('heroicon-m-clipboard')\n    ->requiresConfirmation()\n    ->action(function (Set $set, $state) {\n        $set('price', $state);\n    })\n```\n\nForm component actions also have access to all utilities that apply to actions in general.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Actions - Forms - Filament",
                "content": "Forms",
                "level": 1
              },
              {
                "title": "# Actions",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament’s forms can use Actions. They are buttons that can be added to any form component. For instance, you may want an action to call an API endpoint to generate content with AI, or to create a new option for a select dropdown. Also, you can render anonymous sets of actions on their own which are not attached to a particular form component.",
                "level": 3
              },
              {
                "title": "## #Defining a form component action",
                "content": "Action objects inside a form component are instances of Filament/Forms/Components/Actions/Action. You must pass a unique name to the action’s make() method, which is used to identify it amongst others internally within Filament. You can customize the trigger button of an action, and even open a modal with little effort:\n\n`Filament/Forms/Components/Actions/Action``make()````\nuse App\\Actions\\ResetStars;\nuse Filament\\Forms\\Components\\Actions\\Action;\n\nAction::make('resetStars')\n    ->icon('heroicon-m-x-mark')\n    ->color('danger')\n    ->requiresConfirmation()\n    ->action(function (ResetStars $resetStars) {\n        $resetStars();\n    })\n```",
                "level": 3
              },
              {
                "title": "### #Adding an affix action to a field",
                "content": "Certain fields support “affix actions”, which are buttons that can be placed before or after its input area. The following fields support affix actions:\n\n- Text input\n- Select\n- Date-time picker\n- Color picker\n\nTo define an affix action, you can pass it to either prefixAction() or suffixAction():\n\n`prefixAction()``suffixAction()````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Set;\n\nTextInput::make('cost')\n    ->prefix('€')\n    ->suffixAction(\n        Action::make('copyCostToPrice')\n            ->icon('heroicon-m-clipboard')\n            ->requiresConfirmation()\n            ->action(function (Set $set, $state) {\n                $set('price', $state);\n            })\n    )\n```\n\nNotice $set and $state injected into the action() function in this example. This is form component action utility injection.\n\n`$set``$state``action()`#### #Passing multiple affix actions to a field\n\nYou may pass multiple affix actions to a field by passing them in an array to either prefixActions() or suffixActions(). Either method can be used, or both at once, Filament will render all the registered actions in order:\n\n`prefixActions()``suffixActions()````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('cost')\n    ->prefix('€')\n    ->prefixActions([\n        Action::make('...'),\n        Action::make('...'),\n        Action::make('...'),\n    ])\n    ->suffixActions([\n        Action::make('...'),\n        Action::make('...'),\n    ])\n```",
                "level": 4
              },
              {
                "title": "### #Adding a hint action to a field",
                "content": "All fields support “hint actions”, which are rendered aside the field’s hint. To add a hint action to a field, you may pass it to hintAction():\n\n`hintAction()````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Set;\n\nTextInput::make('cost')\n    ->prefix('€')\n    ->hintAction(\n        Action::make('copyCostToPrice')\n            ->icon('heroicon-m-clipboard')\n            ->requiresConfirmation()\n            ->action(function (Set $set, $state) {\n                $set('price', $state);\n            })\n    )\n```\n\nNotice $set and $state injected into the action() function in this example. This is form component action utility injection.\n\n`$set``$state``action()`#### #Passing multiple hint actions to a field\n\nYou may pass multiple hint actions to a field by passing them in an array to hintActions(). Filament will render all the registered actions in order:\n\n`hintActions()````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('cost')\n    ->prefix('€')\n    ->hintActions([\n        Action::make('...'),\n        Action::make('...'),\n        Action::make('...'),\n    ])\n```",
                "level": 4
              },
              {
                "title": "### #Adding an action to a custom form component",
                "content": "If you wish to render an action within a custom form component, ViewField object, or View component object, you may do so using the registerActions() method:\n\n`ViewField``View``registerActions()````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Components\\ViewField;\nuse Filament\\Forms\\Set;\n\nViewField::make('rating')\n    ->view('filament.forms.components.range-slider')\n    ->registerActions([\n        Action::make('setMaximum')\n            ->icon('heroicon-m-star')\n            ->action(function (Set $set) {\n                $set('rating', 5);\n            }),\n    ])\n```\n\nNotice $set injected into the action() function in this example. This is form component action utility injection.\n\n`$set``action()`Now, to render the action in the view of the custom component, you need to call $getAction(), passing the name of the action you registered:\n\n`$getAction()````\n<div x-data=\"{ state: $wire.$entangle('{{ $getStatePath() }}') }\">\n    <input x-model=\"state\" type=\"range\" />\n    \n    {{ $getAction('setMaximum') }}\n</div>\n```",
                "level": 4
              },
              {
                "title": "### #Adding “anonymous” actions to a form without attaching them to a component",
                "content": "You may use an Actions component to render a set of actions anywhere in the form, avoiding the need to register them to any particular component:\n\n`Actions````\nuse App\\Actions\\Star;\nuse App\\Actions\\ResetStars;\nuse Filament\\Forms\\Components\\Actions;\nuse Filament\\Forms\\Components\\Actions\\Action;\n\nActions::make([\n    Action::make('star')\n        ->icon('heroicon-m-star')\n        ->requiresConfirmation()\n        ->action(function (Star $star) {\n            $star();\n        }),\n    Action::make('resetStars')\n        ->icon('heroicon-m-x-mark')\n        ->color('danger')\n        ->requiresConfirmation()\n        ->action(function (ResetStars $resetStars) {\n            $resetStars();\n        }),\n]),\n```",
                "level": 4
              },
              {
                "title": "#### #Making the independent form actions consume the full width of the form",
                "content": "You can stretch the independent form actions to consume the full width of the form using fullWidth():\n\n`fullWidth()````\nuse Filament\\Forms\\Components\\Actions;\n\nActions::make([\n    // ...\n])->fullWidth(),\n```",
                "level": 5
              },
              {
                "title": "#### #Controlling the horizontal alignment of independent form actions",
                "content": "Independent form actions are aligned to the start of the component by default. You may change this by passing Alignment::Center or Alignment::End to alignment():\n\n`Alignment::Center``Alignment::End``alignment()````\nuse Filament\\Forms\\Components\\Actions;\nuse Filament\\Support\\Enums\\Alignment;\n\nActions::make([\n    // ...\n])->alignment(Alignment::Center),\n```",
                "level": 5
              },
              {
                "title": "#### #Controlling the vertical alignment of independent form actions",
                "content": "Independent form actions are vertically aligned to the start of the component by default. You may change this by passing Alignment::Center or Alignment::End to verticalAlignment():\n\n`Alignment::Center``Alignment::End``verticalAlignment()````\nuse Filament\\Forms\\Components\\Actions;\nuse Filament\\Support\\Enums\\VerticalAlignment;\n\nActions::make([\n    // ...\n])->verticalAlignment(VerticalAlignment::End),\n```",
                "level": 5
              },
              {
                "title": "## #Form component action utility injection",
                "content": "If an action is attached to a form component, the action() function is able to inject utilities directly from that form component. For instance, you can inject $set and $state:\n\n`action()``$set``$state````\nuse Filament\\Forms\\Components\\Actions\\Action;\nuse Filament\\Forms\\Set;\n\nAction::make('copyCostToPrice')\n    ->icon('heroicon-m-clipboard')\n    ->requiresConfirmation()\n    ->action(function (Set $set, $state) {\n        $set('price', $state);\n    })\n```\n\nForm component actions also have access to all utilities that apply to actions in general.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Defining a form component action",
              "Adding an affix action to a field",
              "Adding a hint action to a field",
              "Adding an action to a custom form component",
              "Adding “anonymous” actions to a form without attaching them to a component",
              "Form component action utility injection"
            ],
            "code_examples_count": 24,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "advanced": {
          "metadata": {
            "title": "Advanced",
            "url": "https://filamentphp.com/docs/3.x/forms/advanced",
            "section": "forms",
            "word_count": 3628,
            "character_count": 27825
          },
          "content": {
            "full_text": "\n# Advanced forms - Forms - Filament\n\nForms\n\n# Advanced forms\n\n## #Overview\n\nFilament Form Builder is designed to be flexible and customizable. Many existing form builders allow users to define a form schema, but don’t provide a great interface for defining inter-field interactions, or custom logic. Since all Filament forms are built on top of Livewire, the form can adapt dynamically to user input, even after it has been initially rendered. Developers can use parameter injection to access many utilities in real time and build dynamic forms based on user input. The lifecycle of fields is open to extension using hook functions to define custom functionality for each field. This allows developers to build complex forms with ease.\n\n## #The basics of reactivity\n\nLivewire is a tool that allows Blade-rendered HTML to dynamically re-render without requiring a full page reload. Filament forms are built on top of Livewire, so they are able to re-render dynamically, allowing their layout to adapt after they are initially rendered.\n\nBy default, when a user uses a field, the form will not re-render. Since rendering requires a round-trip to the server, this is a performance optimization. However, if you wish to re-render the form after the user has interacted with a field, you can use the live() method:\n\n`live()````\nuse Filament\\Forms\\Components\\Select;\n\nSelect::make('status')\n    ->options([\n        'draft' => 'Draft',\n        'reviewing' => 'Reviewing',\n        'published' => 'Published',\n    ])\n    ->live()\n```\n\nIn this example, when the user changes the value of the status field, the form will re-render. This allows you to then make changes to fields in the form based on the new value of the status field. Also, you can hook in to the field’s lifecycle to perform custom logic when the field is updated.\n\n`status``status`### #Reactive fields on blur\n\nBy default, when a field is set to live(), the form will re-render every time the field is interacted with. However, this may not be appropriate for some fields like the text input, since making network requests while the user is still typing results in suboptimal performance. You may wish to re-render the form only after the user has finished using the field, when it becomes out of focus. You can do this using the live(onBlur: true) method:\n\n`live()``live(onBlur: true)````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('username')\n    ->live(onBlur: true)\n```\n\n### #Debouncing reactive fields\n\nYou may wish to find a middle ground between live() and live(onBlur: true), using “debouncing”. Debouncing will prevent a network request from being sent until a user has finished typing for a certain period of time. You can do this using the live(debounce: 500) method:\n\n`live()``live(onBlur: true)``live(debounce: 500)````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('username')\n    ->live(debounce: 500) // Wait 500ms before re-rendering the form.\n```\n\nIn this example, 500 is the number of milliseconds to wait before sending a network request. You can customize this number to whatever you want, or even use a string like '1s'.\n\n`500``'1s'`## #Form component utility injection\n\nThe vast majority of methods used to configure fields and layout components accept functions as parameters instead of hardcoded values:\n\n```\nuse App\\Models\\User;\nuse Filament\\Forms\\Components\\DatePicker;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Forms\\Components\\TextInput;\n\nDatePicker::make('date_of_birth')\n    ->displayFormat(function (): string {\n        if (auth()->user()->country_id === 'us') {\n            return 'm/d/Y';\n        }\n\n        return 'd/m/Y';\n    })\n\nSelect::make('user_id')\n    ->options(function (): array {\n        return User::all()->pluck('name', 'id')->all();\n    })\n\nTextInput::make('middle_name')\n    ->required(fn (): bool => auth()->user()->hasMiddleName())\n```\n\nThis alone unlocks many customization possibilities.\n\nThe package is also able to inject many utilities to use inside these functions, as parameters. All customization methods that accept functions as arguments can inject utilities.\n\nThese injected utilities require specific parameter names to be used. Otherwise, Filament doesn’t know what to inject.\n\n### #Injecting the current state of a field\n\nIf you wish to access the current state (value) of the field, define a $state parameter:\n\n`$state````\nfunction ($state) {\n    // ...\n}\n```\n\n### #Injecting the current form component instance\n\nIf you wish to access the current component instance, define a $component parameter:\n\n`$component````\nuse Filament\\Forms\\Components\\Component;\n\nfunction (Component $component) {\n    // ...\n}\n```\n\n### #Injecting the current Livewire component instance\n\nIf you wish to access the current Livewire component instance, define a $livewire parameter:\n\n`$livewire````\nuse Livewire\\Component as Livewire;\n\nfunction (Livewire $livewire) {\n    // ...\n}\n```\n\n### #Injecting the current form record\n\nIf your form is associated with an Eloquent model instance, define a $record parameter:\n\n`$record````\nuse Illuminate\\Database\\Eloquent\\Model;\n\nfunction (?Model $record) {\n    // ...\n}\n```\n\n### #Injecting the state of another field\n\nYou may also retrieve the state (value) of another field from within a callback, using a $get parameter:\n\n`$get````\nuse Filament\\Forms\\Get;\n\nfunction (Get $get) {\n    $email = $get('email'); // Store the value of the `email` field in the `$email` variable.\n    //...\n}\n```\n\n### #Injecting a function to set the state of another field\n\nIn a similar way to $get, you may also set the value of another field from within a callback, using a $set parameter:\n\n`$get``$set````\nuse Filament\\Forms\\Set;\n\nfunction (Set $set) {\n    $set('title', 'Blog Post'); // Set the `title` field to `Blog Post`.\n    //...\n}\n```\n\nWhen this function is run, the state of the title field will be updated, and the form will re-render with the new title. This is useful inside the afterStateUpdated method.\n\n`title``afterStateUpdated`### #Injecting the current form operation\n\nIf you’re writing a form for a panel resource or relation manager, and you wish to check if a form is create, edit or view, use the $operation parameter:\n\n`create``edit``view``$operation````\nfunction (string $operation) {\n    // ...\n}\n```\n\n> Outside the panel, you can set a form’s operation by using the operation() method on the form definition.\n\nOutside the panel, you can set a form’s operation by using the operation() method on the form definition.\n\n`operation()`### #Injecting multiple utilities\n\nThe parameters are injected dynamically using reflection, so you are able to combine multiple parameters in any order:\n\n```\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Set;\nuse Livewire\\Component as Livewire;\n\nfunction (Livewire $livewire, Get $get, Set $set) {\n    // ...\n}\n```\n\n### #Injecting dependencies from Laravel’s container\n\nYou may inject anything from Laravel’s container like normal, alongside utilities:\n\n```\nuse Filament\\Forms\\Set;\nuse Illuminate\\Http\\Request;\n\nfunction (Request $request, Set $set) {\n    // ...\n}\n```\n\n## #Field lifecycle\n\nEach field in a form has a lifecycle, which is the process it goes through when the form is loaded, when it is interacted with by the user, and when it is submitted. You may customize what happens at each stage of this lifecycle using a function that gets run at that stage.\n\n### #Field hydration\n\nHydration is the process that fills fields with data. It runs when you call the form’s fill() method. You may customize what happens after a field is hydrated using the afterStateHydrated() method.\n\n`fill()``afterStateHydrated()`In this example, the name field will always be hydrated with the correctly capitalized name:\n\n`name````\nuse Closure;\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->required()\n    ->afterStateHydrated(function (TextInput $component, string $state) {\n        $component->state(ucwords($state));\n    })\n```\n\nAs a shortcut for formatting the field’s state like this when it is hydrated, you can use the formatStateUsing() method:\n\n`formatStateUsing()````\nuse Closure;\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->formatStateUsing(fn (string $state): string => ucwords($state))\n```\n\n### #Field updates\n\nYou may use the afterStateUpdated() method to customize what happens after a field is updated by the user. Only changes from the user on the frontend will trigger this function, not manual changes to the state from $set() or another PHP function.\n\n`afterStateUpdated()``$set()`Inside this function, you can also inject the $old value of the field before it was updated, using the $old parameter:\n\n`$old``$old````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->afterStateUpdated(function (?string $state, ?string $old) {\n        // ...\n    })\n```\n\nFor an example of how to use this method, learn how to automatically generate a slug from a title.\n\n### #Field dehydration\n\nDehydration is the process that gets data from the fields in your forms, and transforms it. It runs when you call the form’s getState() method.\n\n`getState()`You may customize how the state is transformed when it is dehydrated using the dehydrateStateUsing() function. In this example, the name field will always be dehydrated with the correctly capitalized name:\n\n`dehydrateStateUsing()``name````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->required()\n    ->dehydrateStateUsing(fn (string $state): string => ucwords($state))\n```\n\n#### #Preventing a field from being dehydrated\n\nYou may also prevent a field from being dehydrated altogether using dehydrated(false). In this example, the field will not be present in the array returned from getState():\n\n`dehydrated(false)``getState()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('password_confirmation')\n    ->password()\n    ->dehydrated(false)\n```\n\nIf your form auto-saves data to the database, like in a resource or table action, this is useful to prevent a field from being saved to the database if it is purely used for presentational purposes.\n\n## #Reactive forms cookbook\n\nThis section contains a collection of recipes for common tasks you may need to perform when building an advanced form.\n\n### #Conditionally hiding a field\n\nTo conditionally hide or show a field, you can pass a function to the hidden() method, and return true or false depending on whether you want the field to be hidden or not. The function can inject utilities as parameters, so you can do things like check the value of another field:\n\n`hidden()``true``false````\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Components\\Checkbox;\nuse Filament\\Forms\\Components\\TextInput;\n\nCheckbox::make('is_company')\n    ->live()\n\nTextInput::make('company_name')\n    ->hidden(fn (Get $get): bool => ! $get('is_company'))\n```\n\nIn this example, the is_company checkbox is live(). This allows the form to rerender when the value of the is_company field changes. You can access the value of that field from within the hidden() function using the $get() utility. The value of the field is inverted using ! so that the company_name field is hidden when the is_company field is false.\n\n`is_company``live()``is_company``hidden()``$get()``!``company_name``is_company``false`Alternatively, you can use the visible() method to show a field conditionally. It does the exact inverse of hidden(), and could be used if you prefer the clarity of the code when written this way:\n\n`visible()``hidden()````\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Components\\Checkbox;\nuse Filament\\Forms\\Components\\TextInput;\n\nCheckbox::make('is_company')\n    ->live()\n    \nTextInput::make('company_name')\n    ->visible(fn (Get $get): bool => $get('is_company'))\n```\n\n### #Conditionally making a field required\n\nTo conditionally make a field required, you can pass a function to the required() method, and return true or false depending on whether you want the field to be required or not. The function can inject utilities as parameters, so you can do things like check the value of another field:\n\n`required()``true``false````\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('company_name')\n    ->live(onBlur: true)\n    \nTextInput::make('vat_number')\n    ->required(fn (Get $get): bool => filled($get('company_name')))\n```\n\nIn this example, the company_name field is live(onBlur: true). This allows the form to rerender after the value of the company_name field changes and the user clicks away. You can access the value of that field from within the required() function using the $get() utility. The value of the field is checked using filled() so that the vat_number field is required when the company_name field is not null or an empty string. The result is that the vat_number field is only required when the company_name field is filled in.\n\n`company_name``live(onBlur: true)``company_name``required()``$get()``filled()``vat_number``company_name``null``vat_number``company_name`Using a function is able to make any other validation rule dynamic in a similar way.\n\n### #Generating a slug from a title\n\nTo generate a slug from a title while the user is typing, you can use the afterStateUpdated() method on the title field to $set() the value of the slug field:\n\n`afterStateUpdated()``$set()````\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Set;\nuse Illuminate\\Support\\Str;\n\nTextInput::make('title')\n    ->live(onBlur: true)\n    ->afterStateUpdated(fn (Set $set, ?string $state) => $set('slug', Str::slug($state)))\n    \nTextInput::make('slug')\n```\n\nIn this example, the title field is live(onBlur: true). This allows the form to rerender when the value of the title field changes and the user clicks away. The afterStateUpdated() method is used to run a function after the state of the title field is updated. The function injects the $set() utility and the new state of the title field. The Str::slug() utility method is part of Laravel and is used to generate a slug from a string. The slug field is then updated using the $set() function.\n\n`title``live(onBlur: true)``title``afterStateUpdated()``title``$set()``title``Str::slug()``slug``$set()`One thing to note is that the user may customize the slug manually, and we don’t want to overwrite their changes if the title changes. To prevent this, we can use the old version of the title to work out if the user has modified it themselves. To access the old version of the title, you can inject $old, and to get the current value of the slug before it gets changed, we can use the $get() utility:\n\n`$old``$get()````\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Set;\nuse Illuminate\\Support\\Str;\n\nTextInput::make('title')\n    ->live(onBlur: true)\n    ->afterStateUpdated(function (Get $get, Set $set, ?string $old, ?string $state) {\n        if (($get('slug') ?? '') !== Str::slug($old)) {\n            return;\n        }\n    \n        $set('slug', Str::slug($state));\n    })\n    \nTextInput::make('slug')\n```\n\n### #Dependant select options\n\nTo dynamically update the options of a select field based on the value of another field, you can pass a function to the options() method of the select field. The function can inject utilities as parameters, so you can do things like check the value of another field using the $get() utility:\n\n`options()``$get()````\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Components\\Select;\n\nSelect::make('category')\n    ->options([\n        'web' => 'Web development',\n        'mobile' => 'Mobile development',\n        'design' => 'Design',\n    ])\n    ->live()\n\nSelect::make('sub_category')\n    ->options(fn (Get $get): array => match ($get('category')) {\n        'web' => [\n            'frontend_web' => 'Frontend development',\n            'backend_web' => 'Backend development',\n        ],\n        'mobile' => [\n            'ios_mobile' => 'iOS development',\n            'android_mobile' => 'Android development',\n        ],\n        'design' => [\n            'app_design' => 'Panel design',\n            'marketing_website_design' => 'Marketing website design',\n        ],\n        default => [],\n    })\n```\n\nIn this example, the category field is live(). This allows the form to rerender when the value of the category field changes. You can access the value of that field from within the options() function using the $get() utility. The value of the field is used to determine which options should be available in the sub_category field. The match () statement in PHP is used to return an array of options based on the value of the category field. The result is that the sub_category field will only show options relevant to the selected category field.\n\n`category``live()``category``options()``$get()``sub_category``match ()``category``sub_category``category`You could adapt this example to use options loaded from an Eloquent model or other data source, by querying within the function:\n\n```\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Components\\Select;\nuse Illuminate\\Support\\Collection;\n\nSelect::make('category')\n    ->options(Category::query()->pluck('name', 'id'))\n    ->live()\n    \nSelect::make('sub_category')\n    ->options(fn (Get $get): Collection => SubCategory::query()\n        ->where('category', $get('category'))\n        ->pluck('name', 'id'))\n```\n\n### #Dynamic fields based on a select option\n\nYou may wish to render a different set of fields based on the value of a field, like a select. To do this, you can pass a function to the schema() method of any layout component, which checks the value of the field and returns a different schema based on that value. Also, you will need a way to initialise the new fields in the dynamic schema when they are first loaded.\n\n`schema()````\nuse Filament\\Forms\\Components\\FileUpload;\nuse Filament\\Forms\\Components\\Grid;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Get;\n\nSelect::make('type')\n    ->options([\n        'employee' => 'Employee',\n        'freelancer' => 'Freelancer',\n    ])\n    ->live()\n    ->afterStateUpdated(fn (Select $component) => $component\n        ->getContainer()\n        ->getComponent('dynamicTypeFields')\n        ->getChildComponentContainer()\n        ->fill())\n    \nGrid::make(2)\n    ->schema(fn (Get $get): array => match ($get('type')) {\n        'employee' => [\n            TextInput::make('employee_number')\n                ->required(),\n            FileUpload::make('badge')\n                ->image()\n                ->required(),\n        ],\n        'freelancer' => [\n            TextInput::make('hourly_rate')\n                ->numeric()\n                ->required()\n                ->prefix('€'),\n            FileUpload::make('contract')\n                ->required(),\n        ],\n        default => [],\n    })\n    ->key('dynamicTypeFields')\n```\n\nIn this example, the type field is live(). This allows the form to rerender when the value of the type field changes. The afterStateUpdated() method is used to run a function after the state of the type field is updated. In this case, we inject the current select field instance, which we can then use to get the form “container” instance that holds both the select and the grid components. With this container, we can target the grid component using a unique key (dynamicTypeFields) that we have assigned to it. With that grid component instance, we can call fill(), just as we do on a normal form to initialise it. The schema() method of the grid component is then used to return a different schema based on the value of the type field. This is done by using the $get() utility, and returning a different schema array dynamically.\n\n`type``live()``type``afterStateUpdated()``type``dynamicTypeFields``fill()``schema()``type``$get()`### #Auto-hashing password field\n\nYou have a password field:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('password')\n    ->password()\n```\n\nAnd you can use a dehydration function to hash the password when the form is submitted:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\Facades\\Hash;\n\nTextInput::make('password')\n    ->password()\n    ->dehydrateStateUsing(fn (string $state): string => Hash::make($state))\n```\n\nBut if your form is used to change an existing password, you don’t want to overwrite the existing password if the field is empty. You can prevent the field from being dehydrated if the field is null or an empty string (using the filled() helper):\n\n`filled()````\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\Facades\\Hash;\n\nTextInput::make('password')\n    ->password()\n    ->dehydrateStateUsing(fn (string $state): string => Hash::make($state))\n    ->dehydrated(fn (?string $state): bool => filled($state))\n```\n\nHowever, you want to require the password to be filled when the user is being created, by injecting the $operation utility, and then conditionally making the field required:\n\n`$operation````\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\Facades\\Hash;\n\nTextInput::make('password')\n    ->password()\n    ->dehydrateStateUsing(fn (string $state): string => Hash::make($state))\n    ->dehydrated(fn (?string $state): bool => filled($state))\n    ->required(fn (string $operation): bool => $operation === 'create')\n```\n\n## #Saving data to relationships\n\n> If you’re building a form inside your Livewire component, make sure you have set up the form’s model. Otherwise, Filament doesn’t know which model to use to retrieve the relationship from.\n\nIf you’re building a form inside your Livewire component, make sure you have set up the form’s model. Otherwise, Filament doesn’t know which model to use to retrieve the relationship from.\n\nAs well as being able to give structure to fields, layout components are also able to “teleport” their nested fields into a relationship. Filament will handle loading data from a HasOne, BelongsTo or MorphOne Eloquent relationship, and then it will save the data back to the same relationship. To set this behavior up, you can use the relationship() method on any layout component:\n\n`HasOne``BelongsTo``MorphOne``relationship()````\nuse Filament\\Forms\\Components\\Fieldset;\nuse Filament\\Forms\\Components\\FileUpload;\nuse Filament\\Forms\\Components\\Textarea;\nuse Filament\\Forms\\Components\\TextInput;\n\nFieldset::make('Metadata')\n    ->relationship('metadata')\n    ->schema([\n        TextInput::make('title'),\n        Textarea::make('description'),\n        FileUpload::make('image'),\n    ])\n```\n\nIn this example, the title, description and image are automatically loaded from the metadata relationship, and saved again when the form is submitted. If the metadata record does not exist, it is automatically created.\n\n`title``description``image``metadata``metadata`This functionality is not just limited to fieldsets - you can use it with any layout component. For example, you could use a Group component which has no styling associated with it:\n\n`Group````\nuse Filament\\Forms\\Components\\Group;\nuse Filament\\Forms\\Components\\TextInput;\n\nGroup::make()\n    ->relationship('customer')\n    ->schema([\n        TextInput::make('name')\n            ->label('Customer')\n            ->required(),\n        TextInput::make('email')\n            ->label('Email address')\n            ->email()\n            ->required(),\n    ])\n```\n\n### #Saving data to a BelongsTo relationship\n\n`BelongsTo`Please note that if you are saving the data to a BelongsTo relationship, then the foreign key column in your database must be nullable(). This is because Filament saves the form first, before saving the relationship. Since the form is saved first, the foreign ID does not exist yet, so it must be nullable. Immediately after the form is saved, Filament saves the relationship, which will then fill in the foreign ID and save it again.\n\n`BelongsTo``nullable()`It is worth noting that if you have an observer on your form model, then you may need to adapt it to ensure that it does not depend on the relationship existing when it is created. For example, if you have an observer that sends an email to a related record when a form is created, you may need to switch to using a different hook that runs after the relationship is attached, like updated().\n\n`updated()`### #Conditionally saving data to a relationship\n\nSometimes, saving the related record may be optional. If the user fills out the customer fields, then the customer will be created / updated. Otherwise, the customer will not be created, or will be deleted if it already exists. To do this, you can pass a condition function as an argument to relationship(), which can use the $state of the related form to determine whether the relationship should be saved or not:\n\n`condition``relationship()``$state````\nuse Filament\\Forms\\Components\\Group;\nuse Filament\\Forms\\Components\\TextInput;\n\nGroup::make()\n    ->relationship(\n        'customer',\n        condition: fn (?array $state): bool => filled($state['name']),\n    )\n    ->schema([\n        TextInput::make('name')\n            ->label('Customer'),\n        TextInput::make('email')\n            ->label('Email address')\n            ->email()\n            ->requiredWith('name'),\n    ])\n```\n\nIn this example, the customer’s name is not required(), and the email address is only required when the name is filled. The condition function is used to check whether the name field is filled, and if it is, then the customer will be created / updated. Otherwise, the customer will not be created, or will be deleted if it already exists.\n\n`required()``name``condition``name`## #Inserting Livewire components into a form\n\nYou may insert a Livewire component directly into a form:\n\n```\nuse Filament\\Forms\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)\n```\n\nIf you are rendering multiple of the same Livewire component, please make sure to pass a unique key() to each:\n\n`key()````\nuse Filament\\Forms\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)\n    ->key('foo-first')\n\nLivewire::make(Foo::class)\n    ->key('foo-second')\n\nLivewire::make(Foo::class)\n    ->key('foo-third')\n```\n\n### #Passing parameters to a Livewire component\n\nYou can pass an array of parameters to a Livewire component:\n\n```\nuse Filament\\Forms\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class, ['bar' => 'baz'])\n```\n\nNow, those parameters will be passed to the Livewire component’s mount() method:\n\n`mount()````\nclass Foo extends Component\n{\n    public function mount(string $bar): void\n    {       \n        // ...\n    }\n}\n```\n\nAlternatively, they will be available as public properties on the Livewire component:\n\n```\nclass Foo extends Component\n{\n    public string $bar;\n}\n```\n\n#### #Accessing the current record in the Livewire component\n\nYou can access the current record in the Livewire component using the $record parameter in the mount() method, or the $record property:\n\n`$record``mount()``$record````\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Foo extends Component\n{\n    public function mount(?Model $record = null): void\n    {       \n        // ...\n    }\n    \n    // or\n    \n    public ?Model $record = null;\n}\n```\n\nPlease be aware that when the record has not yet been created, it will be null. If you’d like to hide the Livewire component when the record is null, you can use the hidden() method:\n\n`null``null``hidden()````\nuse Filament\\Forms\\Components\\Livewire;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nLivewire::make(Foo::class)\n    ->hidden(fn (?Model $record): bool => $record === null)\n```\n\n### #Lazy loading a Livewire component\n\nYou may allow the component to lazily load using the lazy() method:\n\n`lazy()````\nuse Filament\\Forms\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)->lazy()\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Advanced forms - Forms - Filament",
                "content": "Forms",
                "level": 1
              },
              {
                "title": "# Advanced forms",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament Form Builder is designed to be flexible and customizable. Many existing form builders allow users to define a form schema, but don’t provide a great interface for defining inter-field interactions, or custom logic. Since all Filament forms are built on top of Livewire, the form can adapt dynamically to user input, even after it has been initially rendered. Developers can use parameter injection to access many utilities in real time and build dynamic forms based on user input. The lifecycle of fields is open to extension using hook functions to define custom functionality for each field. This allows developers to build complex forms with ease.",
                "level": 3
              },
              {
                "title": "## #The basics of reactivity",
                "content": "Livewire is a tool that allows Blade-rendered HTML to dynamically re-render without requiring a full page reload. Filament forms are built on top of Livewire, so they are able to re-render dynamically, allowing their layout to adapt after they are initially rendered.\n\nBy default, when a user uses a field, the form will not re-render. Since rendering requires a round-trip to the server, this is a performance optimization. However, if you wish to re-render the form after the user has interacted with a field, you can use the live() method:\n\n`live()````\nuse Filament\\Forms\\Components\\Select;\n\nSelect::make('status')\n    ->options([\n        'draft' => 'Draft',\n        'reviewing' => 'Reviewing',\n        'published' => 'Published',\n    ])\n    ->live()\n```\n\nIn this example, when the user changes the value of the status field, the form will re-render. This allows you to then make changes to fields in the form based on the new value of the status field. Also, you can hook in to the field’s lifecycle to perform custom logic when the field is updated.\n\n`status``status`### #Reactive fields on blur\n\nBy default, when a field is set to live(), the form will re-render every time the field is interacted with. However, this may not be appropriate for some fields like the text input, since making network requests while the user is still typing results in suboptimal performance. You may wish to re-render the form only after the user has finished using the field, when it becomes out of focus. You can do this using the live(onBlur: true) method:\n\n`live()``live(onBlur: true)````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('username')\n    ->live(onBlur: true)\n```",
                "level": 3
              },
              {
                "title": "### #Debouncing reactive fields",
                "content": "You may wish to find a middle ground between live() and live(onBlur: true), using “debouncing”. Debouncing will prevent a network request from being sent until a user has finished typing for a certain period of time. You can do this using the live(debounce: 500) method:\n\n`live()``live(onBlur: true)``live(debounce: 500)````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('username')\n    ->live(debounce: 500) // Wait 500ms before re-rendering the form.\n```\n\nIn this example, 500 is the number of milliseconds to wait before sending a network request. You can customize this number to whatever you want, or even use a string like '1s'.\n\n`500``'1s'`## #Form component utility injection\n\nThe vast majority of methods used to configure fields and layout components accept functions as parameters instead of hardcoded values:\n\n```\nuse App\\Models\\User;\nuse Filament\\Forms\\Components\\DatePicker;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Forms\\Components\\TextInput;\n\nDatePicker::make('date_of_birth')\n    ->displayFormat(function (): string {\n        if (auth()->user()->country_id === 'us') {\n            return 'm/d/Y';\n        }\n\n        return 'd/m/Y';\n    })\n\nSelect::make('user_id')\n    ->options(function (): array {\n        return User::all()->pluck('name', 'id')->all();\n    })\n\nTextInput::make('middle_name')\n    ->required(fn (): bool => auth()->user()->hasMiddleName())\n```\n\nThis alone unlocks many customization possibilities.\n\nThe package is also able to inject many utilities to use inside these functions, as parameters. All customization methods that accept functions as arguments can inject utilities.\n\nThese injected utilities require specific parameter names to be used. Otherwise, Filament doesn’t know what to inject.",
                "level": 4
              },
              {
                "title": "### #Injecting the current state of a field",
                "content": "If you wish to access the current state (value) of the field, define a $state parameter:\n\n`$state````\nfunction ($state) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting the current form component instance",
                "content": "If you wish to access the current component instance, define a $component parameter:\n\n`$component````\nuse Filament\\Forms\\Components\\Component;\n\nfunction (Component $component) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting the current Livewire component instance",
                "content": "If you wish to access the current Livewire component instance, define a $livewire parameter:\n\n`$livewire````\nuse Livewire\\Component as Livewire;\n\nfunction (Livewire $livewire) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting the current form record",
                "content": "If your form is associated with an Eloquent model instance, define a $record parameter:\n\n`$record````\nuse Illuminate\\Database\\Eloquent\\Model;\n\nfunction (?Model $record) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting the state of another field",
                "content": "You may also retrieve the state (value) of another field from within a callback, using a $get parameter:\n\n`$get````\nuse Filament\\Forms\\Get;\n\nfunction (Get $get) {\n    $email = $get('email'); // Store the value of the `email` field in the `$email` variable.\n    //...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting a function to set the state of another field",
                "content": "In a similar way to $get, you may also set the value of another field from within a callback, using a $set parameter:\n\n`$get``$set````\nuse Filament\\Forms\\Set;\n\nfunction (Set $set) {\n    $set('title', 'Blog Post'); // Set the `title` field to `Blog Post`.\n    //...\n}\n```\n\nWhen this function is run, the state of the title field will be updated, and the form will re-render with the new title. This is useful inside the afterStateUpdated method.\n\n`title``afterStateUpdated`### #Injecting the current form operation\n\nIf you’re writing a form for a panel resource or relation manager, and you wish to check if a form is create, edit or view, use the $operation parameter:\n\n`create``edit``view``$operation````\nfunction (string $operation) {\n    // ...\n}\n```\n\n> Outside the panel, you can set a form’s operation by using the operation() method on the form definition.\n\nOutside the panel, you can set a form’s operation by using the operation() method on the form definition.\n\n`operation()`### #Injecting multiple utilities\n\nThe parameters are injected dynamically using reflection, so you are able to combine multiple parameters in any order:\n\n```\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Set;\nuse Livewire\\Component as Livewire;\n\nfunction (Livewire $livewire, Get $get, Set $set) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting dependencies from Laravel’s container",
                "content": "You may inject anything from Laravel’s container like normal, alongside utilities:\n\n```\nuse Filament\\Forms\\Set;\nuse Illuminate\\Http\\Request;\n\nfunction (Request $request, Set $set) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "## #Field lifecycle",
                "content": "Each field in a form has a lifecycle, which is the process it goes through when the form is loaded, when it is interacted with by the user, and when it is submitted. You may customize what happens at each stage of this lifecycle using a function that gets run at that stage.",
                "level": 3
              },
              {
                "title": "### #Field hydration",
                "content": "Hydration is the process that fills fields with data. It runs when you call the form’s fill() method. You may customize what happens after a field is hydrated using the afterStateHydrated() method.\n\n`fill()``afterStateHydrated()`In this example, the name field will always be hydrated with the correctly capitalized name:\n\n`name````\nuse Closure;\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->required()\n    ->afterStateHydrated(function (TextInput $component, string $state) {\n        $component->state(ucwords($state));\n    })\n```\n\nAs a shortcut for formatting the field’s state like this when it is hydrated, you can use the formatStateUsing() method:\n\n`formatStateUsing()````\nuse Closure;\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->formatStateUsing(fn (string $state): string => ucwords($state))\n```",
                "level": 4
              },
              {
                "title": "### #Field updates",
                "content": "You may use the afterStateUpdated() method to customize what happens after a field is updated by the user. Only changes from the user on the frontend will trigger this function, not manual changes to the state from $set() or another PHP function.\n\n`afterStateUpdated()``$set()`Inside this function, you can also inject the $old value of the field before it was updated, using the $old parameter:\n\n`$old``$old````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->afterStateUpdated(function (?string $state, ?string $old) {\n        // ...\n    })\n```\n\nFor an example of how to use this method, learn how to automatically generate a slug from a title.",
                "level": 4
              },
              {
                "title": "### #Field dehydration",
                "content": "Dehydration is the process that gets data from the fields in your forms, and transforms it. It runs when you call the form’s getState() method.\n\n`getState()`You may customize how the state is transformed when it is dehydrated using the dehydrateStateUsing() function. In this example, the name field will always be dehydrated with the correctly capitalized name:\n\n`dehydrateStateUsing()``name````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('name')\n    ->required()\n    ->dehydrateStateUsing(fn (string $state): string => ucwords($state))\n```",
                "level": 4
              },
              {
                "title": "#### #Preventing a field from being dehydrated",
                "content": "You may also prevent a field from being dehydrated altogether using dehydrated(false). In this example, the field will not be present in the array returned from getState():\n\n`dehydrated(false)``getState()````\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('password_confirmation')\n    ->password()\n    ->dehydrated(false)\n```\n\nIf your form auto-saves data to the database, like in a resource or table action, this is useful to prevent a field from being saved to the database if it is purely used for presentational purposes.",
                "level": 5
              },
              {
                "title": "## #Reactive forms cookbook",
                "content": "This section contains a collection of recipes for common tasks you may need to perform when building an advanced form.",
                "level": 3
              },
              {
                "title": "### #Conditionally hiding a field",
                "content": "To conditionally hide or show a field, you can pass a function to the hidden() method, and return true or false depending on whether you want the field to be hidden or not. The function can inject utilities as parameters, so you can do things like check the value of another field:\n\n`hidden()``true``false````\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Components\\Checkbox;\nuse Filament\\Forms\\Components\\TextInput;\n\nCheckbox::make('is_company')\n    ->live()\n\nTextInput::make('company_name')\n    ->hidden(fn (Get $get): bool => ! $get('is_company'))\n```\n\nIn this example, the is_company checkbox is live(). This allows the form to rerender when the value of the is_company field changes. You can access the value of that field from within the hidden() function using the $get() utility. The value of the field is inverted using ! so that the company_name field is hidden when the is_company field is false.\n\n`is_company``live()``is_company``hidden()``$get()``!``company_name``is_company``false`Alternatively, you can use the visible() method to show a field conditionally. It does the exact inverse of hidden(), and could be used if you prefer the clarity of the code when written this way:\n\n`visible()``hidden()````\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Components\\Checkbox;\nuse Filament\\Forms\\Components\\TextInput;\n\nCheckbox::make('is_company')\n    ->live()\n    \nTextInput::make('company_name')\n    ->visible(fn (Get $get): bool => $get('is_company'))\n```",
                "level": 4
              },
              {
                "title": "### #Conditionally making a field required",
                "content": "To conditionally make a field required, you can pass a function to the required() method, and return true or false depending on whether you want the field to be required or not. The function can inject utilities as parameters, so you can do things like check the value of another field:\n\n`required()``true``false````\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('company_name')\n    ->live(onBlur: true)\n    \nTextInput::make('vat_number')\n    ->required(fn (Get $get): bool => filled($get('company_name')))\n```\n\nIn this example, the company_name field is live(onBlur: true). This allows the form to rerender after the value of the company_name field changes and the user clicks away. You can access the value of that field from within the required() function using the $get() utility. The value of the field is checked using filled() so that the vat_number field is required when the company_name field is not null or an empty string. The result is that the vat_number field is only required when the company_name field is filled in.\n\n`company_name``live(onBlur: true)``company_name``required()``$get()``filled()``vat_number``company_name``null``vat_number``company_name`Using a function is able to make any other validation rule dynamic in a similar way.",
                "level": 4
              },
              {
                "title": "### #Generating a slug from a title",
                "content": "To generate a slug from a title while the user is typing, you can use the afterStateUpdated() method on the title field to $set() the value of the slug field:\n\n`afterStateUpdated()``$set()````\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Set;\nuse Illuminate\\Support\\Str;\n\nTextInput::make('title')\n    ->live(onBlur: true)\n    ->afterStateUpdated(fn (Set $set, ?string $state) => $set('slug', Str::slug($state)))\n    \nTextInput::make('slug')\n```\n\nIn this example, the title field is live(onBlur: true). This allows the form to rerender when the value of the title field changes and the user clicks away. The afterStateUpdated() method is used to run a function after the state of the title field is updated. The function injects the $set() utility and the new state of the title field. The Str::slug() utility method is part of Laravel and is used to generate a slug from a string. The slug field is then updated using the $set() function.\n\n`title``live(onBlur: true)``title``afterStateUpdated()``title``$set()``title``Str::slug()``slug``$set()`One thing to note is that the user may customize the slug manually, and we don’t want to overwrite their changes if the title changes. To prevent this, we can use the old version of the title to work out if the user has modified it themselves. To access the old version of the title, you can inject $old, and to get the current value of the slug before it gets changed, we can use the $get() utility:\n\n`$old``$get()````\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Set;\nuse Illuminate\\Support\\Str;\n\nTextInput::make('title')\n    ->live(onBlur: true)\n    ->afterStateUpdated(function (Get $get, Set $set, ?string $old, ?string $state) {\n        if (($get('slug') ?? '') !== Str::slug($old)) {\n            return;\n        }\n    \n        $set('slug', Str::slug($state));\n    })\n    \nTextInput::make('slug')\n```",
                "level": 4
              },
              {
                "title": "### #Dependant select options",
                "content": "To dynamically update the options of a select field based on the value of another field, you can pass a function to the options() method of the select field. The function can inject utilities as parameters, so you can do things like check the value of another field using the $get() utility:\n\n`options()``$get()````\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Components\\Select;\n\nSelect::make('category')\n    ->options([\n        'web' => 'Web development',\n        'mobile' => 'Mobile development',\n        'design' => 'Design',\n    ])\n    ->live()\n\nSelect::make('sub_category')\n    ->options(fn (Get $get): array => match ($get('category')) {\n        'web' => [\n            'frontend_web' => 'Frontend development',\n            'backend_web' => 'Backend development',\n        ],\n        'mobile' => [\n            'ios_mobile' => 'iOS development',\n            'android_mobile' => 'Android development',\n        ],\n        'design' => [\n            'app_design' => 'Panel design',\n            'marketing_website_design' => 'Marketing website design',\n        ],\n        default => [],\n    })\n```\n\nIn this example, the category field is live(). This allows the form to rerender when the value of the category field changes. You can access the value of that field from within the options() function using the $get() utility. The value of the field is used to determine which options should be available in the sub_category field. The match () statement in PHP is used to return an array of options based on the value of the category field. The result is that the sub_category field will only show options relevant to the selected category field.\n\n`category``live()``category``options()``$get()``sub_category``match ()``category``sub_category``category`You could adapt this example to use options loaded from an Eloquent model or other data source, by querying within the function:\n\n```\nuse Filament\\Forms\\Get;\nuse Filament\\Forms\\Components\\Select;\nuse Illuminate\\Support\\Collection;\n\nSelect::make('category')\n    ->options(Category::query()->pluck('name', 'id'))\n    ->live()\n    \nSelect::make('sub_category')\n    ->options(fn (Get $get): Collection => SubCategory::query()\n        ->where('category', $get('category'))\n        ->pluck('name', 'id'))\n```",
                "level": 4
              },
              {
                "title": "### #Dynamic fields based on a select option",
                "content": "You may wish to render a different set of fields based on the value of a field, like a select. To do this, you can pass a function to the schema() method of any layout component, which checks the value of the field and returns a different schema based on that value. Also, you will need a way to initialise the new fields in the dynamic schema when they are first loaded.\n\n`schema()````\nuse Filament\\Forms\\Components\\FileUpload;\nuse Filament\\Forms\\Components\\Grid;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Get;\n\nSelect::make('type')\n    ->options([\n        'employee' => 'Employee',\n        'freelancer' => 'Freelancer',\n    ])\n    ->live()\n    ->afterStateUpdated(fn (Select $component) => $component\n        ->getContainer()\n        ->getComponent('dynamicTypeFields')\n        ->getChildComponentContainer()\n        ->fill())\n    \nGrid::make(2)\n    ->schema(fn (Get $get): array => match ($get('type')) {\n        'employee' => [\n            TextInput::make('employee_number')\n                ->required(),\n            FileUpload::make('badge')\n                ->image()\n                ->required(),\n        ],\n        'freelancer' => [\n            TextInput::make('hourly_rate')\n                ->numeric()\n                ->required()\n                ->prefix('€'),\n            FileUpload::make('contract')\n                ->required(),\n        ],\n        default => [],\n    })\n    ->key('dynamicTypeFields')\n```\n\nIn this example, the type field is live(). This allows the form to rerender when the value of the type field changes. The afterStateUpdated() method is used to run a function after the state of the type field is updated. In this case, we inject the current select field instance, which we can then use to get the form “container” instance that holds both the select and the grid components. With this container, we can target the grid component using a unique key (dynamicTypeFields) that we have assigned to it. With that grid component instance, we can call fill(), just as we do on a normal form to initialise it. The schema() method of the grid component is then used to return a different schema based on the value of the type field. This is done by using the $get() utility, and returning a different schema array dynamically.\n\n`type``live()``type``afterStateUpdated()``type``dynamicTypeFields``fill()``schema()``type``$get()`### #Auto-hashing password field\n\nYou have a password field:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\n\nTextInput::make('password')\n    ->password()\n```\n\nAnd you can use a dehydration function to hash the password when the form is submitted:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\Facades\\Hash;\n\nTextInput::make('password')\n    ->password()\n    ->dehydrateStateUsing(fn (string $state): string => Hash::make($state))\n```\n\nBut if your form is used to change an existing password, you don’t want to overwrite the existing password if the field is empty. You can prevent the field from being dehydrated if the field is null or an empty string (using the filled() helper):\n\n`filled()````\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\Facades\\Hash;\n\nTextInput::make('password')\n    ->password()\n    ->dehydrateStateUsing(fn (string $state): string => Hash::make($state))\n    ->dehydrated(fn (?string $state): bool => filled($state))\n```\n\nHowever, you want to require the password to be filled when the user is being created, by injecting the $operation utility, and then conditionally making the field required:\n\n`$operation````\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\Facades\\Hash;\n\nTextInput::make('password')\n    ->password()\n    ->dehydrateStateUsing(fn (string $state): string => Hash::make($state))\n    ->dehydrated(fn (?string $state): bool => filled($state))\n    ->required(fn (string $operation): bool => $operation === 'create')\n```",
                "level": 4
              },
              {
                "title": "## #Saving data to relationships",
                "content": "> If you’re building a form inside your Livewire component, make sure you have set up the form’s model. Otherwise, Filament doesn’t know which model to use to retrieve the relationship from.\n\nIf you’re building a form inside your Livewire component, make sure you have set up the form’s model. Otherwise, Filament doesn’t know which model to use to retrieve the relationship from.\n\nAs well as being able to give structure to fields, layout components are also able to “teleport” their nested fields into a relationship. Filament will handle loading data from a HasOne, BelongsTo or MorphOne Eloquent relationship, and then it will save the data back to the same relationship. To set this behavior up, you can use the relationship() method on any layout component:\n\n`HasOne``BelongsTo``MorphOne``relationship()````\nuse Filament\\Forms\\Components\\Fieldset;\nuse Filament\\Forms\\Components\\FileUpload;\nuse Filament\\Forms\\Components\\Textarea;\nuse Filament\\Forms\\Components\\TextInput;\n\nFieldset::make('Metadata')\n    ->relationship('metadata')\n    ->schema([\n        TextInput::make('title'),\n        Textarea::make('description'),\n        FileUpload::make('image'),\n    ])\n```\n\nIn this example, the title, description and image are automatically loaded from the metadata relationship, and saved again when the form is submitted. If the metadata record does not exist, it is automatically created.\n\n`title``description``image``metadata``metadata`This functionality is not just limited to fieldsets - you can use it with any layout component. For example, you could use a Group component which has no styling associated with it:\n\n`Group````\nuse Filament\\Forms\\Components\\Group;\nuse Filament\\Forms\\Components\\TextInput;\n\nGroup::make()\n    ->relationship('customer')\n    ->schema([\n        TextInput::make('name')\n            ->label('Customer')\n            ->required(),\n        TextInput::make('email')\n            ->label('Email address')\n            ->email()\n            ->required(),\n    ])\n```",
                "level": 3
              },
              {
                "title": "### #Saving data to a BelongsTo relationship",
                "content": "`BelongsTo`Please note that if you are saving the data to a BelongsTo relationship, then the foreign key column in your database must be nullable(). This is because Filament saves the form first, before saving the relationship. Since the form is saved first, the foreign ID does not exist yet, so it must be nullable. Immediately after the form is saved, Filament saves the relationship, which will then fill in the foreign ID and save it again.\n\n`BelongsTo``nullable()`It is worth noting that if you have an observer on your form model, then you may need to adapt it to ensure that it does not depend on the relationship existing when it is created. For example, if you have an observer that sends an email to a related record when a form is created, you may need to switch to using a different hook that runs after the relationship is attached, like updated().\n\n`updated()`### #Conditionally saving data to a relationship\n\nSometimes, saving the related record may be optional. If the user fills out the customer fields, then the customer will be created / updated. Otherwise, the customer will not be created, or will be deleted if it already exists. To do this, you can pass a condition function as an argument to relationship(), which can use the $state of the related form to determine whether the relationship should be saved or not:\n\n`condition``relationship()``$state````\nuse Filament\\Forms\\Components\\Group;\nuse Filament\\Forms\\Components\\TextInput;\n\nGroup::make()\n    ->relationship(\n        'customer',\n        condition: fn (?array $state): bool => filled($state['name']),\n    )\n    ->schema([\n        TextInput::make('name')\n            ->label('Customer'),\n        TextInput::make('email')\n            ->label('Email address')\n            ->email()\n            ->requiredWith('name'),\n    ])\n```\n\nIn this example, the customer’s name is not required(), and the email address is only required when the name is filled. The condition function is used to check whether the name field is filled, and if it is, then the customer will be created / updated. Otherwise, the customer will not be created, or will be deleted if it already exists.\n\n`required()``name``condition``name`## #Inserting Livewire components into a form\n\nYou may insert a Livewire component directly into a form:\n\n```\nuse Filament\\Forms\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)\n```\n\nIf you are rendering multiple of the same Livewire component, please make sure to pass a unique key() to each:\n\n`key()````\nuse Filament\\Forms\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)\n    ->key('foo-first')\n\nLivewire::make(Foo::class)\n    ->key('foo-second')\n\nLivewire::make(Foo::class)\n    ->key('foo-third')\n```",
                "level": 4
              },
              {
                "title": "### #Passing parameters to a Livewire component",
                "content": "You can pass an array of parameters to a Livewire component:\n\n```\nuse Filament\\Forms\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class, ['bar' => 'baz'])\n```\n\nNow, those parameters will be passed to the Livewire component’s mount() method:\n\n`mount()````\nclass Foo extends Component\n{\n    public function mount(string $bar): void\n    {       \n        // ...\n    }\n}\n```\n\nAlternatively, they will be available as public properties on the Livewire component:\n\n```\nclass Foo extends Component\n{\n    public string $bar;\n}\n```",
                "level": 4
              },
              {
                "title": "#### #Accessing the current record in the Livewire component",
                "content": "You can access the current record in the Livewire component using the $record parameter in the mount() method, or the $record property:\n\n`$record``mount()``$record````\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Foo extends Component\n{\n    public function mount(?Model $record = null): void\n    {       \n        // ...\n    }\n    \n    // or\n    \n    public ?Model $record = null;\n}\n```\n\nPlease be aware that when the record has not yet been created, it will be null. If you’d like to hide the Livewire component when the record is null, you can use the hidden() method:\n\n`null``null``hidden()````\nuse Filament\\Forms\\Components\\Livewire;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nLivewire::make(Foo::class)\n    ->hidden(fn (?Model $record): bool => $record === null)\n```",
                "level": 5
              },
              {
                "title": "### #Lazy loading a Livewire component",
                "content": "You may allow the component to lazily load using the lazy() method:\n\n`lazy()````\nuse Filament\\Forms\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)->lazy()\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "The basics of reactivity",
              "Debouncing reactive fields",
              "Injecting the current state of a field",
              "Injecting the current form component instance",
              "Injecting the current Livewire component instance",
              "Injecting the current form record",
              "Injecting the state of another field",
              "Injecting a function to set the state of another field",
              "Injecting dependencies from Laravel’s container"
            ],
            "code_examples_count": 82,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "adding-a-form-to-a-livewire-component": {
          "metadata": {
            "title": "Adding A Form To A Livewire Component",
            "url": "https://filamentphp.com/docs/3.x/forms/adding-a-form-to-a-livewire-component",
            "section": "forms",
            "word_count": 1520,
            "character_count": 11856
          },
          "content": {
            "full_text": "\n# Adding a form to a Livewire component - Forms - Filament\n\nForms\n\n# Adding a form to a Livewire component\n\n## #Setting up the Livewire component\n\nFirst, generate a new Livewire component:\n\n```\nphp artisan make:livewire CreatePost\n```\n\nThen, render your Livewire component on the page:\n\n```\n@livewire('create-post')\n```\n\nAlternatively, you can use a full-page Livewire component:\n\n```\nuse App\\Livewire\\CreatePost;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('posts/create', CreatePost::class);\n```\n\n## #Adding the form\n\nThere are 5 main tasks when adding a form to a Livewire component class. Each one is essential:\n\n- Implement the HasForms interface and use the InteractsWithForms trait.\n- Define a public Livewire property to store your form’s data. In our example, we’ll call this $data, but you can call it whatever you want.\n- Add a form() method, which is where you configure the form. Add the form’s schema, and tell Filament to store the form data in the $data property (using statePath('data')).\n- Initialize the form with $this->form->fill() in mount(). This is imperative for every form that you build, even if it doesn’t have any initial data.\n- Define a method to handle the form submission. In our example, we’ll call this create(), but you can call it whatever you want. Inside that method, you can validate and get the form’s data using $this->form->getState(). It’s important that you use this method instead of accessing the $this->data property directly, because the form’s data needs to be validated and transformed into a useful format before being returned.\n\n`HasForms``InteractsWithForms``$data``form()``$data``statePath('data')``$this->form->fill()``mount()``create()``$this->form->getState()``$this->data````\n<?php\n\nnamespace App\\Livewire;\n\nuse App\\Models\\Post;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Components\\MarkdownEditor;\nuse Filament\\Forms\\Concerns\\InteractsWithForms;\nuse Filament\\Forms\\Contracts\\HasForms;\nuse Filament\\Forms\\Form;\nuse Illuminate\\Contracts\\View\\View;\nuse Livewire\\Component;\n\nclass CreatePost extends Component implements HasForms\n{\n    use InteractsWithForms;\n    \n    public ?array $data = [];\n    \n    public function mount(): void\n    {\n        $this->form->fill();\n    }\n    \n    public function form(Form $form): Form\n    {\n        return $form\n            ->schema([\n                TextInput::make('title')\n                    ->required(),\n                MarkdownEditor::make('content'),\n                // ...\n            ])\n            ->statePath('data');\n    }\n    \n    public function create(): void\n    {\n        dd($this->form->getState());\n    }\n    \n    public function render(): View\n    {\n        return view('livewire.create-post');\n    }\n}\n```\n\nFinally, in your Livewire component’s view, render the form:\n\n```\n<div>\n    <form wire:submit=\"create\">\n        {{ $this->form }}\n        \n        <button type=\"submit\">\n            Submit\n        </button>\n    </form>\n    \n    <x-filament-actions::modals />\n</div>\n```\n\n> <x-filament-actions::modals /> is used to render form component action modals. The code can be put anywhere outside the <form> element, as long as it’s within the Livewire component.\n\n<x-filament-actions::modals /> is used to render form component action modals. The code can be put anywhere outside the <form> element, as long as it’s within the Livewire component.\n\n`<x-filament-actions::modals />``<form>`Visit your Livewire component in the browser, and you should see the form components from schema():\n\n`schema()`Submit the form with data, and you’ll see the form’s data dumped to the screen. You can save the data to a model instead of dumping it:\n\n```\nuse App\\Models\\Post;\n\npublic function create(): void\n{\n    Post::create($this->form->getState());\n}\n```\n\n## #Initializing the form with data\n\nTo fill the form with data, just pass that data to the $this->form->fill() method. For example, if you’re editing an existing post, you might do something like this:\n\n`$this->form->fill()````\nuse App\\Models\\Post;\n\npublic function mount(Post $post): void\n{\n    $this->form->fill($post->attributesToArray());\n}\n```\n\nIt’s important that you use the $this->form->fill() method instead of assigning the data directly to the $this->data property. This is because the post’s data needs to be internally transformed into a useful format before being stored.\n\n`$this->form->fill()``$this->data`## #Setting a form model\n\nGiving the $form access to a model is useful for a few reasons:\n\n`$form`- It allows fields within that form to load information from that model. For example, select fields can load their options from the database automatically.\n- The form can load and save the model’s relationship data automatically. For example, you have an Edit Post form, with a Repeater which manages comments associated with that post. Filament will automatically load the comments for that post when you call $this->form->fill([...]), and save them back to the relationship when you call $this->form->getState().\n- Validation rules like exists() and unique() can automatically retrieve the database table name from the model.\n\n`$this->form->fill([...])``$this->form->getState()``exists()``unique()`It is advised to always pass the model to the form when there is one. As explained, it unlocks many new powers of the Filament Form Builder.\n\nTo pass the model to the form, use the $form->model() method:\n\n`$form->model()````\nuse App\\Models\\Post;\nuse Filament\\Forms\\Form;\n\npublic Post $post;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            // ...\n        ])\n        ->statePath('data')\n        ->model($this->post);\n}\n```\n\n### #Passing the form model after the form has been submitted\n\nIn some cases, the form’s model is not available until the form has been submitted. For example, in a Create Post form, the post does not exist until the form has been submitted. Therefore, you can’t pass it in to $form->model(). However, you can pass a model class instead:\n\n`$form->model()````\nuse App\\Models\\Post;\nuse Filament\\Forms\\Form;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            // ...\n        ])\n        ->statePath('data')\n        ->model(Post::class);\n}\n```\n\nOn its own, this isn’t as powerful as passing a model instance. For example, relationships won’t be saved to the post after it is created. To do that, you’ll need to pass the post to the form after it has been created, and call saveRelationships() to save the relationships to it:\n\n`saveRelationships()````\nuse App\\Models\\Post;\n\npublic function create(): void\n{\n    $post = Post::create($this->form->getState());\n    \n    // Save the relationships from the form to the post after it is created.\n    $this->form->model($post)->saveRelationships();\n}\n```\n\n## #Saving form data to individual properties\n\nIn all of our previous examples, we’ve been saving the form’s data to the public $data property on the Livewire component. However, you can save the data to individual properties instead. For example, if you have a form with a title field, you can save the form’s data to the $title property instead. To do this, don’t pass a statePath() to the form at all. Ensure that all of your fields have their own public properties on the class.\n\n`$data``title``$title``statePath()````\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Components\\MarkdownEditor;\nuse Filament\\Forms\\Form;\n\npublic ?string $title = null;\n\npublic ?string $content = null;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            TextInput::make('title')\n                ->required(),\n            MarkdownEditor::make('content'),\n            // ...\n        ]);\n}\n```\n\n## #Using multiple forms\n\nBy default, the InteractsWithForms trait only handles one form per Livewire component - form(). To add more forms to the Livewire component, you can define them in the getForms() method, and return an array containing the name of each form:\n\n`InteractsWithForms``form()``getForms()````\nprotected function getForms(): array\n{\n    return [\n        'editPostForm',\n        'createCommentForm',\n    ];\n}\n```\n\nEach of these forms can now be defined within the Livewire component, using a method with the same name:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Components\\MarkdownEditor;\nuse Filament\\Forms\\Form;\n\npublic function editPostForm(Form $form): Form\n{\n    return $form\n        ->schema([\n            TextInput::make('title')\n                ->required(),\n            MarkdownEditor::make('content'),\n            // ...\n        ])\n        ->statePath('postData')\n        ->model($this->post);\n}\n\npublic function createCommentForm(Form $form): Form\n{\n    return $form\n        ->schema([\n            TextInput::make('name')\n                ->required(),\n            TextInput::make('email')\n                ->email()\n                ->required(),\n            MarkdownEditor::make('content')\n                ->required(),\n            // ...\n        ])\n        ->statePath('commentData')\n        ->model(Comment::class);\n}\n```\n\nNow, each form is addressable by its name instead of form. For example, to fill the post form, you can use $this->editPostForm->fill([...]), or to get the data from the comment form you can use $this->createCommentForm->getState().\n\n`form``$this->editPostForm->fill([...])``$this->createCommentForm->getState()`You’ll notice that each form has its own unique statePath(). Each form will write its state to a different array on your Livewire component, so it’s important to define these:\n\n`statePath()````\npublic ?array $postData = [];\npublic ?array $commentData = [];\n```\n\n## #Resetting a form’s data\n\nYou can reset a form back to its default data at any time by calling $this->form->fill(). For example, you may wish to clear the contents of a form every time it’s submitted:\n\n`$this->form->fill()````\nuse App\\Models\\Comment;\n\npublic function createComment(): void\n{\n    Comment::create($this->form->getState());\n\n    // Reinitialize the form to clear its data.\n    $this->form->fill();\n}\n```\n\n## #Generating form Livewire components with the CLI\n\nIt’s advised that you learn how to set up a Livewire component with the Form Builder manually, but once you are confident, you can use the CLI to generate a form for you.\n\n```\nphp artisan make:livewire-form RegistrationForm\n```\n\nThis will generate a new app/Livewire/RegistrationForm.php component, which you can customize.\n\n`app/Livewire/RegistrationForm.php`### #Generating a form for an Eloquent model\n\nFilament is also able to generate forms for a specific Eloquent model. These are more powerful, as they will automatically save the data in the form for you, and ensure the form fields are properly configured to access that model.\n\nWhen generating a form with the make:livewire-form command, it will ask for the name of the model:\n\n`make:livewire-form````\nphp artisan make:livewire-form Products/CreateProduct\n```\n\n#### #Generating an edit form for an Eloquent record\n\nBy default, passing a model to the make:livewire-form command will result in a form that creates a new record in your database. If you pass the --edit flag to the command, it will generate an edit form for a specific record. This will automatically fill the form with the data from the record, and save the data back to the model when the form is submitted.\n\n`make:livewire-form``--edit````\nphp artisan make:livewire-form Products/EditProduct --edit\n```\n\n### #Automatically generating form schemas\n\nFilament is also able to guess which form fields you want in the schema, based on the model’s database columns. You can use the --generate flag when generating your form:\n\n`--generate````\nphp artisan make:livewire-form Products/CreateProduct --generate\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Adding a form to a Livewire component - Forms - Filament",
                "content": "Forms",
                "level": 1
              },
              {
                "title": "# Adding a form to a Livewire component",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Setting up the Livewire component",
                "content": "First, generate a new Livewire component:\n\n```\nphp artisan make:livewire CreatePost\n```\n\nThen, render your Livewire component on the page:\n\n```\n@livewire('create-post')\n```\n\nAlternatively, you can use a full-page Livewire component:\n\n```\nuse App\\Livewire\\CreatePost;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('posts/create', CreatePost::class);\n```",
                "level": 3
              },
              {
                "title": "## #Adding the form",
                "content": "There are 5 main tasks when adding a form to a Livewire component class. Each one is essential:\n\n- Implement the HasForms interface and use the InteractsWithForms trait.\n- Define a public Livewire property to store your form’s data. In our example, we’ll call this $data, but you can call it whatever you want.\n- Add a form() method, which is where you configure the form. Add the form’s schema, and tell Filament to store the form data in the $data property (using statePath('data')).\n- Initialize the form with $this->form->fill() in mount(). This is imperative for every form that you build, even if it doesn’t have any initial data.\n- Define a method to handle the form submission. In our example, we’ll call this create(), but you can call it whatever you want. Inside that method, you can validate and get the form’s data using $this->form->getState(). It’s important that you use this method instead of accessing the $this->data property directly, because the form’s data needs to be validated and transformed into a useful format before being returned.\n\n`HasForms``InteractsWithForms``$data``form()``$data``statePath('data')``$this->form->fill()``mount()``create()``$this->form->getState()``$this->data````\n<?php\n\nnamespace App\\Livewire;\n\nuse App\\Models\\Post;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Components\\MarkdownEditor;\nuse Filament\\Forms\\Concerns\\InteractsWithForms;\nuse Filament\\Forms\\Contracts\\HasForms;\nuse Filament\\Forms\\Form;\nuse Illuminate\\Contracts\\View\\View;\nuse Livewire\\Component;\n\nclass CreatePost extends Component implements HasForms\n{\n    use InteractsWithForms;\n    \n    public ?array $data = [];\n    \n    public function mount(): void\n    {\n        $this->form->fill();\n    }\n    \n    public function form(Form $form): Form\n    {\n        return $form\n            ->schema([\n                TextInput::make('title')\n                    ->required(),\n                MarkdownEditor::make('content'),\n                // ...\n            ])\n            ->statePath('data');\n    }\n    \n    public function create(): void\n    {\n        dd($this->form->getState());\n    }\n    \n    public function render(): View\n    {\n        return view('livewire.create-post');\n    }\n}\n```\n\nFinally, in your Livewire component’s view, render the form:\n\n```\n<div>\n    <form wire:submit=\"create\">\n        {{ $this->form }}\n        \n        <button type=\"submit\">\n            Submit\n        </button>\n    </form>\n    \n    <x-filament-actions::modals />\n</div>\n```\n\n> <x-filament-actions::modals /> is used to render form component action modals. The code can be put anywhere outside the <form> element, as long as it’s within the Livewire component.\n\n<x-filament-actions::modals /> is used to render form component action modals. The code can be put anywhere outside the <form> element, as long as it’s within the Livewire component.\n\n`<x-filament-actions::modals />``<form>`Visit your Livewire component in the browser, and you should see the form components from schema():\n\n`schema()`Submit the form with data, and you’ll see the form’s data dumped to the screen. You can save the data to a model instead of dumping it:\n\n```\nuse App\\Models\\Post;\n\npublic function create(): void\n{\n    Post::create($this->form->getState());\n}\n```",
                "level": 3
              },
              {
                "title": "## #Initializing the form with data",
                "content": "To fill the form with data, just pass that data to the $this->form->fill() method. For example, if you’re editing an existing post, you might do something like this:\n\n`$this->form->fill()````\nuse App\\Models\\Post;\n\npublic function mount(Post $post): void\n{\n    $this->form->fill($post->attributesToArray());\n}\n```\n\nIt’s important that you use the $this->form->fill() method instead of assigning the data directly to the $this->data property. This is because the post’s data needs to be internally transformed into a useful format before being stored.\n\n`$this->form->fill()``$this->data`## #Setting a form model\n\nGiving the $form access to a model is useful for a few reasons:\n\n`$form`- It allows fields within that form to load information from that model. For example, select fields can load their options from the database automatically.\n- The form can load and save the model’s relationship data automatically. For example, you have an Edit Post form, with a Repeater which manages comments associated with that post. Filament will automatically load the comments for that post when you call $this->form->fill([...]), and save them back to the relationship when you call $this->form->getState().\n- Validation rules like exists() and unique() can automatically retrieve the database table name from the model.\n\n`$this->form->fill([...])``$this->form->getState()``exists()``unique()`It is advised to always pass the model to the form when there is one. As explained, it unlocks many new powers of the Filament Form Builder.\n\nTo pass the model to the form, use the $form->model() method:\n\n`$form->model()````\nuse App\\Models\\Post;\nuse Filament\\Forms\\Form;\n\npublic Post $post;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            // ...\n        ])\n        ->statePath('data')\n        ->model($this->post);\n}\n```",
                "level": 3
              },
              {
                "title": "### #Passing the form model after the form has been submitted",
                "content": "In some cases, the form’s model is not available until the form has been submitted. For example, in a Create Post form, the post does not exist until the form has been submitted. Therefore, you can’t pass it in to $form->model(). However, you can pass a model class instead:\n\n`$form->model()````\nuse App\\Models\\Post;\nuse Filament\\Forms\\Form;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            // ...\n        ])\n        ->statePath('data')\n        ->model(Post::class);\n}\n```\n\nOn its own, this isn’t as powerful as passing a model instance. For example, relationships won’t be saved to the post after it is created. To do that, you’ll need to pass the post to the form after it has been created, and call saveRelationships() to save the relationships to it:\n\n`saveRelationships()````\nuse App\\Models\\Post;\n\npublic function create(): void\n{\n    $post = Post::create($this->form->getState());\n    \n    // Save the relationships from the form to the post after it is created.\n    $this->form->model($post)->saveRelationships();\n}\n```",
                "level": 4
              },
              {
                "title": "## #Saving form data to individual properties",
                "content": "In all of our previous examples, we’ve been saving the form’s data to the public $data property on the Livewire component. However, you can save the data to individual properties instead. For example, if you have a form with a title field, you can save the form’s data to the $title property instead. To do this, don’t pass a statePath() to the form at all. Ensure that all of your fields have their own public properties on the class.\n\n`$data``title``$title``statePath()````\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Components\\MarkdownEditor;\nuse Filament\\Forms\\Form;\n\npublic ?string $title = null;\n\npublic ?string $content = null;\n\npublic function form(Form $form): Form\n{\n    return $form\n        ->schema([\n            TextInput::make('title')\n                ->required(),\n            MarkdownEditor::make('content'),\n            // ...\n        ]);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Using multiple forms",
                "content": "By default, the InteractsWithForms trait only handles one form per Livewire component - form(). To add more forms to the Livewire component, you can define them in the getForms() method, and return an array containing the name of each form:\n\n`InteractsWithForms``form()``getForms()````\nprotected function getForms(): array\n{\n    return [\n        'editPostForm',\n        'createCommentForm',\n    ];\n}\n```\n\nEach of these forms can now be defined within the Livewire component, using a method with the same name:\n\n```\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Components\\MarkdownEditor;\nuse Filament\\Forms\\Form;\n\npublic function editPostForm(Form $form): Form\n{\n    return $form\n        ->schema([\n            TextInput::make('title')\n                ->required(),\n            MarkdownEditor::make('content'),\n            // ...\n        ])\n        ->statePath('postData')\n        ->model($this->post);\n}\n\npublic function createCommentForm(Form $form): Form\n{\n    return $form\n        ->schema([\n            TextInput::make('name')\n                ->required(),\n            TextInput::make('email')\n                ->email()\n                ->required(),\n            MarkdownEditor::make('content')\n                ->required(),\n            // ...\n        ])\n        ->statePath('commentData')\n        ->model(Comment::class);\n}\n```\n\nNow, each form is addressable by its name instead of form. For example, to fill the post form, you can use $this->editPostForm->fill([...]), or to get the data from the comment form you can use $this->createCommentForm->getState().\n\n`form``$this->editPostForm->fill([...])``$this->createCommentForm->getState()`You’ll notice that each form has its own unique statePath(). Each form will write its state to a different array on your Livewire component, so it’s important to define these:\n\n`statePath()````\npublic ?array $postData = [];\npublic ?array $commentData = [];\n```",
                "level": 3
              },
              {
                "title": "## #Resetting a form’s data",
                "content": "You can reset a form back to its default data at any time by calling $this->form->fill(). For example, you may wish to clear the contents of a form every time it’s submitted:\n\n`$this->form->fill()````\nuse App\\Models\\Comment;\n\npublic function createComment(): void\n{\n    Comment::create($this->form->getState());\n\n    // Reinitialize the form to clear its data.\n    $this->form->fill();\n}\n```",
                "level": 3
              },
              {
                "title": "## #Generating form Livewire components with the CLI",
                "content": "It’s advised that you learn how to set up a Livewire component with the Form Builder manually, but once you are confident, you can use the CLI to generate a form for you.\n\n```\nphp artisan make:livewire-form RegistrationForm\n```\n\nThis will generate a new app/Livewire/RegistrationForm.php component, which you can customize.\n\n`app/Livewire/RegistrationForm.php`### #Generating a form for an Eloquent model\n\nFilament is also able to generate forms for a specific Eloquent model. These are more powerful, as they will automatically save the data in the form for you, and ensure the form fields are properly configured to access that model.\n\nWhen generating a form with the make:livewire-form command, it will ask for the name of the model:\n\n`make:livewire-form````\nphp artisan make:livewire-form Products/CreateProduct\n```",
                "level": 3
              },
              {
                "title": "#### #Generating an edit form for an Eloquent record",
                "content": "By default, passing a model to the make:livewire-form command will result in a form that creates a new record in your database. If you pass the --edit flag to the command, it will generate an edit form for a specific record. This will automatically fill the form with the data from the record, and save the data back to the model when the form is submitted.\n\n`make:livewire-form``--edit````\nphp artisan make:livewire-form Products/EditProduct --edit\n```",
                "level": 5
              },
              {
                "title": "### #Automatically generating form schemas",
                "content": "Filament is also able to guess which form fields you want in the schema, based on the model’s database columns. You can use the --generate flag when generating your form:\n\n`--generate````\nphp artisan make:livewire-form Products/CreateProduct --generate\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Setting up the Livewire component",
              "Adding the form",
              "Initializing the form with data",
              "Passing the form model after the form has been submitted",
              "Saving form data to individual properties",
              "Using multiple forms",
              "Resetting a form’s data",
              "Generating form Livewire components with the CLI",
              "Automatically generating form schemas"
            ],
            "code_examples_count": 38,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "testing": {
          "metadata": {
            "title": "Testing",
            "url": "https://filamentphp.com/docs/3.x/forms/testing",
            "section": "forms",
            "word_count": 1994,
            "character_count": 20837
          },
          "content": {
            "full_text": "\n# Testing - Forms - Filament\n\nForms\n\n# Testing\n\n## #Overview\n\nAll examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\nSince the Form Builder works on Livewire components, you can use the Livewire testing helpers. However, we have custom testing helpers that you can use with forms:\n\n## #Filling a form\n\nTo fill a form with data, pass the data to fillForm():\n\n`fillForm()````\nuse function Pest\\Livewire\\livewire;\n\nlivewire(CreatePost::class)\n    ->fillForm([\n        'title' => fake()->sentence(),\n        // ...\n    ]);\n```\n\n> If you have multiple forms on a Livewire component, you can specify which form you want to fill using fillForm([...], 'createPostForm').\n\nIf you have multiple forms on a Livewire component, you can specify which form you want to fill using fillForm([...], 'createPostForm').\n\n`fillForm([...], 'createPostForm')`To check that a form has data, use assertFormSet():\n\n`assertFormSet()````\nuse Illuminate\\Support\\Str;\nuse function Pest\\Livewire\\livewire;\n\nit('can automatically generate a slug from the title', function () {\n    $title = fake()->sentence();\n\n    livewire(CreatePost::class)\n        ->fillForm([\n            'title' => $title,\n        ])\n        ->assertFormSet([\n            'slug' => Str::slug($title),\n        ]);\n});\n```\n\n> If you have multiple forms on a Livewire component, you can specify which form you want to check using assertFormSet([...], 'createPostForm').\n\nIf you have multiple forms on a Livewire component, you can specify which form you want to check using assertFormSet([...], 'createPostForm').\n\n`assertFormSet([...], 'createPostForm')`You may also find it useful to pass a function to the assertFormSet() method, which allows you to access the form $state and perform additional assertions:\n\n`assertFormSet()``$state````\nuse Illuminate\\Support\\Str;\nuse function Pest\\Livewire\\livewire;\n\nit('can automatically generate a slug from the title without any spaces', function () {\n    $title = fake()->sentence();\n\n    livewire(CreatePost::class)\n        ->fillForm([\n            'title' => $title,\n        ])\n        ->assertFormSet(function (array $state): array {\n            expect($state['slug'])\n                ->not->toContain(' ');\n                \n            return [\n                'slug' => Str::slug($title),\n            ];\n        });\n});\n```\n\nYou can return an array from the function if you want Filament to continue to assert the form state after the function has been run.\n\n## #Validation\n\nUse assertHasFormErrors() to ensure that data is properly validated in a form:\n\n`assertHasFormErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate input', function () {\n    livewire(CreatePost::class)\n        ->fillForm([\n            'title' => null,\n        ])\n        ->call('create')\n        ->assertHasFormErrors(['title' => 'required']);\n});\n```\n\nAnd assertHasNoFormErrors() to ensure there are no validation errors:\n\n`assertHasNoFormErrors()````\nuse function Pest\\Livewire\\livewire;\n\nlivewire(CreatePost::class)\n    ->fillForm([\n        'title' => fake()->sentence(),\n        // ...\n    ])\n    ->call('create')\n    ->assertHasNoFormErrors();\n```\n\n> If you have multiple forms on a Livewire component, you can pass the name of a specific form as the second parameter like assertHasFormErrors(['title' => 'required'], 'createPostForm') or assertHasNoFormErrors([], 'createPostForm').\n\nIf you have multiple forms on a Livewire component, you can pass the name of a specific form as the second parameter like assertHasFormErrors(['title' => 'required'], 'createPostForm') or assertHasNoFormErrors([], 'createPostForm').\n\n`assertHasFormErrors(['title' => 'required'], 'createPostForm')``assertHasNoFormErrors([], 'createPostForm')`## #Form existence\n\nTo check that a Livewire component has a form, use assertFormExists():\n\n`assertFormExists()````\nuse function Pest\\Livewire\\livewire;\n\nit('has a form', function () {\n    livewire(CreatePost::class)\n        ->assertFormExists();\n});\n```\n\n> If you have multiple forms on a Livewire component, you can pass the name of a specific form like assertFormExists('createPostForm').\n\nIf you have multiple forms on a Livewire component, you can pass the name of a specific form like assertFormExists('createPostForm').\n\n`assertFormExists('createPostForm')`## #Fields\n\nTo ensure that a form has a given field, pass the field name to assertFormFieldExists():\n\n`assertFormFieldExists()````\nuse function Pest\\Livewire\\livewire;\n\nit('has a title field', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldExists('title');\n});\n```\n\nYou may pass a function as an additional argument in order to assert that a field passes a given “truth test”. This is useful for asserting that a field has a specific configuration:\n\n```\nuse function Pest\\Livewire\\livewire;\n\nit('has a title field', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldExists('title', function (TextInput $field): bool {\n            return $field->isDisabled();\n        });\n});\n```\n\nTo assert that a form does not have a given field, pass the field name to assertFormFieldDoesNotExist():\n\n`assertFormFieldDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('does not have a conditional field', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldDoesNotExist('no-such-field');\n});\n```\n\n> If you have multiple forms on a Livewire component, you can specify which form you want to check for the existence of the field like assertFormFieldExists('title', 'createPostForm').\n\nIf you have multiple forms on a Livewire component, you can specify which form you want to check for the existence of the field like assertFormFieldExists('title', 'createPostForm').\n\n`assertFormFieldExists('title', 'createPostForm')`### #Hidden fields\n\nTo ensure that a field is visible, pass the name to assertFormFieldIsVisible():\n\n`assertFormFieldIsVisible()````\nuse function Pest\\Livewire\\livewire;\n\ntest('title is visible', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldIsVisible('title');\n});\n```\n\nOr to ensure that a field is hidden you can pass the name to assertFormFieldIsHidden():\n\n`assertFormFieldIsHidden()````\nuse function Pest\\Livewire\\livewire;\n\ntest('title is hidden', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldIsHidden('title');\n});\n```\n\n> For both assertFormFieldIsHidden() and assertFormFieldIsVisible() you can pass the name of a specific form the field belongs to as the second argument like assertFormFieldIsHidden('title', 'createPostForm').\n\nFor both assertFormFieldIsHidden() and assertFormFieldIsVisible() you can pass the name of a specific form the field belongs to as the second argument like assertFormFieldIsHidden('title', 'createPostForm').\n\n`assertFormFieldIsHidden()``assertFormFieldIsVisible()``assertFormFieldIsHidden('title', 'createPostForm')`### #Disabled fields\n\nTo ensure that a field is enabled, pass the name to assertFormFieldIsEnabled():\n\n`assertFormFieldIsEnabled()````\nuse function Pest\\Livewire\\livewire;\n\ntest('title is enabled', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldIsEnabled('title');\n});\n```\n\nOr to ensure that a field is disabled you can pass the name to assertFormFieldIsDisabled():\n\n`assertFormFieldIsDisabled()````\nuse function Pest\\Livewire\\livewire;\n\ntest('title is disabled', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldIsDisabled('title');\n});\n```\n\n> For both assertFormFieldIsEnabled() and assertFormFieldIsDisabled() you can pass the name of a specific form the field belongs to as the second argument like assertFormFieldIsEnabled('title', 'createPostForm').\n\nFor both assertFormFieldIsEnabled() and assertFormFieldIsDisabled() you can pass the name of a specific form the field belongs to as the second argument like assertFormFieldIsEnabled('title', 'createPostForm').\n\n`assertFormFieldIsEnabled()``assertFormFieldIsDisabled()``assertFormFieldIsEnabled('title', 'createPostForm')`## #Layout components\n\nIf you need to check if a particular layout component exists rather than a field, you may use assertFormComponentExists().  As layout components do not have names, this method uses the key() provided by the developer:\n\n`assertFormComponentExists()``key()````\nuse Filament\\Forms\\Components\\Section;\n\nSection::make('Comments')\n    ->key('comments-section')\n    ->schema([\n        //\n    ])\n```\n\n```\nuse function Pest\\Livewire\\livewire;\n\ntest('comments section exists', function () {\n    livewire(EditPost::class)\n        ->assertFormComponentExists('comments-section');\n});\n```\n\nTo assert that a form does not have a given component, pass the component key to assertFormComponentDoesNotExist():\n\n`assertFormComponentDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('does not have a conditional component', function () {\n    livewire(CreatePost::class)\n        ->assertFormComponentDoesNotExist('no-such-section');\n});\n```\n\nTo check if the component exists and passes a given truth test, you can pass a function to the second argument of assertFormComponentExists(), returning true or false if the component passes the test or not:\n\n`assertFormComponentExists()````\nuse Filament\\Forms\\Components\\Component;\n\nuse function Pest\\Livewire\\livewire;\n\ntest('comments section has heading', function () {\n    livewire(EditPost::class)\n        ->assertFormComponentExists(\n            'comments-section',\n            function (Component $component): bool {\n                return $component->getHeading() === 'Comments';\n            },\n        );\n});\n```\n\nIf you want more informative test results, you can embed an assertion within your truth test callback:\n\n```\nuse Filament\\Forms\\Components\\Component;\nuse Illuminate\\Testing\\Assert;\n\nuse function Pest\\Livewire\\livewire;\n\ntest('comments section is enabled', function () {\n    livewire(EditPost::class)\n        ->assertFormComponentExists(\n            'comments-section',\n            function (Component $component): bool {\n                Assert::assertTrue(\n                    $component->isEnabled(),\n                    'Failed asserting that comments-section is enabled.',\n                );\n                \n                return true;\n            },\n        );\n});\n```\n\n### #Wizard\n\nTo go to a wizard’s next step, use goToNextWizardStep():\n\n`goToNextWizardStep()````\nuse function Pest\\Livewire\\livewire;\n\nit('moves to next wizard step', function () {\n    livewire(CreatePost::class)\n        ->goToNextWizardStep()\n        ->assertHasFormErrors(['title']);\n});\n```\n\nYou can also go to the previous step by calling goToPreviousWizardStep():\n\n`goToPreviousWizardStep()````\nuse function Pest\\Livewire\\livewire;\n\nit('moves to next wizard step', function () {\n    livewire(CreatePost::class)\n        ->goToPreviousWizardStep()\n        ->assertHasFormErrors(['title']);\n});\n```\n\nIf you want to go to a specific step, use goToWizardStep(), then the assertWizardCurrentStep method which can ensure you are on the desired step without validation errors from the previous:\n\n`goToWizardStep()``assertWizardCurrentStep````\nuse function Pest\\Livewire\\livewire;\n\nit('moves to the wizards second step', function () {\n    livewire(CreatePost::class)\n        ->goToWizardStep(2)\n        ->assertWizardCurrentStep(2);\n});\n```\n\nIf you have multiple forms on a single Livewire component, any of the wizard test helpers can accept a formName parameter:\n\n`formName````\nuse function Pest\\Livewire\\livewire;\n\nit('moves to next wizard step only for fooForm', function () {\n    livewire(CreatePost::class)\n        ->goToNextWizardStep(formName: 'fooForm')\n        ->assertHasFormErrors(['title'], formName: 'fooForm');\n});\n```\n\n## #Actions\n\nYou can call an action by passing its form component name, and then the name of the action to callFormComponentAction():\n\n`callFormComponentAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callFormComponentAction('customer_id', 'send');\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue();\n});\n```\n\nTo pass an array of data into an action, use the data parameter:\n\n`data````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callFormComponentAction('customer_id', 'send', data: [\n            'email' => $email = fake()->email(),\n        ])\n        ->assertHasNoFormComponentActionErrors();\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($email);\n});\n```\n\nIf you ever need to only set an action’s data without immediately calling it, you can use setFormComponentActionData():\n\n`setFormComponentActionData()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountFormComponentAction('customer_id', 'send')\n        ->setFormComponentActionData([\n            'email' => $email = fake()->email(),\n        ])\n});\n```\n\n### #Execution\n\nTo check if an action has been halted, you can use assertFormComponentActionHalted():\n\n`assertFormComponentActionHalted()````\nuse function Pest\\Livewire\\livewire;\n\nit('stops sending if invoice has no email address', function () {\n    $invoice = Invoice::factory(['email' => null])->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callFormComponentAction('customer_id', 'send')\n        ->assertFormComponentActionHalted('customer_id', 'send');\n});\n```\n\n### #Errors\n\nassertHasNoFormComponentActionErrors() is used to assert that no validation errors occurred when submitting the action form.\n\n`assertHasNoFormComponentActionErrors()`To check if a validation error has occurred with the data, use assertHasFormComponentActionErrors(), similar to assertHasErrors() in Livewire:\n\n`assertHasFormComponentActionErrors()``assertHasErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate invoice recipient email', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callFormComponentAction('customer_id', 'send', data: [\n            'email' => Str::random(),\n        ])\n        ->assertHasFormComponentActionErrors(['email' => ['email']]);\n});\n```\n\nTo check if an action is pre-filled with data, you can use the assertFormComponentActionDataSet() method:\n\n`assertFormComponentActionDataSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices to the primary contact by default', function () {\n    $invoice = Invoice::factory()->create();\n    $recipientEmail = $invoice->company->primaryContact->email;\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountFormComponentAction('customer_id', 'send')\n        ->assertFormComponentActionDataSet([\n            'email' => $recipientEmail,\n        ])\n        ->callMountedFormComponentAction()\n        ->assertHasNoFormComponentActionErrors();\n        \n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($recipientEmail);\n});\n```\n\n### #Action state\n\nTo ensure that an action exists or doesn’t in a form, you can use the assertFormComponentActionExists() or  assertFormComponentActionDoesNotExist() method:\n\n`assertFormComponentActionExists()``assertFormComponentActionDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send but not unsend invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionExists('customer_id', 'send')\n        ->assertFormComponentActionDoesNotExist('customer_id', 'unsend');\n});\n```\n\nTo ensure an action is hidden or visible for a user, you can use the assertFormComponentActionHidden() or assertFormComponentActionVisible() methods:\n\n`assertFormComponentActionHidden()``assertFormComponentActionVisible()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print customers', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionHidden('customer_id', 'send')\n        ->assertFormComponentActionVisible('customer_id', 'print');\n});\n```\n\nTo ensure an action is enabled or disabled for a user, you can use the assertFormComponentActionEnabled() or assertFormComponentActionDisabled() methods:\n\n`assertFormComponentActionEnabled()``assertFormComponentActionDisabled()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print a customer for a sent invoice', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionDisabled('customer_id', 'send')\n        ->assertFormComponentActionEnabled('customer_id', 'print');\n});\n```\n\nTo check if an action is hidden to a user, you can use the assertFormComponentActionHidden() method:\n\n`assertFormComponentActionHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionHidden('customer_id', 'send');\n});\n```\n\n### #Button appearance\n\nTo ensure an action has the correct label, you can use assertFormComponentActionHasLabel() and assertFormComponentActionDoesNotHaveLabel():\n\n`assertFormComponentActionHasLabel()``assertFormComponentActionDoesNotHaveLabel()````\nuse function Pest\\Livewire\\livewire;\n\nit('send action has correct label', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionHasLabel('customer_id', 'send', 'Email Invoice')\n        ->assertFormComponentActionDoesNotHaveLabel('customer_id', 'send', 'Send');\n});\n```\n\nTo ensure an action’s button is showing the correct icon, you can use assertFormComponentActionHasIcon() or assertFormComponentActionDoesNotHaveIcon():\n\n`assertFormComponentActionHasIcon()``assertFormComponentActionDoesNotHaveIcon()````\nuse function Pest\\Livewire\\livewire;\n\nit('when enabled the send button has correct icon', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionEnabled('customer_id', 'send')\n        ->assertFormComponentActionHasIcon('customer_id', 'send', 'envelope-open')\n        ->assertFormComponentActionDoesNotHaveIcon('customer_id', 'send', 'envelope');\n});\n```\n\nTo ensure that an action’s button is displaying the right color, you can use assertFormComponentActionHasColor() or assertFormComponentActionDoesNotHaveColor():\n\n`assertFormComponentActionHasColor()``assertFormComponentActionDoesNotHaveColor()````\nuse function Pest\\Livewire\\livewire;\n\nit('actions display proper colors', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionHasColor('customer_id', 'delete', 'danger')\n        ->assertFormComponentActionDoesNotHaveColor('customer_id', 'print', 'danger');\n});\n```\n\n### #URL\n\nTo ensure an action has the correct URL, you can use assertFormComponentActionHasUrl(), assertFormComponentActionDoesNotHaveUrl(), assertFormComponentActionShouldOpenUrlInNewTab(), and assertFormComponentActionShouldNotOpenUrlInNewTab():\n\n`assertFormComponentActionHasUrl()``assertFormComponentActionDoesNotHaveUrl()``assertFormComponentActionShouldOpenUrlInNewTab()``assertFormComponentActionShouldNotOpenUrlInNewTab()````\nuse function Pest\\Livewire\\livewire;\n\nit('links to the correct Filament sites', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionHasUrl('customer_id', 'filament', 'https://filamentphp.com/')\n        ->assertFormComponentActionDoesNotHaveUrl('customer_id', 'filament', 'https://github.com/filamentphp/filament')\n        ->assertFormComponentActionShouldOpenUrlInNewTab('customer_id', 'filament')\n        ->assertFormComponentActionShouldNotOpenUrlInNewTab('customer_id', 'github');\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Testing - Forms - Filament",
                "content": "Forms",
                "level": 1
              },
              {
                "title": "# Testing",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "All examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\nSince the Form Builder works on Livewire components, you can use the Livewire testing helpers. However, we have custom testing helpers that you can use with forms:",
                "level": 3
              },
              {
                "title": "## #Filling a form",
                "content": "To fill a form with data, pass the data to fillForm():\n\n`fillForm()````\nuse function Pest\\Livewire\\livewire;\n\nlivewire(CreatePost::class)\n    ->fillForm([\n        'title' => fake()->sentence(),\n        // ...\n    ]);\n```\n\n> If you have multiple forms on a Livewire component, you can specify which form you want to fill using fillForm([...], 'createPostForm').\n\nIf you have multiple forms on a Livewire component, you can specify which form you want to fill using fillForm([...], 'createPostForm').\n\n`fillForm([...], 'createPostForm')`To check that a form has data, use assertFormSet():\n\n`assertFormSet()````\nuse Illuminate\\Support\\Str;\nuse function Pest\\Livewire\\livewire;\n\nit('can automatically generate a slug from the title', function () {\n    $title = fake()->sentence();\n\n    livewire(CreatePost::class)\n        ->fillForm([\n            'title' => $title,\n        ])\n        ->assertFormSet([\n            'slug' => Str::slug($title),\n        ]);\n});\n```\n\n> If you have multiple forms on a Livewire component, you can specify which form you want to check using assertFormSet([...], 'createPostForm').\n\nIf you have multiple forms on a Livewire component, you can specify which form you want to check using assertFormSet([...], 'createPostForm').\n\n`assertFormSet([...], 'createPostForm')`You may also find it useful to pass a function to the assertFormSet() method, which allows you to access the form $state and perform additional assertions:\n\n`assertFormSet()``$state````\nuse Illuminate\\Support\\Str;\nuse function Pest\\Livewire\\livewire;\n\nit('can automatically generate a slug from the title without any spaces', function () {\n    $title = fake()->sentence();\n\n    livewire(CreatePost::class)\n        ->fillForm([\n            'title' => $title,\n        ])\n        ->assertFormSet(function (array $state): array {\n            expect($state['slug'])\n                ->not->toContain(' ');\n                \n            return [\n                'slug' => Str::slug($title),\n            ];\n        });\n});\n```\n\nYou can return an array from the function if you want Filament to continue to assert the form state after the function has been run.",
                "level": 3
              },
              {
                "title": "## #Validation",
                "content": "Use assertHasFormErrors() to ensure that data is properly validated in a form:\n\n`assertHasFormErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate input', function () {\n    livewire(CreatePost::class)\n        ->fillForm([\n            'title' => null,\n        ])\n        ->call('create')\n        ->assertHasFormErrors(['title' => 'required']);\n});\n```\n\nAnd assertHasNoFormErrors() to ensure there are no validation errors:\n\n`assertHasNoFormErrors()````\nuse function Pest\\Livewire\\livewire;\n\nlivewire(CreatePost::class)\n    ->fillForm([\n        'title' => fake()->sentence(),\n        // ...\n    ])\n    ->call('create')\n    ->assertHasNoFormErrors();\n```\n\n> If you have multiple forms on a Livewire component, you can pass the name of a specific form as the second parameter like assertHasFormErrors(['title' => 'required'], 'createPostForm') or assertHasNoFormErrors([], 'createPostForm').\n\nIf you have multiple forms on a Livewire component, you can pass the name of a specific form as the second parameter like assertHasFormErrors(['title' => 'required'], 'createPostForm') or assertHasNoFormErrors([], 'createPostForm').\n\n`assertHasFormErrors(['title' => 'required'], 'createPostForm')``assertHasNoFormErrors([], 'createPostForm')`## #Form existence\n\nTo check that a Livewire component has a form, use assertFormExists():\n\n`assertFormExists()````\nuse function Pest\\Livewire\\livewire;\n\nit('has a form', function () {\n    livewire(CreatePost::class)\n        ->assertFormExists();\n});\n```\n\n> If you have multiple forms on a Livewire component, you can pass the name of a specific form like assertFormExists('createPostForm').\n\nIf you have multiple forms on a Livewire component, you can pass the name of a specific form like assertFormExists('createPostForm').\n\n`assertFormExists('createPostForm')`## #Fields\n\nTo ensure that a form has a given field, pass the field name to assertFormFieldExists():\n\n`assertFormFieldExists()````\nuse function Pest\\Livewire\\livewire;\n\nit('has a title field', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldExists('title');\n});\n```\n\nYou may pass a function as an additional argument in order to assert that a field passes a given “truth test”. This is useful for asserting that a field has a specific configuration:\n\n```\nuse function Pest\\Livewire\\livewire;\n\nit('has a title field', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldExists('title', function (TextInput $field): bool {\n            return $field->isDisabled();\n        });\n});\n```\n\nTo assert that a form does not have a given field, pass the field name to assertFormFieldDoesNotExist():\n\n`assertFormFieldDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('does not have a conditional field', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldDoesNotExist('no-such-field');\n});\n```\n\n> If you have multiple forms on a Livewire component, you can specify which form you want to check for the existence of the field like assertFormFieldExists('title', 'createPostForm').\n\nIf you have multiple forms on a Livewire component, you can specify which form you want to check for the existence of the field like assertFormFieldExists('title', 'createPostForm').\n\n`assertFormFieldExists('title', 'createPostForm')`### #Hidden fields\n\nTo ensure that a field is visible, pass the name to assertFormFieldIsVisible():\n\n`assertFormFieldIsVisible()````\nuse function Pest\\Livewire\\livewire;\n\ntest('title is visible', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldIsVisible('title');\n});\n```\n\nOr to ensure that a field is hidden you can pass the name to assertFormFieldIsHidden():\n\n`assertFormFieldIsHidden()````\nuse function Pest\\Livewire\\livewire;\n\ntest('title is hidden', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldIsHidden('title');\n});\n```\n\n> For both assertFormFieldIsHidden() and assertFormFieldIsVisible() you can pass the name of a specific form the field belongs to as the second argument like assertFormFieldIsHidden('title', 'createPostForm').\n\nFor both assertFormFieldIsHidden() and assertFormFieldIsVisible() you can pass the name of a specific form the field belongs to as the second argument like assertFormFieldIsHidden('title', 'createPostForm').\n\n`assertFormFieldIsHidden()``assertFormFieldIsVisible()``assertFormFieldIsHidden('title', 'createPostForm')`### #Disabled fields\n\nTo ensure that a field is enabled, pass the name to assertFormFieldIsEnabled():\n\n`assertFormFieldIsEnabled()````\nuse function Pest\\Livewire\\livewire;\n\ntest('title is enabled', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldIsEnabled('title');\n});\n```\n\nOr to ensure that a field is disabled you can pass the name to assertFormFieldIsDisabled():\n\n`assertFormFieldIsDisabled()````\nuse function Pest\\Livewire\\livewire;\n\ntest('title is disabled', function () {\n    livewire(CreatePost::class)\n        ->assertFormFieldIsDisabled('title');\n});\n```\n\n> For both assertFormFieldIsEnabled() and assertFormFieldIsDisabled() you can pass the name of a specific form the field belongs to as the second argument like assertFormFieldIsEnabled('title', 'createPostForm').\n\nFor both assertFormFieldIsEnabled() and assertFormFieldIsDisabled() you can pass the name of a specific form the field belongs to as the second argument like assertFormFieldIsEnabled('title', 'createPostForm').\n\n`assertFormFieldIsEnabled()``assertFormFieldIsDisabled()``assertFormFieldIsEnabled('title', 'createPostForm')`## #Layout components\n\nIf you need to check if a particular layout component exists rather than a field, you may use assertFormComponentExists().  As layout components do not have names, this method uses the key() provided by the developer:\n\n`assertFormComponentExists()``key()````\nuse Filament\\Forms\\Components\\Section;\n\nSection::make('Comments')\n    ->key('comments-section')\n    ->schema([\n        //\n    ])\n```\n\n```\nuse function Pest\\Livewire\\livewire;\n\ntest('comments section exists', function () {\n    livewire(EditPost::class)\n        ->assertFormComponentExists('comments-section');\n});\n```\n\nTo assert that a form does not have a given component, pass the component key to assertFormComponentDoesNotExist():\n\n`assertFormComponentDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('does not have a conditional component', function () {\n    livewire(CreatePost::class)\n        ->assertFormComponentDoesNotExist('no-such-section');\n});\n```\n\nTo check if the component exists and passes a given truth test, you can pass a function to the second argument of assertFormComponentExists(), returning true or false if the component passes the test or not:\n\n`assertFormComponentExists()````\nuse Filament\\Forms\\Components\\Component;\n\nuse function Pest\\Livewire\\livewire;\n\ntest('comments section has heading', function () {\n    livewire(EditPost::class)\n        ->assertFormComponentExists(\n            'comments-section',\n            function (Component $component): bool {\n                return $component->getHeading() === 'Comments';\n            },\n        );\n});\n```\n\nIf you want more informative test results, you can embed an assertion within your truth test callback:\n\n```\nuse Filament\\Forms\\Components\\Component;\nuse Illuminate\\Testing\\Assert;\n\nuse function Pest\\Livewire\\livewire;\n\ntest('comments section is enabled', function () {\n    livewire(EditPost::class)\n        ->assertFormComponentExists(\n            'comments-section',\n            function (Component $component): bool {\n                Assert::assertTrue(\n                    $component->isEnabled(),\n                    'Failed asserting that comments-section is enabled.',\n                );\n                \n                return true;\n            },\n        );\n});\n```",
                "level": 3
              },
              {
                "title": "### #Wizard",
                "content": "To go to a wizard’s next step, use goToNextWizardStep():\n\n`goToNextWizardStep()````\nuse function Pest\\Livewire\\livewire;\n\nit('moves to next wizard step', function () {\n    livewire(CreatePost::class)\n        ->goToNextWizardStep()\n        ->assertHasFormErrors(['title']);\n});\n```\n\nYou can also go to the previous step by calling goToPreviousWizardStep():\n\n`goToPreviousWizardStep()````\nuse function Pest\\Livewire\\livewire;\n\nit('moves to next wizard step', function () {\n    livewire(CreatePost::class)\n        ->goToPreviousWizardStep()\n        ->assertHasFormErrors(['title']);\n});\n```\n\nIf you want to go to a specific step, use goToWizardStep(), then the assertWizardCurrentStep method which can ensure you are on the desired step without validation errors from the previous:\n\n`goToWizardStep()``assertWizardCurrentStep````\nuse function Pest\\Livewire\\livewire;\n\nit('moves to the wizards second step', function () {\n    livewire(CreatePost::class)\n        ->goToWizardStep(2)\n        ->assertWizardCurrentStep(2);\n});\n```\n\nIf you have multiple forms on a single Livewire component, any of the wizard test helpers can accept a formName parameter:\n\n`formName````\nuse function Pest\\Livewire\\livewire;\n\nit('moves to next wizard step only for fooForm', function () {\n    livewire(CreatePost::class)\n        ->goToNextWizardStep(formName: 'fooForm')\n        ->assertHasFormErrors(['title'], formName: 'fooForm');\n});\n```",
                "level": 4
              },
              {
                "title": "## #Actions",
                "content": "You can call an action by passing its form component name, and then the name of the action to callFormComponentAction():\n\n`callFormComponentAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callFormComponentAction('customer_id', 'send');\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue();\n});\n```\n\nTo pass an array of data into an action, use the data parameter:\n\n`data````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callFormComponentAction('customer_id', 'send', data: [\n            'email' => $email = fake()->email(),\n        ])\n        ->assertHasNoFormComponentActionErrors();\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($email);\n});\n```\n\nIf you ever need to only set an action’s data without immediately calling it, you can use setFormComponentActionData():\n\n`setFormComponentActionData()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountFormComponentAction('customer_id', 'send')\n        ->setFormComponentActionData([\n            'email' => $email = fake()->email(),\n        ])\n});\n```",
                "level": 3
              },
              {
                "title": "### #Execution",
                "content": "To check if an action has been halted, you can use assertFormComponentActionHalted():\n\n`assertFormComponentActionHalted()````\nuse function Pest\\Livewire\\livewire;\n\nit('stops sending if invoice has no email address', function () {\n    $invoice = Invoice::factory(['email' => null])->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callFormComponentAction('customer_id', 'send')\n        ->assertFormComponentActionHalted('customer_id', 'send');\n});\n```",
                "level": 4
              },
              {
                "title": "### #Errors",
                "content": "assertHasNoFormComponentActionErrors() is used to assert that no validation errors occurred when submitting the action form.\n\n`assertHasNoFormComponentActionErrors()`To check if a validation error has occurred with the data, use assertHasFormComponentActionErrors(), similar to assertHasErrors() in Livewire:\n\n`assertHasFormComponentActionErrors()``assertHasErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate invoice recipient email', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callFormComponentAction('customer_id', 'send', data: [\n            'email' => Str::random(),\n        ])\n        ->assertHasFormComponentActionErrors(['email' => ['email']]);\n});\n```\n\nTo check if an action is pre-filled with data, you can use the assertFormComponentActionDataSet() method:\n\n`assertFormComponentActionDataSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices to the primary contact by default', function () {\n    $invoice = Invoice::factory()->create();\n    $recipientEmail = $invoice->company->primaryContact->email;\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountFormComponentAction('customer_id', 'send')\n        ->assertFormComponentActionDataSet([\n            'email' => $recipientEmail,\n        ])\n        ->callMountedFormComponentAction()\n        ->assertHasNoFormComponentActionErrors();\n        \n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($recipientEmail);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Action state",
                "content": "To ensure that an action exists or doesn’t in a form, you can use the assertFormComponentActionExists() or  assertFormComponentActionDoesNotExist() method:\n\n`assertFormComponentActionExists()``assertFormComponentActionDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send but not unsend invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionExists('customer_id', 'send')\n        ->assertFormComponentActionDoesNotExist('customer_id', 'unsend');\n});\n```\n\nTo ensure an action is hidden or visible for a user, you can use the assertFormComponentActionHidden() or assertFormComponentActionVisible() methods:\n\n`assertFormComponentActionHidden()``assertFormComponentActionVisible()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print customers', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionHidden('customer_id', 'send')\n        ->assertFormComponentActionVisible('customer_id', 'print');\n});\n```\n\nTo ensure an action is enabled or disabled for a user, you can use the assertFormComponentActionEnabled() or assertFormComponentActionDisabled() methods:\n\n`assertFormComponentActionEnabled()``assertFormComponentActionDisabled()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print a customer for a sent invoice', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionDisabled('customer_id', 'send')\n        ->assertFormComponentActionEnabled('customer_id', 'print');\n});\n```\n\nTo check if an action is hidden to a user, you can use the assertFormComponentActionHidden() method:\n\n`assertFormComponentActionHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionHidden('customer_id', 'send');\n});\n```",
                "level": 4
              },
              {
                "title": "### #Button appearance",
                "content": "To ensure an action has the correct label, you can use assertFormComponentActionHasLabel() and assertFormComponentActionDoesNotHaveLabel():\n\n`assertFormComponentActionHasLabel()``assertFormComponentActionDoesNotHaveLabel()````\nuse function Pest\\Livewire\\livewire;\n\nit('send action has correct label', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionHasLabel('customer_id', 'send', 'Email Invoice')\n        ->assertFormComponentActionDoesNotHaveLabel('customer_id', 'send', 'Send');\n});\n```\n\nTo ensure an action’s button is showing the correct icon, you can use assertFormComponentActionHasIcon() or assertFormComponentActionDoesNotHaveIcon():\n\n`assertFormComponentActionHasIcon()``assertFormComponentActionDoesNotHaveIcon()````\nuse function Pest\\Livewire\\livewire;\n\nit('when enabled the send button has correct icon', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionEnabled('customer_id', 'send')\n        ->assertFormComponentActionHasIcon('customer_id', 'send', 'envelope-open')\n        ->assertFormComponentActionDoesNotHaveIcon('customer_id', 'send', 'envelope');\n});\n```\n\nTo ensure that an action’s button is displaying the right color, you can use assertFormComponentActionHasColor() or assertFormComponentActionDoesNotHaveColor():\n\n`assertFormComponentActionHasColor()``assertFormComponentActionDoesNotHaveColor()````\nuse function Pest\\Livewire\\livewire;\n\nit('actions display proper colors', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionHasColor('customer_id', 'delete', 'danger')\n        ->assertFormComponentActionDoesNotHaveColor('customer_id', 'print', 'danger');\n});\n```",
                "level": 4
              },
              {
                "title": "### #URL",
                "content": "To ensure an action has the correct URL, you can use assertFormComponentActionHasUrl(), assertFormComponentActionDoesNotHaveUrl(), assertFormComponentActionShouldOpenUrlInNewTab(), and assertFormComponentActionShouldNotOpenUrlInNewTab():\n\n`assertFormComponentActionHasUrl()``assertFormComponentActionDoesNotHaveUrl()``assertFormComponentActionShouldOpenUrlInNewTab()``assertFormComponentActionShouldNotOpenUrlInNewTab()````\nuse function Pest\\Livewire\\livewire;\n\nit('links to the correct Filament sites', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertFormComponentActionHasUrl('customer_id', 'filament', 'https://filamentphp.com/')\n        ->assertFormComponentActionDoesNotHaveUrl('customer_id', 'filament', 'https://github.com/filamentphp/filament')\n        ->assertFormComponentActionShouldOpenUrlInNewTab('customer_id', 'filament')\n        ->assertFormComponentActionShouldNotOpenUrlInNewTab('customer_id', 'github');\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Filling a form",
              "Validation",
              "Wizard",
              "Actions",
              "Execution",
              "Errors",
              "Action state",
              "Button appearance"
            ],
            "code_examples_count": 72,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "upgrading": {
          "metadata": {
            "title": "Upgrading",
            "url": "https://filamentphp.com/docs/3.x/forms/upgrading",
            "section": "forms",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        }
      }
    },
    "infolists": {
      "section_info": {
        "name": "infolists",
        "page_count": 8,
        "description": "Read-only information display components for showing data"
      },
      "pages": {
        "installation": {
          "metadata": {
            "title": "Installation",
            "url": "https://filamentphp.com/docs/3.x/infolists/installation",
            "section": "infolists",
            "word_count": 660,
            "character_count": 5536
          },
          "content": {
            "full_text": "\n# Installation - Infolists - Filament\n\nInfolists\n\n# Installation\n\nThe Infolist Builder package is pre-installed with the Panel Builder. This guide is for using the Infolist Builder package in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)\n\n## #Installation\n\nRequire the Infolist Builder package using Composer:\n\n```\ncomposer require filament/infolists:\"^3.3\" -W\n```\n\n## #New Laravel projects\n\nTo quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --infolists\n\nnpm install\n\nnpm run dev\n```\n\n## #Existing Laravel projects\n\nRun the following command to install the Infolist Builder package assets:\n\n```\nphp artisan filament:install --infolists\n```\n\n### #Installing Tailwind CSS\n\n> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```\n\n### #Configuring styles\n\nAdd Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```\n\n### #Automatically refreshing the browser\n\nYou may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```\n\n### #Compiling assets\n\nCompile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```\n\n## #Publishing configuration\n\nYou can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Upgrading\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Infolists - Filament",
                "content": "Infolists",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "The Infolist Builder package is pre-installed with the Panel Builder. This guide is for using the Infolist Builder package in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "Require the Infolist Builder package using Composer:\n\n```\ncomposer require filament/infolists:\"^3.3\" -W\n```",
                "level": 3
              },
              {
                "title": "## #New Laravel projects",
                "content": "To quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --infolists\n\nnpm install\n\nnpm run dev\n```",
                "level": 3
              },
              {
                "title": "## #Existing Laravel projects",
                "content": "Run the following command to install the Infolist Builder package assets:\n\n```\nphp artisan filament:install --infolists\n```",
                "level": 3
              },
              {
                "title": "### #Installing Tailwind CSS",
                "content": "> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```",
                "level": 4
              },
              {
                "title": "### #Configuring styles",
                "content": "Add Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```",
                "level": 4
              },
              {
                "title": "### #Automatically refreshing the browser",
                "content": "You may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```",
                "level": 4
              },
              {
                "title": "### #Compiling assets",
                "content": "Compile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```",
                "level": 4
              },
              {
                "title": "## #Publishing configuration",
                "content": "You can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "Filament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "New Laravel projects",
              "Existing Laravel projects",
              "Installing Tailwind CSS",
              "Configuring styles",
              "Automatically refreshing the browser",
              "Compiling assets",
              "Publishing configuration",
              "Upgrading"
            ],
            "code_examples_count": 24,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "getting-started": {
          "metadata": {
            "title": "Getting Started",
            "url": "https://filamentphp.com/docs/3.x/infolists/getting-started",
            "section": "infolists",
            "word_count": 511,
            "character_count": 3915
          },
          "content": {
            "full_text": "\n# Getting started - Infolists - Filament\n\nInfolists\n\n# Getting started\n\n## #Overview\n\nFilament’s infolist package allows you to render a read-only list of data about a particular entity. It’s also used within other Filament packages, such as the Panel Builder for displaying app resources and relation managers, as well as for action modals. Learning the features of the Infolist Builder will be incredibly time-saving when both building your own custom Livewire applications and using Filament’s other packages.\n\nThis guide will walk you through the basics of building infolists with Filament’s infolist package. If you’re planning to add a new infolist to your own Livewire component, you should do that first and then come back. If you’re adding an infolist to an app resource, or another Filament package, you’re ready to go!\n\n## #Defining entries\n\nThe first step to building an infolist is to define the entries that will be displayed in the list. You can do this by calling the schema() method on an Infolist object. This method accepts an array of entry objects.\n\n`schema()``Infolist````\nuse Filament\\Infolists\\Components\\TextEntry;\n\n$infolist\n    ->schema([\n        TextEntry::make('title'),\n        TextEntry::make('slug'),\n        TextEntry::make('content'),\n    ]);\n```\n\nEach entry is a piece of information that should be displayed in the infolist. The TextEntry is used for displaying text, but there are other entry types available.\n\n`TextEntry`Infolists within the Panel Builder and other packages usually have 2 columns by default. For custom infolists, you can use the columns() method to achieve the same effect:\n\n`columns()````\n$infolist\n    ->schema([\n        // ...\n    ])\n    ->columns(2);\n```\n\nNow, the content entry will only consume half of the available width. We can use the columnSpan() method to make it span the full width:\n\n`content``columnSpan()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\n[\n    TextEntry::make('title'),\n    TextEntry::make('slug')\n    TextEntry::make('content')\n        ->columnSpan(2), // or `columnSpan('full')`,\n]\n```\n\nYou can learn more about columns and spans in the layout documentation. You can even make them responsive!\n\n## #Using layout components\n\nThe Infolist Builder allows you to use layout components inside the schema array to control how entries are displayed. Section is a layout component, and it allows you to add a heading and description to a set of entries. It can also allow entries inside it to collapse, which saves space in long infolists.\n\n`Section````\nuse Filament\\Infolists\\Components\\Section;\nuse Filament\\Infolists\\Components\\TextEntry;\n\n[\n    TextEntry::make('title'),\n    TextEntry::make('slug'),\n    TextEntry::make('content')\n        ->columnSpan(2)\n        ->markdown(),\n    Section::make('Media')\n        ->description('Images used in the page layout.')\n        ->schema([\n            // ...\n        ]),\n]\n```\n\nIn this example, you can see how the Section component has its own schema() method. You can use this to nest other entries and layout components inside:\n\n`Section``schema()````\nuse Filament\\Infolists\\Components\\ImageEntry;\nuse Filament\\Infolists\\Components\\Section;\nuse Filament\\Infolists\\Components\\TextEntry;\n\nSection::make('Media')\n    ->description('Images used in the page layout.')\n    ->schema([\n        ImageEntry::make('hero_image'),\n        TextEntry::make('alt_text'),\n    ])\n```\n\nThis section now contains an ImageEntry and a TextEntry. You can learn more about those entries and their functionalities on the respective docs pages.\n\n`ImageEntry``TextEntry`## #Next steps with the infolists package\n\nNow you’ve finished reading this guide, where to next? Here are some suggestions:\n\n- Explore the available entries to display data in your infolist.\n- Discover how to build complex, responsive layouts without touching CSS.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Infolists - Filament",
                "content": "Infolists",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament’s infolist package allows you to render a read-only list of data about a particular entity. It’s also used within other Filament packages, such as the Panel Builder for displaying app resources and relation managers, as well as for action modals. Learning the features of the Infolist Builder will be incredibly time-saving when both building your own custom Livewire applications and using Filament’s other packages.\n\nThis guide will walk you through the basics of building infolists with Filament’s infolist package. If you’re planning to add a new infolist to your own Livewire component, you should do that first and then come back. If you’re adding an infolist to an app resource, or another Filament package, you’re ready to go!",
                "level": 3
              },
              {
                "title": "## #Defining entries",
                "content": "The first step to building an infolist is to define the entries that will be displayed in the list. You can do this by calling the schema() method on an Infolist object. This method accepts an array of entry objects.\n\n`schema()``Infolist````\nuse Filament\\Infolists\\Components\\TextEntry;\n\n$infolist\n    ->schema([\n        TextEntry::make('title'),\n        TextEntry::make('slug'),\n        TextEntry::make('content'),\n    ]);\n```\n\nEach entry is a piece of information that should be displayed in the infolist. The TextEntry is used for displaying text, but there are other entry types available.\n\n`TextEntry`Infolists within the Panel Builder and other packages usually have 2 columns by default. For custom infolists, you can use the columns() method to achieve the same effect:\n\n`columns()````\n$infolist\n    ->schema([\n        // ...\n    ])\n    ->columns(2);\n```\n\nNow, the content entry will only consume half of the available width. We can use the columnSpan() method to make it span the full width:\n\n`content``columnSpan()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\n[\n    TextEntry::make('title'),\n    TextEntry::make('slug')\n    TextEntry::make('content')\n        ->columnSpan(2), // or `columnSpan('full')`,\n]\n```\n\nYou can learn more about columns and spans in the layout documentation. You can even make them responsive!",
                "level": 3
              },
              {
                "title": "## #Using layout components",
                "content": "The Infolist Builder allows you to use layout components inside the schema array to control how entries are displayed. Section is a layout component, and it allows you to add a heading and description to a set of entries. It can also allow entries inside it to collapse, which saves space in long infolists.\n\n`Section````\nuse Filament\\Infolists\\Components\\Section;\nuse Filament\\Infolists\\Components\\TextEntry;\n\n[\n    TextEntry::make('title'),\n    TextEntry::make('slug'),\n    TextEntry::make('content')\n        ->columnSpan(2)\n        ->markdown(),\n    Section::make('Media')\n        ->description('Images used in the page layout.')\n        ->schema([\n            // ...\n        ]),\n]\n```\n\nIn this example, you can see how the Section component has its own schema() method. You can use this to nest other entries and layout components inside:\n\n`Section``schema()````\nuse Filament\\Infolists\\Components\\ImageEntry;\nuse Filament\\Infolists\\Components\\Section;\nuse Filament\\Infolists\\Components\\TextEntry;\n\nSection::make('Media')\n    ->description('Images used in the page layout.')\n    ->schema([\n        ImageEntry::make('hero_image'),\n        TextEntry::make('alt_text'),\n    ])\n```\n\nThis section now contains an ImageEntry and a TextEntry. You can learn more about those entries and their functionalities on the respective docs pages.\n\n`ImageEntry``TextEntry`## #Next steps with the infolists package\n\nNow you’ve finished reading this guide, where to next? Here are some suggestions:\n\n- Explore the available entries to display data in your infolist.\n- Discover how to build complex, responsive layouts without touching CSS.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Defining entries",
              "Using layout components"
            ],
            "code_examples_count": 10,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "entries": {
          "metadata": {
            "title": "Entries",
            "url": "https://filamentphp.com/docs/3.x/infolists/entries",
            "section": "infolists",
            "word_count": 1043,
            "character_count": 9252
          },
          "content": {
            "full_text": "\n# Getting started - Infolists - Filament\n\nInfolists  \n-  Entries\n\n# Getting started\n\n## #Overview\n\nEntry classes can be found in the Filament\\Infolists\\Components namespace. You can put them inside the $infolist->schema() method:\n\n`Filament\\Infolists\\Components``$infolist->schema()````\nuse Filament\\Infolists\\Infolist;\n\npublic function infolist(Infolist $infolist): Infolist\n{\n    return $infolist\n        ->schema([\n            // ...\n        ]);\n}\n```\n\nIf you’re inside a panel builder resource, the infolist() method should be static:\n\n`infolist()````\nuse Filament\\Infolists\\Infolist;\n\npublic static function infolist(Infolist $infolist): Infolist\n{\n    return $infolist\n        ->schema([\n            // ...\n        ]);\n}\n```\n\nEntries may be created using the static make() method, passing its unique name. You may use “dot notation” to access entries within relationships.\n\n`make()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n\nTextEntry::make('author.name')\n```\n\n## #Available entries\n\n- Text entry\n- Icon entry\n- Image entry\n- Color entry\n- Key-value entry\n- Repeatable entry\n\nYou may also create your own custom entries to display data however you wish.\n\n## #Setting a label\n\nBy default, the label of the entry, which is displayed in the header of the infolist, is generated from the name of the entry. You may customize this using the label() method:\n\n`label()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->label('Post title')\n```\n\nOptionally, you can have the label automatically translated using Laravel’s localization features with the translateLabel() method:\n\n`translateLabel()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->translateLabel() // Equivalent to `label(__('Title'))`\n```\n\n## #Entry URLs\n\nWhen an entry is clicked, you may open a URL.\n\n### #Opening URLs\n\nTo open a URL, you may use the url() method, passing a callback or static URL to open. Callbacks accept a $record parameter which you may use to customize the URL:\n\n`url()``$record````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->url(fn (Post $record): string => route('posts.edit', ['post' => $record]))\n```\n\nYou may also choose to open the URL in a new tab:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->url(fn (Post $record): string => route('posts.edit', ['post' => $record]))\n    ->openUrlInNewTab()\n```\n\n## #Setting a default value\n\nTo set a default value for entries with an empty state, you may use the default() method. This method will treat the default state as if it were real, so entries like image or color will display the default image or color.\n\n`default()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->default('Untitled')\n```\n\n## #Adding placeholder text if an entry is empty\n\nSometimes you may want to display placeholder text for entries with an empty state, which is styled as a lighter gray text. This differs from the default value, as the placeholder is always text and not treated as if it were real state.\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->placeholder('Untitled')\n```\n\n## #Adding helper text below the entry\n\nSometimes, you may wish to provide extra information for the user of the infolist. For this purpose, you may add helper text below the entry.\n\nThe helperText() method is used to add helper text:\n\n`helperText()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('name')\n    ->helperText('Your full name here, including any middle names.')\n```\n\nThis method accepts a plain text string, or an instance of Illuminate\\Support\\HtmlString or Illuminate\\Contracts\\Support\\Htmlable. This allows you to render HTML, or even markdown, in the helper text:\n\n`Illuminate\\Support\\HtmlString``Illuminate\\Contracts\\Support\\Htmlable````\nuse Filament\\Infolists\\Components\\TextEntry;\nuse Illuminate\\Support\\HtmlString;\n\nTextEntry::make('name')\n    ->helperText(new HtmlString('Your <strong>full name</strong> here, including any middle names.'))\n\nTextEntry::make('name')\n    ->helperText(str('Your **full name** here, including any middle names.')->inlineMarkdown()->toHtmlString())\n\nTextEntry::make('name')\n    ->helperText(view('name-helper-text'))\n```\n\n## #Adding a hint next to the label\n\nAs well as helper text below the entry, you may also add a “hint” next to the label of the entry. This is useful for displaying additional information about the entry, such as a link to a help page.\n\nThe hint() method is used to add a hint:\n\n`hint()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint('Documentation? What documentation?!')\n```\n\nThis method accepts a plain text string, or an instance of Illuminate\\Support\\HtmlString or Illuminate\\Contracts\\Support\\Htmlable. This allows you to render HTML, or even markdown, in the helper text:\n\n`Illuminate\\Support\\HtmlString``Illuminate\\Contracts\\Support\\Htmlable````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(new HtmlString('<a href=\"/documentation\">Documentation</a>'))\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(str('[Documentation](/documentation)')->inlineMarkdown()->toHtmlString())\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(view('api-key-hint'))\n```\n\n### #Changing the text color of the hint\n\nYou can change the text color of the hint. By default, it’s gray, but you may use danger, info, primary, success and warning:\n\n`danger``info``primary``success``warning````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(str('[Documentation](/documentation)')->inlineMarkdown()->toHtmlString())\n    ->hintColor('primary')\n```\n\n### #Adding an icon aside the hint\n\nHints may also have an icon rendered next to them:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(str('[Documentation](/documentation)')->inlineMarkdown()->toHtmlString())\n    ->hintIcon('heroicon-m-question-mark-circle')\n```\n\n#### #Adding a tooltip to a hint icon\n\nAdditionally, you can add a tooltip to display when you hover over the hint icon, using the tooltip parameter of hintIcon():\n\n`tooltip``hintIcon()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(str('[Documentation](/documentation)')->inlineMarkdown()->toHtmlString())\n    ->hintIcon('heroicon-m-question-mark-circle', tooltip: 'Read it!')\n```\n\n## #Hiding entries\n\nTo hide an entry conditionally, you may use the hidden() and visible() methods, whichever you prefer:\n\n`hidden()``visible()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('role')\n    ->hidden(! auth()->user()->isAdmin())\n// or\nTextEntry::make('role')\n    ->visible(auth()->user()->isAdmin())\n```\n\n## #Calculated state\n\nSometimes you need to calculate the state of an entry, instead of directly reading it from a database entry.\n\nBy passing a callback function to the state() method, you can customize the returned state for that entry:\n\n`state()````\nInfolists\\Components\\TextEntry::make('amount_including_vat')\n    ->state(function (Model $record): float {\n        return $record->amount * (1 + $record->vat_rate);\n    })\n```\n\n## #Tooltips\n\nYou may specify a tooltip to display when you hover over an entry:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->tooltip('Shown at the top of the page')\n```\n\nThis method also accepts a closure that can access the current infolist record:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nTextEntry::make('title')\n    ->tooltip(fn (Model $record): string => \"By {$record->author->name}\")\n```\n\n## #Custom attributes\n\nThe HTML of entries can be customized, by passing an array of extraAttributes():\n\n`extraAttributes()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('slug')\n    ->extraAttributes(['class' => 'bg-gray-200'])\n```\n\nThese get merged onto the outer <div> element of each entry in that entry.\n\n`<div>`You can also pass extra HTML attributes to the entry wrapper which surrounds the label, entry, and any other text:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('slug')\n    ->extraEntryWrapperAttributes(['class' => 'entry-locked'])\n```\n\n## #Global settings\n\nIf you wish to change the default behavior of all entries globally, then you can call the static configureUsing() method inside a service provider’s boot() method, to which you pass a Closure to modify the entries using. For example, if you wish to make all TextEntry components words(10), you can do it like so:\n\n`configureUsing()``boot()``TextEntry``words(10)````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::configureUsing(function (TextEntry $entry): void {\n    $entry\n        ->words(10);\n});\n```\n\nOf course, you are still able to overwrite this on each entry individually:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('name')\n    ->words(null)\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Infolists - Filament",
                "content": "Infolists  \n-  Entries",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Entry classes can be found in the Filament\\Infolists\\Components namespace. You can put them inside the $infolist->schema() method:\n\n`Filament\\Infolists\\Components``$infolist->schema()````\nuse Filament\\Infolists\\Infolist;\n\npublic function infolist(Infolist $infolist): Infolist\n{\n    return $infolist\n        ->schema([\n            // ...\n        ]);\n}\n```\n\nIf you’re inside a panel builder resource, the infolist() method should be static:\n\n`infolist()````\nuse Filament\\Infolists\\Infolist;\n\npublic static function infolist(Infolist $infolist): Infolist\n{\n    return $infolist\n        ->schema([\n            // ...\n        ]);\n}\n```\n\nEntries may be created using the static make() method, passing its unique name. You may use “dot notation” to access entries within relationships.\n\n`make()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n\nTextEntry::make('author.name')\n```",
                "level": 3
              },
              {
                "title": "## #Available entries",
                "content": "- Text entry\n- Icon entry\n- Image entry\n- Color entry\n- Key-value entry\n- Repeatable entry\n\nYou may also create your own custom entries to display data however you wish.",
                "level": 3
              },
              {
                "title": "## #Setting a label",
                "content": "By default, the label of the entry, which is displayed in the header of the infolist, is generated from the name of the entry. You may customize this using the label() method:\n\n`label()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->label('Post title')\n```\n\nOptionally, you can have the label automatically translated using Laravel’s localization features with the translateLabel() method:\n\n`translateLabel()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->translateLabel() // Equivalent to `label(__('Title'))`\n```",
                "level": 3
              },
              {
                "title": "## #Entry URLs",
                "content": "When an entry is clicked, you may open a URL.",
                "level": 3
              },
              {
                "title": "### #Opening URLs",
                "content": "To open a URL, you may use the url() method, passing a callback or static URL to open. Callbacks accept a $record parameter which you may use to customize the URL:\n\n`url()``$record````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->url(fn (Post $record): string => route('posts.edit', ['post' => $record]))\n```\n\nYou may also choose to open the URL in a new tab:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->url(fn (Post $record): string => route('posts.edit', ['post' => $record]))\n    ->openUrlInNewTab()\n```",
                "level": 4
              },
              {
                "title": "## #Setting a default value",
                "content": "To set a default value for entries with an empty state, you may use the default() method. This method will treat the default state as if it were real, so entries like image or color will display the default image or color.\n\n`default()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->default('Untitled')\n```",
                "level": 3
              },
              {
                "title": "## #Adding placeholder text if an entry is empty",
                "content": "Sometimes you may want to display placeholder text for entries with an empty state, which is styled as a lighter gray text. This differs from the default value, as the placeholder is always text and not treated as if it were real state.\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->placeholder('Untitled')\n```",
                "level": 3
              },
              {
                "title": "## #Adding helper text below the entry",
                "content": "Sometimes, you may wish to provide extra information for the user of the infolist. For this purpose, you may add helper text below the entry.\n\nThe helperText() method is used to add helper text:\n\n`helperText()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('name')\n    ->helperText('Your full name here, including any middle names.')\n```\n\nThis method accepts a plain text string, or an instance of Illuminate\\Support\\HtmlString or Illuminate\\Contracts\\Support\\Htmlable. This allows you to render HTML, or even markdown, in the helper text:\n\n`Illuminate\\Support\\HtmlString``Illuminate\\Contracts\\Support\\Htmlable````\nuse Filament\\Infolists\\Components\\TextEntry;\nuse Illuminate\\Support\\HtmlString;\n\nTextEntry::make('name')\n    ->helperText(new HtmlString('Your <strong>full name</strong> here, including any middle names.'))\n\nTextEntry::make('name')\n    ->helperText(str('Your **full name** here, including any middle names.')->inlineMarkdown()->toHtmlString())\n\nTextEntry::make('name')\n    ->helperText(view('name-helper-text'))\n```",
                "level": 3
              },
              {
                "title": "## #Adding a hint next to the label",
                "content": "As well as helper text below the entry, you may also add a “hint” next to the label of the entry. This is useful for displaying additional information about the entry, such as a link to a help page.\n\nThe hint() method is used to add a hint:\n\n`hint()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint('Documentation? What documentation?!')\n```\n\nThis method accepts a plain text string, or an instance of Illuminate\\Support\\HtmlString or Illuminate\\Contracts\\Support\\Htmlable. This allows you to render HTML, or even markdown, in the helper text:\n\n`Illuminate\\Support\\HtmlString``Illuminate\\Contracts\\Support\\Htmlable````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(new HtmlString('<a href=\"/documentation\">Documentation</a>'))\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(str('[Documentation](/documentation)')->inlineMarkdown()->toHtmlString())\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(view('api-key-hint'))\n```",
                "level": 3
              },
              {
                "title": "### #Changing the text color of the hint",
                "content": "You can change the text color of the hint. By default, it’s gray, but you may use danger, info, primary, success and warning:\n\n`danger``info``primary``success``warning````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(str('[Documentation](/documentation)')->inlineMarkdown()->toHtmlString())\n    ->hintColor('primary')\n```",
                "level": 4
              },
              {
                "title": "### #Adding an icon aside the hint",
                "content": "Hints may also have an icon rendered next to them:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(str('[Documentation](/documentation)')->inlineMarkdown()->toHtmlString())\n    ->hintIcon('heroicon-m-question-mark-circle')\n```",
                "level": 4
              },
              {
                "title": "#### #Adding a tooltip to a hint icon",
                "content": "Additionally, you can add a tooltip to display when you hover over the hint icon, using the tooltip parameter of hintIcon():\n\n`tooltip``hintIcon()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('apiKey')\n    ->label('API key')\n    ->hint(str('[Documentation](/documentation)')->inlineMarkdown()->toHtmlString())\n    ->hintIcon('heroicon-m-question-mark-circle', tooltip: 'Read it!')\n```",
                "level": 5
              },
              {
                "title": "## #Hiding entries",
                "content": "To hide an entry conditionally, you may use the hidden() and visible() methods, whichever you prefer:\n\n`hidden()``visible()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('role')\n    ->hidden(! auth()->user()->isAdmin())\n// or\nTextEntry::make('role')\n    ->visible(auth()->user()->isAdmin())\n```",
                "level": 3
              },
              {
                "title": "## #Calculated state",
                "content": "Sometimes you need to calculate the state of an entry, instead of directly reading it from a database entry.\n\nBy passing a callback function to the state() method, you can customize the returned state for that entry:\n\n`state()````\nInfolists\\Components\\TextEntry::make('amount_including_vat')\n    ->state(function (Model $record): float {\n        return $record->amount * (1 + $record->vat_rate);\n    })\n```",
                "level": 3
              },
              {
                "title": "## #Tooltips",
                "content": "You may specify a tooltip to display when you hover over an entry:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('title')\n    ->tooltip('Shown at the top of the page')\n```\n\nThis method also accepts a closure that can access the current infolist record:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nTextEntry::make('title')\n    ->tooltip(fn (Model $record): string => \"By {$record->author->name}\")\n```",
                "level": 3
              },
              {
                "title": "## #Custom attributes",
                "content": "The HTML of entries can be customized, by passing an array of extraAttributes():\n\n`extraAttributes()````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('slug')\n    ->extraAttributes(['class' => 'bg-gray-200'])\n```\n\nThese get merged onto the outer <div> element of each entry in that entry.\n\n`<div>`You can also pass extra HTML attributes to the entry wrapper which surrounds the label, entry, and any other text:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('slug')\n    ->extraEntryWrapperAttributes(['class' => 'entry-locked'])\n```",
                "level": 3
              },
              {
                "title": "## #Global settings",
                "content": "If you wish to change the default behavior of all entries globally, then you can call the static configureUsing() method inside a service provider’s boot() method, to which you pass a Closure to modify the entries using. For example, if you wish to make all TextEntry components words(10), you can do it like so:\n\n`configureUsing()``boot()``TextEntry``words(10)````\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::configureUsing(function (TextEntry $entry): void {\n    $entry\n        ->words(10);\n});\n```\n\nOf course, you are still able to overwrite this on each entry individually:\n\n```\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('name')\n    ->words(null)\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Available entries",
              "Setting a label",
              "Entry URLs",
              "Opening URLs",
              "Setting a default value",
              "Adding placeholder text if an entry is empty",
              "Adding helper text below the entry",
              "Adding a hint next to the label",
              "Changing the text color of the hint"
            ],
            "code_examples_count": 48,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "layout": {
          "metadata": {
            "title": "Layout",
            "url": "https://filamentphp.com/docs/3.x/infolists/layout",
            "section": "infolists",
            "word_count": 332,
            "character_count": 2456
          },
          "content": {
            "full_text": "\n# Getting started - Infolists - Filament\n\nInfolists  \n-  Layout\n\n# Getting started\n\n## #Overview\n\nInfolists are not limited to just displaying entries. You can also use “layout components” to organize them into an infinitely nestable structure.\n\nLayout component classes can be found in the Filament\\Infolists\\Components namespace. They reside within the schema of your infolist, alongside any entries.\n\n`Filament\\Infolists\\Components`Components may be created using the static make() method. Usually, you will then define the child component schema() to display inside:\n\n`make()``schema()````\nuse Filament\\Infolists\\Components\\Grid;\n\nGrid::make(2)\n    ->schema([\n        // ...\n    ])\n```\n\n## #Available layout components\n\nFilament ships with some layout components, suitable for arranging your form fields depending on your needs:\n\n- Grid\n- Fieldset\n- Tabs\n- Section\n- Split\n\nYou may also create your own custom layout components to organize fields in whatever way you wish.\n\n## #Setting an ID\n\nYou may define an ID for the component using the id() method:\n\n`id()````\nuse Filament\\Infolists\\Components\\Section;\n\nSection::make()\n    ->id('main-section')\n```\n\n## #Adding extra HTML attributes\n\nYou can pass extra HTML attributes to the component, which will be merged onto the outer DOM element. Pass an array of attributes to the extraAttributes() method, where the key is the attribute name and the value is the attribute value:\n\n`extraAttributes()````\nuse Filament\\Infolists\\Components\\Group;\n\nSection::make()\n    ->extraAttributes(['class' => 'custom-section-style'])\n```\n\nClasses will be merged with the default classes, and any other attributes will override the default attributes.\n\n## #Global settings\n\nIf you wish to change the default behavior of a component globally, then you can call the static configureUsing() method inside a service provider’s boot() method, to which you pass a Closure to modify the component using. For example, if you wish to make all section components have 2 columns by default, you can do it like so:\n\n`configureUsing()``boot()````\nuse Filament\\Infolists\\Components\\Section;\n\nSection::configureUsing(function (Section $section): void {\n    $section\n        ->columns(2);\n});\n```\n\nOf course, you are still able to overwrite this on each field individually:\n\n```\nuse Filament\\Infolists\\Components\\Section;\n\nSection::make()\n    ->columns(1)\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Infolists - Filament",
                "content": "Infolists  \n-  Layout",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Infolists are not limited to just displaying entries. You can also use “layout components” to organize them into an infinitely nestable structure.\n\nLayout component classes can be found in the Filament\\Infolists\\Components namespace. They reside within the schema of your infolist, alongside any entries.\n\n`Filament\\Infolists\\Components`Components may be created using the static make() method. Usually, you will then define the child component schema() to display inside:\n\n`make()``schema()````\nuse Filament\\Infolists\\Components\\Grid;\n\nGrid::make(2)\n    ->schema([\n        // ...\n    ])\n```",
                "level": 3
              },
              {
                "title": "## #Available layout components",
                "content": "Filament ships with some layout components, suitable for arranging your form fields depending on your needs:\n\n- Grid\n- Fieldset\n- Tabs\n- Section\n- Split\n\nYou may also create your own custom layout components to organize fields in whatever way you wish.",
                "level": 3
              },
              {
                "title": "## #Setting an ID",
                "content": "You may define an ID for the component using the id() method:\n\n`id()````\nuse Filament\\Infolists\\Components\\Section;\n\nSection::make()\n    ->id('main-section')\n```",
                "level": 3
              },
              {
                "title": "## #Adding extra HTML attributes",
                "content": "You can pass extra HTML attributes to the component, which will be merged onto the outer DOM element. Pass an array of attributes to the extraAttributes() method, where the key is the attribute name and the value is the attribute value:\n\n`extraAttributes()````\nuse Filament\\Infolists\\Components\\Group;\n\nSection::make()\n    ->extraAttributes(['class' => 'custom-section-style'])\n```\n\nClasses will be merged with the default classes, and any other attributes will override the default attributes.",
                "level": 3
              },
              {
                "title": "## #Global settings",
                "content": "If you wish to change the default behavior of a component globally, then you can call the static configureUsing() method inside a service provider’s boot() method, to which you pass a Closure to modify the component using. For example, if you wish to make all section components have 2 columns by default, you can do it like so:\n\n`configureUsing()``boot()````\nuse Filament\\Infolists\\Components\\Section;\n\nSection::configureUsing(function (Section $section): void {\n    $section\n        ->columns(2);\n});\n```\n\nOf course, you are still able to overwrite this on each field individually:\n\n```\nuse Filament\\Infolists\\Components\\Section;\n\nSection::make()\n    ->columns(1)\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Available layout components",
              "Setting an ID",
              "Adding extra HTML attributes",
              "Global settings"
            ],
            "code_examples_count": 10,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "actions": {
          "metadata": {
            "title": "Actions",
            "url": "https://filamentphp.com/docs/3.x/infolists/actions",
            "section": "infolists",
            "word_count": 663,
            "character_count": 6809
          },
          "content": {
            "full_text": "\n# Actions - Infolists - Filament\n\nInfolists\n\n# Actions\n\n## #Overview\n\nFilament’s infolists can use Actions. They are buttons that can be added to any infolist component. Also, you can render anonymous sets of actions on their own, that are not attached to a particular infolist component.\n\n## #Defining a infolist component action\n\nAction objects inside an infolist component are instances of Filament/Infolists/Components/Actions/Action. You must pass a unique name to the action’s make() method, which is used to identify it amongst others internally within Filament. You can customize the trigger button of an action, and even open a modal with little effort:\n\n`Filament/Infolists/Components/Actions/Action``make()````\nuse App\\Actions\\ResetStars;\nuse Filament\\Infolists\\Components\\Actions\\Action;\n\nAction::make('resetStars')\n    ->icon('heroicon-m-x-mark')\n    ->color('danger')\n    ->requiresConfirmation()\n    ->action(function (ResetStars $resetStars) {\n        $resetStars();\n    })\n```\n\n### #Adding an affix action to a entry\n\nCertain entries support “affix actions”, which are buttons that can be placed before or after its content. The following entries support affix actions:\n\n- Text entry\n\nTo define an affix action, you can pass it to either prefixAction() or suffixAction():\n\n`prefixAction()``suffixAction()````\nuse App\\Models\\Product;\nuse Filament\\Infolists\\Components\\Actions\\Action;\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('cost')\n    ->prefix('€')\n    ->suffixAction(\n        Action::make('copyCostToPrice')\n            ->icon('heroicon-m-clipboard')\n            ->requiresConfirmation()\n            ->action(function (Product $record) {\n                $record->price = $record->cost;\n                $record->save();\n            })\n    )\n```\n\n#### #Passing multiple affix actions to a entry\n\nYou may pass multiple affix actions to an entry by passing them in an array to either prefixActions() or suffixActions(). Either method can be used, or both at once, Filament will render all the registered actions in order:\n\n`prefixActions()``suffixActions()````\nuse Filament\\Infolists\\Components\\Actions\\Action;\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('cost')\n    ->prefix('€')\n    ->prefixActions([\n        Action::make('...'),\n        Action::make('...'),\n        Action::make('...'),\n    ])\n    ->suffixActions([\n        Action::make('...'),\n        Action::make('...'),\n    ])\n```\n\n### #Adding a hint action to an entry\n\nAll entries support “hint actions”, which are rendered aside the entry’s hint. To add a hint action to a entry, you may pass it to hintAction():\n\n`hintAction()````\nuse App\\Models\\Product;\nuse Filament\\Infolists\\Components\\Actions\\Action;\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('cost')\n    ->prefix('€')\n    ->hintAction(\n        Action::make('copyCostToPrice')\n            ->icon('heroicon-m-clipboard')\n            ->requiresConfirmation()\n            ->action(function (Product $record) {\n                $record->price = $record->cost;\n                $record->save();\n            })\n    )\n```\n\n#### #Passing multiple hint actions to a entry\n\nYou may pass multiple hint actions to a entry by passing them in an array to hintActions(). Filament will render all the registered actions in order:\n\n`hintActions()````\nuse Filament\\Infolists\\Components\\Actions\\Action;\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('cost')\n    ->prefix('€')\n    ->hintActions([\n        Action::make('...'),\n        Action::make('...'),\n        Action::make('...'),\n    ])\n```\n\n### #Adding an action to a custom infolist component\n\nIf you wish to render an action within a custom infolist component, ViewEntry object, or View component object, you may do so using the registerActions() method:\n\n`ViewEntry``View``registerActions()````\nuse App\\Models\\Post;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Infolists\\Components\\Actions\\Action;\nuse Filament\\Infolists\\Components\\ViewEntry;\nuse Filament\\Infolists\\Set;\n\nViewEntry::make('status')\n    ->view('filament.infolists.entries.status-switcher')\n    ->registerActions([\n        Action::make('createStatus')\n            ->form([\n                TextInput::make('name')\n                    ->required(),\n            ])\n            ->icon('heroicon-m-plus')\n            ->action(function (array $data, Post $record) {\n                $record->status()->create($data);\n            }),\n    ])\n```\n\nNow, to render the action in the view of the custom component, you need to call $getAction(), passing the name of the action you registered:\n\n`$getAction()````\n<div>\n    <select></select>\n    \n    {{ $getAction('createStatus') }}\n</div>\n```\n\n### #Adding “anonymous” actions to an infolist without attaching them to a component\n\nYou may use an Actions component to render a set of actions anywhere in the infolist, avoiding the need to register them to any particular component:\n\n`Actions````\nuse App\\Actions\\Star;\nuse App\\Actions\\ResetStars;\nuse Filament\\Infolists\\Components\\Actions;\nuse Filament\\Infolists\\Components\\Actions\\Action;\n\nActions::make([\n    Action::make('star')\n        ->icon('heroicon-m-star')\n        ->requiresConfirmation()\n        ->action(function (Star $star) {\n            $star();\n        }),\n    Action::make('resetStars')\n        ->icon('heroicon-m-x-mark')\n        ->color('danger')\n        ->requiresConfirmation()\n        ->action(function (ResetStars $resetStars) {\n            $resetStars();\n        }),\n]),\n```\n\n#### #Making the independent infolist actions consume the full width of the infolist\n\nYou can stretch the independent infolist actions to consume the full width of the infolist using fullWidth():\n\n`fullWidth()````\nuse Filament\\Infolists\\Components\\Actions;\n\nActions::make([\n    // ...\n])->fullWidth(),\n```\n\n#### #Controlling the horizontal alignment of independent infolist actions\n\nIndependent infolist actions are aligned to the start of the component by default. You may change this by passing Alignment::Center or Alignment::End to alignment():\n\n`Alignment::Center``Alignment::End``alignment()````\nuse Filament\\Infolists\\Components\\Actions;\nuse Filament\\Support\\Enums\\Alignment;\n\nActions::make([\n    // ...\n])->alignment(Alignment::Center),\n```\n\n#### #Controlling the vertical alignment of independent infolist actions\n\nIndependent infolist actions are vertically aligned to the start of the component by default. You may change this by passing Alignment::Center or Alignment::End to verticalAlignment():\n\n`Alignment::Center``Alignment::End``verticalAlignment()````\nuse Filament\\Infolists\\Components\\Actions;\nuse Filament\\Support\\Enums\\VerticalAlignment;\n\nActions::make([\n    // ...\n])->verticalAlignment(VerticalAlignment::End),\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Actions - Infolists - Filament",
                "content": "Infolists",
                "level": 1
              },
              {
                "title": "# Actions",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament’s infolists can use Actions. They are buttons that can be added to any infolist component. Also, you can render anonymous sets of actions on their own, that are not attached to a particular infolist component.",
                "level": 3
              },
              {
                "title": "## #Defining a infolist component action",
                "content": "Action objects inside an infolist component are instances of Filament/Infolists/Components/Actions/Action. You must pass a unique name to the action’s make() method, which is used to identify it amongst others internally within Filament. You can customize the trigger button of an action, and even open a modal with little effort:\n\n`Filament/Infolists/Components/Actions/Action``make()````\nuse App\\Actions\\ResetStars;\nuse Filament\\Infolists\\Components\\Actions\\Action;\n\nAction::make('resetStars')\n    ->icon('heroicon-m-x-mark')\n    ->color('danger')\n    ->requiresConfirmation()\n    ->action(function (ResetStars $resetStars) {\n        $resetStars();\n    })\n```",
                "level": 3
              },
              {
                "title": "### #Adding an affix action to a entry",
                "content": "Certain entries support “affix actions”, which are buttons that can be placed before or after its content. The following entries support affix actions:\n\n- Text entry\n\nTo define an affix action, you can pass it to either prefixAction() or suffixAction():\n\n`prefixAction()``suffixAction()````\nuse App\\Models\\Product;\nuse Filament\\Infolists\\Components\\Actions\\Action;\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('cost')\n    ->prefix('€')\n    ->suffixAction(\n        Action::make('copyCostToPrice')\n            ->icon('heroicon-m-clipboard')\n            ->requiresConfirmation()\n            ->action(function (Product $record) {\n                $record->price = $record->cost;\n                $record->save();\n            })\n    )\n```",
                "level": 4
              },
              {
                "title": "#### #Passing multiple affix actions to a entry",
                "content": "You may pass multiple affix actions to an entry by passing them in an array to either prefixActions() or suffixActions(). Either method can be used, or both at once, Filament will render all the registered actions in order:\n\n`prefixActions()``suffixActions()````\nuse Filament\\Infolists\\Components\\Actions\\Action;\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('cost')\n    ->prefix('€')\n    ->prefixActions([\n        Action::make('...'),\n        Action::make('...'),\n        Action::make('...'),\n    ])\n    ->suffixActions([\n        Action::make('...'),\n        Action::make('...'),\n    ])\n```",
                "level": 5
              },
              {
                "title": "### #Adding a hint action to an entry",
                "content": "All entries support “hint actions”, which are rendered aside the entry’s hint. To add a hint action to a entry, you may pass it to hintAction():\n\n`hintAction()````\nuse App\\Models\\Product;\nuse Filament\\Infolists\\Components\\Actions\\Action;\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('cost')\n    ->prefix('€')\n    ->hintAction(\n        Action::make('copyCostToPrice')\n            ->icon('heroicon-m-clipboard')\n            ->requiresConfirmation()\n            ->action(function (Product $record) {\n                $record->price = $record->cost;\n                $record->save();\n            })\n    )\n```",
                "level": 4
              },
              {
                "title": "#### #Passing multiple hint actions to a entry",
                "content": "You may pass multiple hint actions to a entry by passing them in an array to hintActions(). Filament will render all the registered actions in order:\n\n`hintActions()````\nuse Filament\\Infolists\\Components\\Actions\\Action;\nuse Filament\\Infolists\\Components\\TextEntry;\n\nTextEntry::make('cost')\n    ->prefix('€')\n    ->hintActions([\n        Action::make('...'),\n        Action::make('...'),\n        Action::make('...'),\n    ])\n```",
                "level": 5
              },
              {
                "title": "### #Adding an action to a custom infolist component",
                "content": "If you wish to render an action within a custom infolist component, ViewEntry object, or View component object, you may do so using the registerActions() method:\n\n`ViewEntry``View``registerActions()````\nuse App\\Models\\Post;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Infolists\\Components\\Actions\\Action;\nuse Filament\\Infolists\\Components\\ViewEntry;\nuse Filament\\Infolists\\Set;\n\nViewEntry::make('status')\n    ->view('filament.infolists.entries.status-switcher')\n    ->registerActions([\n        Action::make('createStatus')\n            ->form([\n                TextInput::make('name')\n                    ->required(),\n            ])\n            ->icon('heroicon-m-plus')\n            ->action(function (array $data, Post $record) {\n                $record->status()->create($data);\n            }),\n    ])\n```\n\nNow, to render the action in the view of the custom component, you need to call $getAction(), passing the name of the action you registered:\n\n`$getAction()````\n<div>\n    <select></select>\n    \n    {{ $getAction('createStatus') }}\n</div>\n```",
                "level": 4
              },
              {
                "title": "### #Adding “anonymous” actions to an infolist without attaching them to a component",
                "content": "You may use an Actions component to render a set of actions anywhere in the infolist, avoiding the need to register them to any particular component:\n\n`Actions````\nuse App\\Actions\\Star;\nuse App\\Actions\\ResetStars;\nuse Filament\\Infolists\\Components\\Actions;\nuse Filament\\Infolists\\Components\\Actions\\Action;\n\nActions::make([\n    Action::make('star')\n        ->icon('heroicon-m-star')\n        ->requiresConfirmation()\n        ->action(function (Star $star) {\n            $star();\n        }),\n    Action::make('resetStars')\n        ->icon('heroicon-m-x-mark')\n        ->color('danger')\n        ->requiresConfirmation()\n        ->action(function (ResetStars $resetStars) {\n            $resetStars();\n        }),\n]),\n```",
                "level": 4
              },
              {
                "title": "#### #Making the independent infolist actions consume the full width of the infolist",
                "content": "You can stretch the independent infolist actions to consume the full width of the infolist using fullWidth():\n\n`fullWidth()````\nuse Filament\\Infolists\\Components\\Actions;\n\nActions::make([\n    // ...\n])->fullWidth(),\n```",
                "level": 5
              },
              {
                "title": "#### #Controlling the horizontal alignment of independent infolist actions",
                "content": "Independent infolist actions are aligned to the start of the component by default. You may change this by passing Alignment::Center or Alignment::End to alignment():\n\n`Alignment::Center``Alignment::End``alignment()````\nuse Filament\\Infolists\\Components\\Actions;\nuse Filament\\Support\\Enums\\Alignment;\n\nActions::make([\n    // ...\n])->alignment(Alignment::Center),\n```",
                "level": 5
              },
              {
                "title": "#### #Controlling the vertical alignment of independent infolist actions",
                "content": "Independent infolist actions are vertically aligned to the start of the component by default. You may change this by passing Alignment::Center or Alignment::End to verticalAlignment():\n\n`Alignment::Center``Alignment::End``verticalAlignment()````\nuse Filament\\Infolists\\Components\\Actions;\nuse Filament\\Support\\Enums\\VerticalAlignment;\n\nActions::make([\n    // ...\n])->verticalAlignment(VerticalAlignment::End),\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 5
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Defining a infolist component action",
              "Adding an affix action to a entry",
              "Adding a hint action to an entry",
              "Adding an action to a custom infolist component",
              "Adding “anonymous” actions to an infolist without attaching them to a component"
            ],
            "code_examples_count": 22,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "advanced": {
          "metadata": {
            "title": "Advanced",
            "url": "https://filamentphp.com/docs/3.x/infolists/advanced",
            "section": "infolists",
            "word_count": 239,
            "character_count": 1977
          },
          "content": {
            "full_text": "\n# Advanced infolists - Infolists - Filament\n\nInfolists\n\n# Advanced infolists\n\n## #Inserting Livewire components into an infolist\n\nYou may insert a Livewire component directly into an infolist:\n\n```\nuse Filament\\Infolists\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)\n```\n\nIf you are rendering multiple of the same Livewire component, please make sure to pass a unique key() to each:\n\n`key()````\nuse Filament\\Infolists\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)\n    ->key('foo-first')\n\nLivewire::make(Foo::class)\n    ->key('foo-second')\n\nLivewire::make(Foo::class)\n    ->key('foo-third')\n```\n\n### #Passing parameters to a Livewire component\n\nYou can pass an array of parameters to a Livewire component:\n\n```\nuse Filament\\Infolists\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class, ['bar' => 'baz'])\n```\n\nNow, those parameters will be passed to the Livewire component’s mount() method:\n\n`mount()````\nclass Foo extends Component\n{\n    public function mount(string $bar): void\n    {       \n        // ...\n    }\n}\n```\n\nAlternatively, they will be available as public properties on the Livewire component:\n\n```\nclass Foo extends Component\n{\n    public string $bar;\n}\n```\n\n#### #Accessing the current record in the Livewire component\n\nYou can access the current record in the Livewire component using the $record parameter in the mount() method, or the $record property:\n\n`$record``mount()``$record````\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Foo extends Component\n{\n    public function mount(Model $record): void\n    {       \n        // ...\n    }\n    \n    // or\n    \n    public Model $record;\n}\n```\n\n### #Lazy loading a Livewire component\n\nYou may allow the component to lazily load using the lazy() method:\n\n`lazy()````\nuse Filament\\Infolists\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)->lazy()\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Advanced infolists - Infolists - Filament",
                "content": "Infolists",
                "level": 1
              },
              {
                "title": "# Advanced infolists",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Inserting Livewire components into an infolist",
                "content": "You may insert a Livewire component directly into an infolist:\n\n```\nuse Filament\\Infolists\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)\n```\n\nIf you are rendering multiple of the same Livewire component, please make sure to pass a unique key() to each:\n\n`key()````\nuse Filament\\Infolists\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)\n    ->key('foo-first')\n\nLivewire::make(Foo::class)\n    ->key('foo-second')\n\nLivewire::make(Foo::class)\n    ->key('foo-third')\n```",
                "level": 3
              },
              {
                "title": "### #Passing parameters to a Livewire component",
                "content": "You can pass an array of parameters to a Livewire component:\n\n```\nuse Filament\\Infolists\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class, ['bar' => 'baz'])\n```\n\nNow, those parameters will be passed to the Livewire component’s mount() method:\n\n`mount()````\nclass Foo extends Component\n{\n    public function mount(string $bar): void\n    {       \n        // ...\n    }\n}\n```\n\nAlternatively, they will be available as public properties on the Livewire component:\n\n```\nclass Foo extends Component\n{\n    public string $bar;\n}\n```",
                "level": 4
              },
              {
                "title": "#### #Accessing the current record in the Livewire component",
                "content": "You can access the current record in the Livewire component using the $record parameter in the mount() method, or the $record property:\n\n`$record``mount()``$record````\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Foo extends Component\n{\n    public function mount(Model $record): void\n    {       \n        // ...\n    }\n    \n    // or\n    \n    public Model $record;\n}\n```",
                "level": 5
              },
              {
                "title": "### #Lazy loading a Livewire component",
                "content": "You may allow the component to lazily load using the lazy() method:\n\n`lazy()````\nuse Filament\\Infolists\\Components\\Livewire;\nuse App\\Livewire\\Foo;\n\nLivewire::make(Foo::class)->lazy()\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Inserting Livewire components into an infolist",
              "Passing parameters to a Livewire component",
              "Lazy loading a Livewire component"
            ],
            "code_examples_count": 14,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "adding-an-infolist-to-a-livewire-component": {
          "metadata": {
            "title": "Adding An Infolist To A Livewire Component",
            "url": "https://filamentphp.com/docs/3.x/infolists/adding-an-infolist-to-a-livewire-component",
            "section": "infolists",
            "word_count": 309,
            "character_count": 2918
          },
          "content": {
            "full_text": "\n# Adding an infolist to a Livewire component - Infolists - Filament\n\nInfolists\n\n# Adding an infolist to a Livewire component\n\n## #Setting up the Livewire component\n\nFirst, generate a new Livewire component:\n\n```\nphp artisan make:livewire ViewProduct\n```\n\nThen, render your Livewire component on the page:\n\n```\n@livewire('view-product')\n```\n\nAlternatively, you can use a full-page Livewire component:\n\n```\nuse App\\Livewire\\ViewProduct;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('products/{product}', ViewProduct::class);\n```\n\nYou must use the InteractsWithInfolists and InteractsWithForms traits, and implement the HasInfolists and HasForms interfaces on your Livewire component class:\n\n`InteractsWithInfolists``InteractsWithForms``HasInfolists``HasForms````\nuse Filament\\Forms\\Concerns\\InteractsWithForms;\nuse Filament\\Forms\\Contracts\\HasForms;\nuse Filament\\Infolists\\Concerns\\InteractsWithInfolists;\nuse Filament\\Infolists\\Contracts\\HasInfolists;\nuse Livewire\\Component;\n\nclass ViewProduct extends Component implements HasForms, HasInfolists\n{\n    use InteractsWithInfolists;\n    use InteractsWithForms;\n\n    // ...\n}\n```\n\n## #Adding the infolist\n\nNext, add a method to the Livewire component which accepts an $infolist object, modifies it, and returns it:\n\n`$infolist````\nuse Filament\\Infolists\\Infolist;\n\npublic function productInfolist(Infolist $infolist): Infolist\n{\n    return $infolist\n        ->record($this->product)\n        ->schema([\n            // ...\n        ]);\n}\n```\n\nFinally, render the infolist in the Livewire component’s view:\n\n```\n{{ $this->productInfolist }}\n```\n\n## #Passing data to the infolist\n\nYou can pass data to the infolist in two ways:\n\nEither pass an Eloquent model instance to the record() method of the infolist, to automatically map all the model attributes and relationships to the entries in the infolist’s schema:\n\n`record()````\nuse Filament\\Infolists\\Components\\TextEntry;\nuse Filament\\Infolists\\Infolist;\n\npublic function productInfolist(Infolist $infolist): Infolist\n{\n    return $infolist\n        ->record($this->product)\n        ->schema([\n            TextEntry::make('name'),\n            TextEntry::make('category.name'),\n            // ...\n        ]);\n}\n```\n\nAlternatively, you can pass an array of data to the state() method of the infolist, to manually map the data to the entries in the infolist’s schema:\n\n`state()````\nuse Filament\\Infolists\\Components\\TextEntry;\nuse Filament\\Infolists\\Infolist;\n\npublic function productInfolist(Infolist $infolist): Infolist\n{\n    return $infolist\n        ->state([\n            'name' => 'MacBook Pro',\n            'category' => [\n                'name' => 'Laptops',\n            ],\n            // ...\n        ])\n        ->schema([\n            TextEntry::make('name'),\n            TextEntry::make('category.name'),\n            // ...\n        ]);\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Adding an infolist to a Livewire component - Infolists - Filament",
                "content": "Infolists",
                "level": 1
              },
              {
                "title": "# Adding an infolist to a Livewire component",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Setting up the Livewire component",
                "content": "First, generate a new Livewire component:\n\n```\nphp artisan make:livewire ViewProduct\n```\n\nThen, render your Livewire component on the page:\n\n```\n@livewire('view-product')\n```\n\nAlternatively, you can use a full-page Livewire component:\n\n```\nuse App\\Livewire\\ViewProduct;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('products/{product}', ViewProduct::class);\n```\n\nYou must use the InteractsWithInfolists and InteractsWithForms traits, and implement the HasInfolists and HasForms interfaces on your Livewire component class:\n\n`InteractsWithInfolists``InteractsWithForms``HasInfolists``HasForms````\nuse Filament\\Forms\\Concerns\\InteractsWithForms;\nuse Filament\\Forms\\Contracts\\HasForms;\nuse Filament\\Infolists\\Concerns\\InteractsWithInfolists;\nuse Filament\\Infolists\\Contracts\\HasInfolists;\nuse Livewire\\Component;\n\nclass ViewProduct extends Component implements HasForms, HasInfolists\n{\n    use InteractsWithInfolists;\n    use InteractsWithForms;\n\n    // ...\n}\n```",
                "level": 3
              },
              {
                "title": "## #Adding the infolist",
                "content": "Next, add a method to the Livewire component which accepts an $infolist object, modifies it, and returns it:\n\n`$infolist````\nuse Filament\\Infolists\\Infolist;\n\npublic function productInfolist(Infolist $infolist): Infolist\n{\n    return $infolist\n        ->record($this->product)\n        ->schema([\n            // ...\n        ]);\n}\n```\n\nFinally, render the infolist in the Livewire component’s view:\n\n```\n{{ $this->productInfolist }}\n```",
                "level": 3
              },
              {
                "title": "## #Passing data to the infolist",
                "content": "You can pass data to the infolist in two ways:\n\nEither pass an Eloquent model instance to the record() method of the infolist, to automatically map all the model attributes and relationships to the entries in the infolist’s schema:\n\n`record()````\nuse Filament\\Infolists\\Components\\TextEntry;\nuse Filament\\Infolists\\Infolist;\n\npublic function productInfolist(Infolist $infolist): Infolist\n{\n    return $infolist\n        ->record($this->product)\n        ->schema([\n            TextEntry::make('name'),\n            TextEntry::make('category.name'),\n            // ...\n        ]);\n}\n```\n\nAlternatively, you can pass an array of data to the state() method of the infolist, to manually map the data to the entries in the infolist’s schema:\n\n`state()````\nuse Filament\\Infolists\\Components\\TextEntry;\nuse Filament\\Infolists\\Infolist;\n\npublic function productInfolist(Infolist $infolist): Infolist\n{\n    return $infolist\n        ->state([\n            'name' => 'MacBook Pro',\n            'category' => [\n                'name' => 'Laptops',\n            ],\n            // ...\n        ])\n        ->schema([\n            TextEntry::make('name'),\n            TextEntry::make('category.name'),\n            // ...\n        ]);\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Setting up the Livewire component",
              "Adding the infolist",
              "Passing data to the infolist"
            ],
            "code_examples_count": 16,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "testing": {
          "metadata": {
            "title": "Testing",
            "url": "https://filamentphp.com/docs/3.x/infolists/testing",
            "section": "infolists",
            "word_count": 787,
            "character_count": 9048
          },
          "content": {
            "full_text": "\n# Testing - Infolists - Filament\n\nInfolists\n\n# Testing\n\n## #Overview\n\nAll examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\nSince the Infolist Builder works on Livewire components, you can use the Livewire testing helpers. However, we have custom testing helpers that you can use with infolists:\n\n## #Actions\n\nYou can call an action by passing its infolist component key, and then the name of the action to callInfolistAction():\n\n`callInfolistAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callInfolistAction('customer', 'send', infolistName: 'infolist');\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue();\n});\n```\n\nTo pass an array of data into an action, use the data parameter:\n\n`data````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callInfolistAction('customer', 'send', data: [\n            'email' => $email = fake()->email(),\n        ])\n        ->assertHasNoInfolistActionErrors();\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($email);\n});\n```\n\nIf you ever need to only set an action’s data without immediately calling it, you can use setInfolistActionData():\n\n`setInfolistActionData()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountInfolistAction('customer', 'send')\n        ->setInfolistActionData([\n            'email' => $email = fake()->email(),\n        ])\n});\n```\n\n### #Execution\n\nTo check if an action has been halted, you can use assertInfolistActionHalted():\n\n`assertInfolistActionHalted()````\nuse function Pest\\Livewire\\livewire;\n\nit('stops sending if invoice has no email address', function () {\n    $invoice = Invoice::factory(['email' => null])->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callInfolistAction('customer', 'send')\n        ->assertInfolistActionHalted('customer', 'send');\n});\n```\n\n### #Errors\n\nassertHasNoInfolistActionErrors() is used to assert that no validation errors occurred when submitting the action form.\n\n`assertHasNoInfolistActionErrors()`To check if a validation error has occurred with the data, use assertHasInfolistActionErrors(), similar to assertHasErrors() in Livewire:\n\n`assertHasInfolistActionErrors()``assertHasErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate invoice recipient email', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callInfolistAction('customer', 'send', data: [\n            'email' => Str::random(),\n        ])\n        ->assertHasInfolistActionErrors(['email' => ['email']]);\n});\n```\n\nTo check if an action is pre-filled with data, you can use the assertInfolistActionDataSet() method:\n\n`assertInfolistActionDataSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices to the primary contact by default', function () {\n    $invoice = Invoice::factory()->create();\n    $recipientEmail = $invoice->company->primaryContact->email;\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountInfolistAction('customer', 'send')\n        ->assertInfolistActionDataSet([\n            'email' => $recipientEmail,\n        ])\n        ->callMountedInfolistAction()\n        ->assertHasNoInfolistActionErrors();\n        \n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($recipientEmail);\n});\n```\n\n### #Action state\n\nTo ensure that an action exists or doesn’t in an infolist, you can use the assertInfolistActionExists() or  assertInfolistActionDoesNotExist() method:\n\n`assertInfolistActionExists()``assertInfolistActionDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send but not unsend invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionExists('customer', 'send')\n        ->assertInfolistActionDoesNotExist('customer', 'unsend');\n});\n```\n\nTo ensure an action is hidden or visible for a user, you can use the assertInfolistActionHidden() or assertInfolistActionVisible() methods:\n\n`assertInfolistActionHidden()``assertInfolistActionVisible()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print customers', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionHidden('customer', 'send')\n        ->assertInfolistActionVisible('customer', 'print');\n});\n```\n\nTo ensure an action is enabled or disabled for a user, you can use the assertInfolistActionEnabled() or assertInfolistActionDisabled() methods:\n\n`assertInfolistActionEnabled()``assertInfolistActionDisabled()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print a customer for a sent invoice', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionDisabled('customer', 'send')\n        ->assertInfolistActionEnabled('customer', 'print');\n});\n```\n\nTo check if an action is hidden to a user, you can use the assertInfolistActionHidden() method:\n\n`assertInfolistActionHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionHidden('customer', 'send');\n});\n```\n\n### #Button appearance\n\nTo ensure an action has the correct label, you can use assertInfolistActionHasLabel() and assertInfolistActionDoesNotHaveLabel():\n\n`assertInfolistActionHasLabel()``assertInfolistActionDoesNotHaveLabel()````\nuse function Pest\\Livewire\\livewire;\n\nit('send action has correct label', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionHasLabel('customer', 'send', 'Email Invoice')\n        ->assertInfolistActionDoesNotHaveLabel('customer', 'send', 'Send');\n});\n```\n\nTo ensure an action’s button is showing the correct icon, you can use assertInfolistActionHasIcon() or assertInfolistActionDoesNotHaveIcon():\n\n`assertInfolistActionHasIcon()``assertInfolistActionDoesNotHaveIcon()````\nuse function Pest\\Livewire\\livewire;\n\nit('when enabled the send button has correct icon', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionEnabled('customer', 'send')\n        ->assertInfolistActionHasIcon('customer', 'send', 'envelope-open')\n        ->assertInfolistActionDoesNotHaveIcon('customer', 'send', 'envelope');\n});\n```\n\nTo ensure that an action’s button is displaying the right color, you can use assertInfolistActionHasColor() or assertInfolistActionDoesNotHaveColor():\n\n`assertInfolistActionHasColor()``assertInfolistActionDoesNotHaveColor()````\nuse function Pest\\Livewire\\livewire;\n\nit('actions display proper colors', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionHasColor('customer', 'delete', 'danger')\n        ->assertInfolistActionDoesNotHaveColor('customer', 'print', 'danger');\n});\n```\n\n### #URL\n\nTo ensure an action has the correct URL, you can use assertInfolistActionHasUrl(), assertInfolistActionDoesNotHaveUrl(), assertInfolistActionShouldOpenUrlInNewTab(), and assertInfolistActionShouldNotOpenUrlInNewTab():\n\n`assertInfolistActionHasUrl()``assertInfolistActionDoesNotHaveUrl()``assertInfolistActionShouldOpenUrlInNewTab()``assertInfolistActionShouldNotOpenUrlInNewTab()````\nuse function Pest\\Livewire\\livewire;\n\nit('links to the correct Filament sites', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionHasUrl('customer', 'filament', 'https://filamentphp.com/')\n        ->assertInfolistActionDoesNotHaveUrl('customer', 'filament', 'https://github.com/filamentphp/filament')\n        ->assertInfolistActionShouldOpenUrlInNewTab('customer', 'filament')\n        ->assertInfolistActionShouldNotOpenUrlInNewTab('customer', 'github');\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Testing - Infolists - Filament",
                "content": "Infolists",
                "level": 1
              },
              {
                "title": "# Testing",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "All examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\nSince the Infolist Builder works on Livewire components, you can use the Livewire testing helpers. However, we have custom testing helpers that you can use with infolists:",
                "level": 3
              },
              {
                "title": "## #Actions",
                "content": "You can call an action by passing its infolist component key, and then the name of the action to callInfolistAction():\n\n`callInfolistAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callInfolistAction('customer', 'send', infolistName: 'infolist');\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue();\n});\n```\n\nTo pass an array of data into an action, use the data parameter:\n\n`data````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callInfolistAction('customer', 'send', data: [\n            'email' => $email = fake()->email(),\n        ])\n        ->assertHasNoInfolistActionErrors();\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($email);\n});\n```\n\nIf you ever need to only set an action’s data without immediately calling it, you can use setInfolistActionData():\n\n`setInfolistActionData()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountInfolistAction('customer', 'send')\n        ->setInfolistActionData([\n            'email' => $email = fake()->email(),\n        ])\n});\n```",
                "level": 3
              },
              {
                "title": "### #Execution",
                "content": "To check if an action has been halted, you can use assertInfolistActionHalted():\n\n`assertInfolistActionHalted()````\nuse function Pest\\Livewire\\livewire;\n\nit('stops sending if invoice has no email address', function () {\n    $invoice = Invoice::factory(['email' => null])->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callInfolistAction('customer', 'send')\n        ->assertInfolistActionHalted('customer', 'send');\n});\n```",
                "level": 4
              },
              {
                "title": "### #Errors",
                "content": "assertHasNoInfolistActionErrors() is used to assert that no validation errors occurred when submitting the action form.\n\n`assertHasNoInfolistActionErrors()`To check if a validation error has occurred with the data, use assertHasInfolistActionErrors(), similar to assertHasErrors() in Livewire:\n\n`assertHasInfolistActionErrors()``assertHasErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate invoice recipient email', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callInfolistAction('customer', 'send', data: [\n            'email' => Str::random(),\n        ])\n        ->assertHasInfolistActionErrors(['email' => ['email']]);\n});\n```\n\nTo check if an action is pre-filled with data, you can use the assertInfolistActionDataSet() method:\n\n`assertInfolistActionDataSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices to the primary contact by default', function () {\n    $invoice = Invoice::factory()->create();\n    $recipientEmail = $invoice->company->primaryContact->email;\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountInfolistAction('customer', 'send')\n        ->assertInfolistActionDataSet([\n            'email' => $recipientEmail,\n        ])\n        ->callMountedInfolistAction()\n        ->assertHasNoInfolistActionErrors();\n        \n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($recipientEmail);\n});\n```",
                "level": 4
              },
              {
                "title": "### #Action state",
                "content": "To ensure that an action exists or doesn’t in an infolist, you can use the assertInfolistActionExists() or  assertInfolistActionDoesNotExist() method:\n\n`assertInfolistActionExists()``assertInfolistActionDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send but not unsend invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionExists('customer', 'send')\n        ->assertInfolistActionDoesNotExist('customer', 'unsend');\n});\n```\n\nTo ensure an action is hidden or visible for a user, you can use the assertInfolistActionHidden() or assertInfolistActionVisible() methods:\n\n`assertInfolistActionHidden()``assertInfolistActionVisible()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print customers', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionHidden('customer', 'send')\n        ->assertInfolistActionVisible('customer', 'print');\n});\n```\n\nTo ensure an action is enabled or disabled for a user, you can use the assertInfolistActionEnabled() or assertInfolistActionDisabled() methods:\n\n`assertInfolistActionEnabled()``assertInfolistActionDisabled()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print a customer for a sent invoice', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionDisabled('customer', 'send')\n        ->assertInfolistActionEnabled('customer', 'print');\n});\n```\n\nTo check if an action is hidden to a user, you can use the assertInfolistActionHidden() method:\n\n`assertInfolistActionHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionHidden('customer', 'send');\n});\n```",
                "level": 4
              },
              {
                "title": "### #Button appearance",
                "content": "To ensure an action has the correct label, you can use assertInfolistActionHasLabel() and assertInfolistActionDoesNotHaveLabel():\n\n`assertInfolistActionHasLabel()``assertInfolistActionDoesNotHaveLabel()````\nuse function Pest\\Livewire\\livewire;\n\nit('send action has correct label', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionHasLabel('customer', 'send', 'Email Invoice')\n        ->assertInfolistActionDoesNotHaveLabel('customer', 'send', 'Send');\n});\n```\n\nTo ensure an action’s button is showing the correct icon, you can use assertInfolistActionHasIcon() or assertInfolistActionDoesNotHaveIcon():\n\n`assertInfolistActionHasIcon()``assertInfolistActionDoesNotHaveIcon()````\nuse function Pest\\Livewire\\livewire;\n\nit('when enabled the send button has correct icon', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionEnabled('customer', 'send')\n        ->assertInfolistActionHasIcon('customer', 'send', 'envelope-open')\n        ->assertInfolistActionDoesNotHaveIcon('customer', 'send', 'envelope');\n});\n```\n\nTo ensure that an action’s button is displaying the right color, you can use assertInfolistActionHasColor() or assertInfolistActionDoesNotHaveColor():\n\n`assertInfolistActionHasColor()``assertInfolistActionDoesNotHaveColor()````\nuse function Pest\\Livewire\\livewire;\n\nit('actions display proper colors', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionHasColor('customer', 'delete', 'danger')\n        ->assertInfolistActionDoesNotHaveColor('customer', 'print', 'danger');\n});\n```",
                "level": 4
              },
              {
                "title": "### #URL",
                "content": "To ensure an action has the correct URL, you can use assertInfolistActionHasUrl(), assertInfolistActionDoesNotHaveUrl(), assertInfolistActionShouldOpenUrlInNewTab(), and assertInfolistActionShouldNotOpenUrlInNewTab():\n\n`assertInfolistActionHasUrl()``assertInfolistActionDoesNotHaveUrl()``assertInfolistActionShouldOpenUrlInNewTab()``assertInfolistActionShouldNotOpenUrlInNewTab()````\nuse function Pest\\Livewire\\livewire;\n\nit('links to the correct Filament sites', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertInfolistActionHasUrl('customer', 'filament', 'https://filamentphp.com/')\n        ->assertInfolistActionDoesNotHaveUrl('customer', 'filament', 'https://github.com/filamentphp/filament')\n        ->assertInfolistActionShouldOpenUrlInNewTab('customer', 'filament')\n        ->assertInfolistActionShouldNotOpenUrlInNewTab('customer', 'github');\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Actions",
              "Execution",
              "Errors",
              "Action state",
              "Button appearance"
            ],
            "code_examples_count": 28,
            "has_installation_info": true,
            "has_configuration": false,
            "has_examples": true
          }
        }
      }
    },
    "actions": {
      "section_info": {
        "name": "actions",
        "page_count": 10,
        "description": "Button and modal system for user interactions"
      },
      "pages": {
        "installation": {
          "metadata": {
            "title": "Installation",
            "url": "https://filamentphp.com/docs/3.x/actions/installation",
            "section": "actions",
            "word_count": 656,
            "character_count": 5490
          },
          "content": {
            "full_text": "\n# Installation - Actions - Filament\n\nActions\n\n# Installation\n\nThe Actions package is pre-installed with the Panel Builder. This guide is for using the Actions package in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)\n\n## #Installation\n\nRequire the Actions package using Composer:\n\n```\ncomposer require filament/actions:\"^3.3\" -W\n```\n\n## #New Laravel projects\n\nTo quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --actions\n\nnpm install\n\nnpm run dev\n```\n\n## #Existing Laravel projects\n\nRun the following command to install the Actions package assets:\n\n```\nphp artisan filament:install --actions\n```\n\n### #Installing Tailwind CSS\n\n> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```\n\n### #Configuring styles\n\nAdd Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```\n\n### #Automatically refreshing the browser\n\nYou may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```\n\n### #Compiling assets\n\nCompile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```\n\n## #Publishing configuration\n\nYou can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Upgrading\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Actions - Filament",
                "content": "Actions",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "The Actions package is pre-installed with the Panel Builder. This guide is for using the Actions package in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "Require the Actions package using Composer:\n\n```\ncomposer require filament/actions:\"^3.3\" -W\n```",
                "level": 3
              },
              {
                "title": "## #New Laravel projects",
                "content": "To quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --actions\n\nnpm install\n\nnpm run dev\n```",
                "level": 3
              },
              {
                "title": "## #Existing Laravel projects",
                "content": "Run the following command to install the Actions package assets:\n\n```\nphp artisan filament:install --actions\n```",
                "level": 3
              },
              {
                "title": "### #Installing Tailwind CSS",
                "content": "> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```",
                "level": 4
              },
              {
                "title": "### #Configuring styles",
                "content": "Add Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```",
                "level": 4
              },
              {
                "title": "### #Automatically refreshing the browser",
                "content": "You may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```",
                "level": 4
              },
              {
                "title": "### #Compiling assets",
                "content": "Compile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```",
                "level": 4
              },
              {
                "title": "## #Publishing configuration",
                "content": "You can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "Filament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "New Laravel projects",
              "Existing Laravel projects",
              "Installing Tailwind CSS",
              "Configuring styles",
              "Automatically refreshing the browser",
              "Compiling assets",
              "Publishing configuration",
              "Upgrading"
            ],
            "code_examples_count": 24,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "overview": {
          "metadata": {
            "title": "Overview",
            "url": "https://filamentphp.com/docs/3.x/actions/overview",
            "section": "actions",
            "word_count": 1187,
            "character_count": 7621
          },
          "content": {
            "full_text": "\n# Overview - Actions - Filament\n\nActions\n\n# Overview\n\n## #What is an action?\n\n“Action” is a word that is used quite a bit within the Laravel community. Traditionally, action PHP classes handle “doing” something in your application’s business logic. For instance, logging a user in, sending an email, or creating a new user record in the database.\n\nIn Filament, actions also handle “doing” something in your app. However, they are a bit different from traditional actions. They are designed to be used in the context of a user interface. For instance, you might have a button to delete a client record, which opens a modal to confirm your decision. When the user clicks the “Delete” button in the modal, the client is deleted. This whole workflow is an “action”.\n\n```\nAction::make('delete')\n    ->requiresConfirmation()\n    ->action(fn () => $this->client->delete())\n```\n\nActions can also collect extra information from the user. For instance, you might have a button to email a client. When the user clicks the button, a modal opens to collect the email subject and body. When the user clicks the “Send” button in the modal, the email is sent:\n\n```\nuse Filament\\Forms\\Components\\RichEditor;\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\Facades\\Mail;\n\nAction::make('sendEmail')\n    ->form([\n        TextInput::make('subject')->required(),\n        RichEditor::make('body')->required(),\n    ])\n    ->action(function (array $data) {\n        Mail::to($this->client)\n            ->send(new GenericEmail(\n                subject: $data['subject'],\n                body: $data['body'],\n            ));\n    })\n```\n\nUsually, actions get executed without redirecting the user away from the page. This is because we extensively use Livewire. However, actions can be much simpler, and don’t even need a modal. You can pass a URL to an action, and when the user clicks on the button, they are redirected to that page:\n\n```\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n```\n\nThe entire look of the action’s trigger button and the modal is customizable using fluent PHP methods. We provide a sensible and consistent styling for the UI, but all of this is customizable with CSS.\n\n## #Types of action\n\nThe concept of “actions” is used throughout Filament in many contexts. Some contexts don’t support opening modals from actions - they can only open a URL, call a public Livewire method, or dispatch a Livewire event. Additionally, different contexts use different action PHP classes since they provide the developer context-aware data that is appropriate to that use-case.\n\n### #Custom Livewire component actions\n\nYou can add an action to any Livewire component in your app, or even a page in a panel.\n\nThese actions use the Filament\\Actions\\Action class. They can open a modal if you choose, or even just a URL.\n\n`Filament\\Actions\\Action`If you’re looking to add an action to a Livewire component, visit this page in the docs. If you want to add an action to the header of a page in a panel, visit this page instead.\n\n### #Table actions\n\nFilament’s tables also use actions. Actions can be added to the end of any table row, or even in the header of a table. For instance, you may want an action to “create” a new record in the header, and then “edit” and “delete” actions on each row. Additionally, actions can be added to any table column, such that each cell in that column is a trigger for your action.\n\nThese actions use the Filament\\Tables\\Actions\\Action class. They can open a modal if you choose, or even just a URL.\n\n`Filament\\Tables\\Actions\\Action`If you’re looking to add an action to a table in your app, visit this page in the docs.\n\n#### #Table bulk actions\n\nTables also support “bulk actions”. These can be used when the user selects rows in the table. Traditionally, when rows are selected, a “bulk actions” button appears in the top left corner of the table. When the user clicks this button, they are presented with a dropdown menu of actions to choose from. Bulk actions may also be added to the header of a table, next to other header actions. In this case, bulk action trigger buttons are disabled until the user selects table rows.\n\nThese actions use the Filament\\Tables\\Actions\\BulkAction class. They can open modals if you choose.\n\n`Filament\\Tables\\Actions\\BulkAction`If you’re looking to add a bulk action to a table in your app, visit this page in the docs.\n\n### #Form component actions\n\nForm components can contain actions. A good use case for actions inside form components would be with a select field, and an action button to “create” a new record. When you click on the button, a modal opens to collect the new record’s data. When the modal form is submitted, the new record is created in the database, and the select field is filled with the newly created record. Fortunately, this case is handled for you out of the box, but it’s a good example of how form component actions can be powerful.\n\nThese actions use the Filament\\Forms\\Components\\Actions\\Action class. They can open a modal if you choose, or even just a URL.\n\n`Filament\\Forms\\Components\\Actions\\Action`If you’re looking to add an action to a form component in your app, visit this page in the docs.\n\n### #Infolist component actions\n\nInfolist components can contain actions. These use the Filament\\Infolists\\Components\\Actions\\Action class. They can open a modal if you choose, or even just a URL.\n\n`Filament\\Infolists\\Components\\Actions\\Action`If you’re looking to add an action to an infolist component in your app, visit this page in the docs.\n\n### #Notification actions\n\nWhen you send notifications, you can add actions. These buttons are rendered below the content of the notification. For example, a notification to alert the user that they have a new message should contain an action button that opens the conversation thread.\n\nThese actions use the Filament\\Notifications\\Actions\\Action class. They aren’t able to open modals, but they can open a URL or dispatch a Livewire event.\n\n`Filament\\Notifications\\Actions\\Action`If you’re looking to add an action to a notification in your app, visit this page in the docs.\n\n### #Global search result actions\n\nIn the Panel Builder, there is a global search field that allows you to search all resources in your app from one place. When you click on a search result, it leads you to the resource page for that record. However, you may add additional actions below each global search result. For example, you may want both “Edit” and “View” options for a client search result, so the user can quickly edit their profile as well as view it in read-only mode.\n\nThese actions use the Filament\\GlobalSearch\\Actions\\Action class. They aren’t able to open modals, but they can open a URL or dispatch a Livewire event.\n\n`Filament\\GlobalSearch\\Actions\\Action`If you’re looking to add an action to a global search result in a panel, visit this page in the docs.\n\n## #Prebuilt actions\n\nFilament includes several prebuilt actions that you can add to your app. Their aim is to simplify the most common Eloquent-related actions:\n\n- Create\n- Edit\n- View\n- Delete\n- Replicate\n- Force-delete\n- Restore\n- Import\n- Export\n\n## #Grouping actions\n\nYou may group actions together into a dropdown menu by using an ActionGroup object. Groups may contain many actions, or other groups:\n\n`ActionGroup````\nActionGroup::make([\n    Action::make('view'),\n    Action::make('edit'),\n    Action::make('delete'),\n])\n```\n\nTo learn about how to group actions, see the Grouping actions page.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Overview - Actions - Filament",
                "content": "Actions",
                "level": 1
              },
              {
                "title": "# Overview",
                "content": "",
                "level": 1
              },
              {
                "title": "## #What is an action?",
                "content": "“Action” is a word that is used quite a bit within the Laravel community. Traditionally, action PHP classes handle “doing” something in your application’s business logic. For instance, logging a user in, sending an email, or creating a new user record in the database.\n\nIn Filament, actions also handle “doing” something in your app. However, they are a bit different from traditional actions. They are designed to be used in the context of a user interface. For instance, you might have a button to delete a client record, which opens a modal to confirm your decision. When the user clicks the “Delete” button in the modal, the client is deleted. This whole workflow is an “action”.\n\n```\nAction::make('delete')\n    ->requiresConfirmation()\n    ->action(fn () => $this->client->delete())\n```\n\nActions can also collect extra information from the user. For instance, you might have a button to email a client. When the user clicks the button, a modal opens to collect the email subject and body. When the user clicks the “Send” button in the modal, the email is sent:\n\n```\nuse Filament\\Forms\\Components\\RichEditor;\nuse Filament\\Forms\\Components\\TextInput;\nuse Illuminate\\Support\\Facades\\Mail;\n\nAction::make('sendEmail')\n    ->form([\n        TextInput::make('subject')->required(),\n        RichEditor::make('body')->required(),\n    ])\n    ->action(function (array $data) {\n        Mail::to($this->client)\n            ->send(new GenericEmail(\n                subject: $data['subject'],\n                body: $data['body'],\n            ));\n    })\n```\n\nUsually, actions get executed without redirecting the user away from the page. This is because we extensively use Livewire. However, actions can be much simpler, and don’t even need a modal. You can pass a URL to an action, and when the user clicks on the button, they are redirected to that page:\n\n```\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n```\n\nThe entire look of the action’s trigger button and the modal is customizable using fluent PHP methods. We provide a sensible and consistent styling for the UI, but all of this is customizable with CSS.",
                "level": 3
              },
              {
                "title": "## #Types of action",
                "content": "The concept of “actions” is used throughout Filament in many contexts. Some contexts don’t support opening modals from actions - they can only open a URL, call a public Livewire method, or dispatch a Livewire event. Additionally, different contexts use different action PHP classes since they provide the developer context-aware data that is appropriate to that use-case.",
                "level": 3
              },
              {
                "title": "### #Custom Livewire component actions",
                "content": "You can add an action to any Livewire component in your app, or even a page in a panel.\n\nThese actions use the Filament\\Actions\\Action class. They can open a modal if you choose, or even just a URL.\n\n`Filament\\Actions\\Action`If you’re looking to add an action to a Livewire component, visit this page in the docs. If you want to add an action to the header of a page in a panel, visit this page instead.",
                "level": 4
              },
              {
                "title": "### #Table actions",
                "content": "Filament’s tables also use actions. Actions can be added to the end of any table row, or even in the header of a table. For instance, you may want an action to “create” a new record in the header, and then “edit” and “delete” actions on each row. Additionally, actions can be added to any table column, such that each cell in that column is a trigger for your action.\n\nThese actions use the Filament\\Tables\\Actions\\Action class. They can open a modal if you choose, or even just a URL.\n\n`Filament\\Tables\\Actions\\Action`If you’re looking to add an action to a table in your app, visit this page in the docs.",
                "level": 4
              },
              {
                "title": "#### #Table bulk actions",
                "content": "Tables also support “bulk actions”. These can be used when the user selects rows in the table. Traditionally, when rows are selected, a “bulk actions” button appears in the top left corner of the table. When the user clicks this button, they are presented with a dropdown menu of actions to choose from. Bulk actions may also be added to the header of a table, next to other header actions. In this case, bulk action trigger buttons are disabled until the user selects table rows.\n\nThese actions use the Filament\\Tables\\Actions\\BulkAction class. They can open modals if you choose.\n\n`Filament\\Tables\\Actions\\BulkAction`If you’re looking to add a bulk action to a table in your app, visit this page in the docs.",
                "level": 5
              },
              {
                "title": "### #Form component actions",
                "content": "Form components can contain actions. A good use case for actions inside form components would be with a select field, and an action button to “create” a new record. When you click on the button, a modal opens to collect the new record’s data. When the modal form is submitted, the new record is created in the database, and the select field is filled with the newly created record. Fortunately, this case is handled for you out of the box, but it’s a good example of how form component actions can be powerful.\n\nThese actions use the Filament\\Forms\\Components\\Actions\\Action class. They can open a modal if you choose, or even just a URL.\n\n`Filament\\Forms\\Components\\Actions\\Action`If you’re looking to add an action to a form component in your app, visit this page in the docs.",
                "level": 4
              },
              {
                "title": "### #Infolist component actions",
                "content": "Infolist components can contain actions. These use the Filament\\Infolists\\Components\\Actions\\Action class. They can open a modal if you choose, or even just a URL.\n\n`Filament\\Infolists\\Components\\Actions\\Action`If you’re looking to add an action to an infolist component in your app, visit this page in the docs.",
                "level": 4
              },
              {
                "title": "### #Notification actions",
                "content": "When you send notifications, you can add actions. These buttons are rendered below the content of the notification. For example, a notification to alert the user that they have a new message should contain an action button that opens the conversation thread.\n\nThese actions use the Filament\\Notifications\\Actions\\Action class. They aren’t able to open modals, but they can open a URL or dispatch a Livewire event.\n\n`Filament\\Notifications\\Actions\\Action`If you’re looking to add an action to a notification in your app, visit this page in the docs.",
                "level": 4
              },
              {
                "title": "### #Global search result actions",
                "content": "In the Panel Builder, there is a global search field that allows you to search all resources in your app from one place. When you click on a search result, it leads you to the resource page for that record. However, you may add additional actions below each global search result. For example, you may want both “Edit” and “View” options for a client search result, so the user can quickly edit their profile as well as view it in read-only mode.\n\nThese actions use the Filament\\GlobalSearch\\Actions\\Action class. They aren’t able to open modals, but they can open a URL or dispatch a Livewire event.\n\n`Filament\\GlobalSearch\\Actions\\Action`If you’re looking to add an action to a global search result in a panel, visit this page in the docs.",
                "level": 4
              },
              {
                "title": "## #Prebuilt actions",
                "content": "Filament includes several prebuilt actions that you can add to your app. Their aim is to simplify the most common Eloquent-related actions:\n\n- Create\n- Edit\n- View\n- Delete\n- Replicate\n- Force-delete\n- Restore\n- Import\n- Export",
                "level": 3
              },
              {
                "title": "## #Grouping actions",
                "content": "You may group actions together into a dropdown menu by using an ActionGroup object. Groups may contain many actions, or other groups:\n\n`ActionGroup````\nActionGroup::make([\n    Action::make('view'),\n    Action::make('edit'),\n    Action::make('delete'),\n])\n```\n\nTo learn about how to group actions, see the Grouping actions page.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "What is an action?",
              "Types of action",
              "Custom Livewire component actions",
              "Table actions",
              "Form component actions",
              "Infolist component actions",
              "Notification actions",
              "Global search result actions",
              "Prebuilt actions",
              "Grouping actions"
            ],
            "code_examples_count": 8,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "trigger-button": {
          "metadata": {
            "title": "Trigger Button",
            "url": "https://filamentphp.com/docs/3.x/actions/trigger-button",
            "section": "actions",
            "word_count": 872,
            "character_count": 6784
          },
          "content": {
            "full_text": "\n# Trigger button - Actions - Filament\n\nActions\n\n# Trigger button\n\n## #Overview\n\nAll actions have a trigger button. When the user clicks on it, the action is executed - a modal will open, a closure function will be executed, or they will be redirected to a URL.\n\nThis page is about customizing the look of that trigger button.\n\n## #Choosing a trigger style\n\nOut of the box, action triggers have 4 styles - “button”, “link”, “icon button”, and “badge”.\n\n“Button” triggers have a background color, label, and optionally an icon. Usually, this is the default button style, but you can use it manually with the button() method:\n\n`button()````\nAction::make('edit')\n    ->button()\n```\n\n“Link” triggers have no background color. They must have a label and optionally an icon. They look like a link that you might find embedded within text. You can switch to that style with the link() method:\n\n`link()````\nAction::make('edit')\n    ->link()\n```\n\n“Icon button” triggers are circular buttons with an icon and no label. You can switch to that style with the iconButton() method:\n\n`iconButton()````\nAction::make('edit')\n    ->icon('heroicon-m-pencil-square')\n    ->iconButton()\n```\n\n“Badge” triggers have a background color, label, and optionally an icon. You can use a badge as trigger using the badge() method:\n\n`badge()````\nAction::make('edit')\n    ->badge()\n```\n\n### #Using an icon button on mobile devices only\n\nYou may want to use a button style with a label on desktop, but remove the label on mobile. This will transform it into an icon button. You can do this with the labeledFrom() method, passing in the responsive breakpoint at which you want the label to be added to the button:\n\n`labeledFrom()````\nAction::make('edit')\n    ->icon('heroicon-m-pencil-square')\n    ->button()\n    ->labeledFrom('md')\n```\n\n## #Setting a label\n\nBy default, the label of the trigger button is generated from its name. You may customize this using the label() method:\n\n`label()````\nAction::make('edit')\n    ->label('Edit post')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n```\n\nOptionally, you can have the label automatically translated using Laravel’s localization features with the translateLabel() method:\n\n`translateLabel()````\nAction::make('edit')\n    ->translateLabel() // Equivalent to `label(__('Edit'))`\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n```\n\n## #Setting a color\n\nButtons may have a color to indicate their significance. It may be either danger, gray, info, primary, success or warning:\n\n`danger``gray``info``primary``success``warning````\nAction::make('delete')\n    ->color('danger')\n```\n\n## #Setting a size\n\nButtons come in 3 sizes - ActionSize::Small, ActionSize::Medium or ActionSize::Large. You can change the size of the action’s trigger using the size() method:\n\n`ActionSize::Small``ActionSize::Medium``ActionSize::Large``size()````\nuse Filament\\Support\\Enums\\ActionSize;\n\nAction::make('create')\n    ->size(ActionSize::Large)\n```\n\n## #Setting an icon\n\nButtons may have an icon to add more detail to the UI. You can set the icon using the icon() method:\n\n`icon()````\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->icon('heroicon-m-pencil-square')\n```\n\nYou can also change the icon’s position to be after the label instead of before it, using the iconPosition() method:\n\n`iconPosition()````\nuse Filament\\Support\\Enums\\IconPosition;\n\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->icon('heroicon-m-pencil-square')\n    ->iconPosition(IconPosition::After)\n```\n\n## #Authorization\n\nYou may conditionally show or hide actions for certain users. To do this, you can use either the visible() or hidden() methods:\n\n`visible()``hidden()````\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->visible(auth()->user()->can('update', $this->post))\n\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->hidden(! auth()->user()->can('update', $this->post))\n```\n\nThis is useful for authorization of certain actions to only users who have permission.\n\n### #Disabling a button\n\nIf you want to disable a button instead of hiding it, you can use the disabled() method:\n\n`disabled()````\nAction::make('delete')\n    ->disabled()\n```\n\nYou can conditionally disable a button by passing a boolean to it:\n\n```\nAction::make('delete')\n    ->disabled(! auth()->user()->can('delete', $this->post))\n```\n\n## #Registering keybindings\n\nYou can attach keyboard shortcuts to trigger buttons. These use the same key codes as Mousetrap:\n\n```\nuse Filament\\Actions\\Action;\n\nAction::make('save')\n    ->action(fn () => $this->save())\n    ->keyBindings(['command+s', 'ctrl+s'])\n```\n\n## #Adding a badge to the corner of the button\n\nYou can add a badge to the corner of the button, to display whatever you want. It’s useful for displaying a count of something, or a status indicator:\n\n```\nuse Filament\\Actions\\Action;\n\nAction::make('filter')\n    ->iconButton()\n    ->icon('heroicon-m-funnel')\n    ->badge(5)\n```\n\nYou can also pass a color to be used for the badge, which can be either danger, gray, info, primary, success and warning:\n\n`danger``gray``info``primary``success``warning````\nuse Filament\\Actions\\Action;\n\nAction::make('filter')\n    ->iconButton()\n    ->icon('heroicon-m-funnel')\n    ->badge(5)\n    ->badgeColor('success')\n```\n\n## #Outlined button style\n\nWhen you’re using the “button” trigger style, you might wish to make it less prominent. You could use a different color, but sometimes you might want to make it outlined instead. You can do this with the outlined() method:\n\n`outlined()````\nuse Filament\\Actions\\Action;\n\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->button()\n    ->outlined()\n```\n\n## #Adding extra HTML attributes\n\nYou can pass extra HTML attributes to the button which will be merged onto the outer DOM element. Pass an array of attributes to the extraAttributes() method, where the key is the attribute name and the value is the attribute value:\n\n`extraAttributes()````\nuse Filament\\Actions\\Action;\n\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->extraAttributes([\n        'title' => 'Edit this post',\n    ])\n```\n\nIf you pass CSS classes in a string, they will be merged with the default classes that already apply to the other HTML element of the button:\n\n```\nuse Filament\\Actions\\Action;\n\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->extraAttributes([\n        'class' => 'mx-auto my-8',\n    ])\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Trigger button - Actions - Filament",
                "content": "Actions",
                "level": 1
              },
              {
                "title": "# Trigger button",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "All actions have a trigger button. When the user clicks on it, the action is executed - a modal will open, a closure function will be executed, or they will be redirected to a URL.\n\nThis page is about customizing the look of that trigger button.",
                "level": 3
              },
              {
                "title": "## #Choosing a trigger style",
                "content": "Out of the box, action triggers have 4 styles - “button”, “link”, “icon button”, and “badge”.\n\n“Button” triggers have a background color, label, and optionally an icon. Usually, this is the default button style, but you can use it manually with the button() method:\n\n`button()````\nAction::make('edit')\n    ->button()\n```\n\n“Link” triggers have no background color. They must have a label and optionally an icon. They look like a link that you might find embedded within text. You can switch to that style with the link() method:\n\n`link()````\nAction::make('edit')\n    ->link()\n```\n\n“Icon button” triggers are circular buttons with an icon and no label. You can switch to that style with the iconButton() method:\n\n`iconButton()````\nAction::make('edit')\n    ->icon('heroicon-m-pencil-square')\n    ->iconButton()\n```\n\n“Badge” triggers have a background color, label, and optionally an icon. You can use a badge as trigger using the badge() method:\n\n`badge()````\nAction::make('edit')\n    ->badge()\n```",
                "level": 3
              },
              {
                "title": "### #Using an icon button on mobile devices only",
                "content": "You may want to use a button style with a label on desktop, but remove the label on mobile. This will transform it into an icon button. You can do this with the labeledFrom() method, passing in the responsive breakpoint at which you want the label to be added to the button:\n\n`labeledFrom()````\nAction::make('edit')\n    ->icon('heroicon-m-pencil-square')\n    ->button()\n    ->labeledFrom('md')\n```",
                "level": 4
              },
              {
                "title": "## #Setting a label",
                "content": "By default, the label of the trigger button is generated from its name. You may customize this using the label() method:\n\n`label()````\nAction::make('edit')\n    ->label('Edit post')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n```\n\nOptionally, you can have the label automatically translated using Laravel’s localization features with the translateLabel() method:\n\n`translateLabel()````\nAction::make('edit')\n    ->translateLabel() // Equivalent to `label(__('Edit'))`\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n```",
                "level": 3
              },
              {
                "title": "## #Setting a color",
                "content": "Buttons may have a color to indicate their significance. It may be either danger, gray, info, primary, success or warning:\n\n`danger``gray``info``primary``success``warning````\nAction::make('delete')\n    ->color('danger')\n```",
                "level": 3
              },
              {
                "title": "## #Setting a size",
                "content": "Buttons come in 3 sizes - ActionSize::Small, ActionSize::Medium or ActionSize::Large. You can change the size of the action’s trigger using the size() method:\n\n`ActionSize::Small``ActionSize::Medium``ActionSize::Large``size()````\nuse Filament\\Support\\Enums\\ActionSize;\n\nAction::make('create')\n    ->size(ActionSize::Large)\n```",
                "level": 3
              },
              {
                "title": "## #Setting an icon",
                "content": "Buttons may have an icon to add more detail to the UI. You can set the icon using the icon() method:\n\n`icon()````\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->icon('heroicon-m-pencil-square')\n```\n\nYou can also change the icon’s position to be after the label instead of before it, using the iconPosition() method:\n\n`iconPosition()````\nuse Filament\\Support\\Enums\\IconPosition;\n\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->icon('heroicon-m-pencil-square')\n    ->iconPosition(IconPosition::After)\n```",
                "level": 3
              },
              {
                "title": "## #Authorization",
                "content": "You may conditionally show or hide actions for certain users. To do this, you can use either the visible() or hidden() methods:\n\n`visible()``hidden()````\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->visible(auth()->user()->can('update', $this->post))\n\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->hidden(! auth()->user()->can('update', $this->post))\n```\n\nThis is useful for authorization of certain actions to only users who have permission.",
                "level": 3
              },
              {
                "title": "### #Disabling a button",
                "content": "If you want to disable a button instead of hiding it, you can use the disabled() method:\n\n`disabled()````\nAction::make('delete')\n    ->disabled()\n```\n\nYou can conditionally disable a button by passing a boolean to it:\n\n```\nAction::make('delete')\n    ->disabled(! auth()->user()->can('delete', $this->post))\n```",
                "level": 4
              },
              {
                "title": "## #Registering keybindings",
                "content": "You can attach keyboard shortcuts to trigger buttons. These use the same key codes as Mousetrap:\n\n```\nuse Filament\\Actions\\Action;\n\nAction::make('save')\n    ->action(fn () => $this->save())\n    ->keyBindings(['command+s', 'ctrl+s'])\n```",
                "level": 3
              },
              {
                "title": "## #Adding a badge to the corner of the button",
                "content": "You can add a badge to the corner of the button, to display whatever you want. It’s useful for displaying a count of something, or a status indicator:\n\n```\nuse Filament\\Actions\\Action;\n\nAction::make('filter')\n    ->iconButton()\n    ->icon('heroicon-m-funnel')\n    ->badge(5)\n```\n\nYou can also pass a color to be used for the badge, which can be either danger, gray, info, primary, success and warning:\n\n`danger``gray``info``primary``success``warning````\nuse Filament\\Actions\\Action;\n\nAction::make('filter')\n    ->iconButton()\n    ->icon('heroicon-m-funnel')\n    ->badge(5)\n    ->badgeColor('success')\n```",
                "level": 3
              },
              {
                "title": "## #Outlined button style",
                "content": "When you’re using the “button” trigger style, you might wish to make it less prominent. You could use a different color, but sometimes you might want to make it outlined instead. You can do this with the outlined() method:\n\n`outlined()````\nuse Filament\\Actions\\Action;\n\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->button()\n    ->outlined()\n```",
                "level": 3
              },
              {
                "title": "## #Adding extra HTML attributes",
                "content": "You can pass extra HTML attributes to the button which will be merged onto the outer DOM element. Pass an array of attributes to the extraAttributes() method, where the key is the attribute name and the value is the attribute value:\n\n`extraAttributes()````\nuse Filament\\Actions\\Action;\n\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->extraAttributes([\n        'title' => 'Edit this post',\n    ])\n```\n\nIf you pass CSS classes in a string, they will be merged with the default classes that already apply to the other HTML element of the button:\n\n```\nuse Filament\\Actions\\Action;\n\nAction::make('edit')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n    ->extraAttributes([\n        'class' => 'mx-auto my-8',\n    ])\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Choosing a trigger style",
              "Using an icon button on mobile devices only",
              "Setting a label",
              "Setting a color",
              "Setting a size",
              "Setting an icon",
              "Authorization",
              "Disabling a button",
              "Registering keybindings"
            ],
            "code_examples_count": 40,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "modals": {
          "metadata": {
            "title": "Modals",
            "url": "https://filamentphp.com/docs/3.x/actions/modals",
            "section": "actions",
            "word_count": 2314,
            "character_count": 20415
          },
          "content": {
            "full_text": "\n# Modals - Actions - Filament\n\nActions\n\n# Modals\n\n## #Overview\n\nActions may require additional confirmation or input from the user before they run. You may open a modal before an action is executed to do this.\n\n## #Confirmation modals\n\nYou may require confirmation before an action is run using the requiresConfirmation() method. This is useful for particularly destructive actions, such as those that delete records.\n\n`requiresConfirmation()````\nuse App\\Models\\Post;\n\nAction::make('delete')\n    ->action(fn (Post $record) => $record->delete())\n    ->requiresConfirmation()\n```\n\n> The confirmation modal is not available when a url() is set instead of an action(). Instead, you should redirect to the URL within the action() closure.\n\nThe confirmation modal is not available when a url() is set instead of an action(). Instead, you should redirect to the URL within the action() closure.\n\n`url()``action()``action()`## #Modal forms\n\nYou may also render a form in the modal to collect extra information from the user before the action runs.\n\nYou may use components from the Form Builder to create custom action modal forms. The data from the form is available in the $data array of the action() closure:\n\n`$data``action()````\nuse App\\Models\\Post;\nuse App\\Models\\User;\nuse Filament\\Forms\\Components\\Select;\n\nAction::make('updateAuthor')\n    ->form([\n        Select::make('authorId')\n            ->label('Author')\n            ->options(User::query()->pluck('name', 'id'))\n            ->required(),\n    ])\n    ->action(function (array $data, Post $record): void {\n        $record->author()->associate($data['authorId']);\n        $record->save();\n    })\n```\n\n### #Filling the form with existing data\n\nYou may fill the form with existing data, using the fillForm() method:\n\n`fillForm()````\nuse App\\Models\\Post;\nuse App\\Models\\User;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Forms\\Form;\n\nAction::make('updateAuthor')\n    ->fillForm(fn (Post $record): array => [\n        'authorId' => $record->author->id,\n    ])\n    ->form([\n        Select::make('authorId')\n            ->label('Author')\n            ->options(User::query()->pluck('name', 'id'))\n            ->required(),\n    ])\n    ->action(function (array $data, Post $record): void {\n        $record->author()->associate($data['authorId']);\n        $record->save();\n    })\n```\n\n### #Using a wizard as a modal form\n\nYou may create a multistep form wizard inside a modal. Instead of using a form(), define a steps() array and pass your Step objects:\n\n`form()``steps()``Step````\nuse Filament\\Forms\\Components\\MarkdownEditor;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Components\\Toggle;\nuse Filament\\Forms\\Components\\Wizard\\Step;\n\nAction::make('create')\n    ->steps([\n        Step::make('Name')\n            ->description('Give the category a unique name')\n            ->schema([\n                TextInput::make('name')\n                    ->required()\n                    ->live()\n                    ->afterStateUpdated(fn ($state, callable $set) => $set('slug', Str::slug($state))),\n                TextInput::make('slug')\n                    ->disabled()\n                    ->required()\n                    ->unique(Category::class, 'slug'),\n            ])\n            ->columns(2),\n        Step::make('Description')\n            ->description('Add some extra details')\n            ->schema([\n                MarkdownEditor::make('description'),\n            ]),\n        Step::make('Visibility')\n            ->description('Control who can view it')\n            ->schema([\n                Toggle::make('is_visible')\n                    ->label('Visible to customers.')\n                    ->default(true),\n            ]),\n    ])\n```\n\n### #Disabling all form fields\n\nYou may wish to disable all form fields in the modal, ensuring the user cannot edit them. You may do so using the disabledForm() method:\n\n`disabledForm()````\nuse App\\Models\\Post;\nuse App\\Models\\User;\nuse Filament\\Forms\\Components\\Textarea;\nuse Filament\\Forms\\Components\\TextInput;\n\nAction::make('approvePost')\n    ->form([\n        TextInput::make('title'),\n        Textarea::make('content'),\n    ])\n    ->fillForm(fn (Post $record): array => [\n        'title' => $record->title,\n        'content' => $record->content,\n    ])\n    ->disabledForm()\n    ->action(function (Post $record): void {\n        $record->approve();\n    })\n```\n\n## #Customizing the modal’s heading, description, and submit action label\n\nYou may customize the heading, description and label of the submit button in the modal:\n\n```\nuse App\\Models\\Post;\n\nAction::make('delete')\n    ->action(fn (Post $record) => $record->delete())\n    ->requiresConfirmation()\n    ->modalHeading('Delete post')\n    ->modalDescription('Are you sure you\\'d like to delete this post? This cannot be undone.')\n    ->modalSubmitActionLabel('Yes, delete it')\n```\n\n## #Adding an icon inside the modal\n\nYou may add an icon inside the modal using the modalIcon() method:\n\n`modalIcon()````\nuse App\\Models\\Post;\n\nAction::make('delete')\n    ->action(fn (Post $record) => $record->delete())\n    ->requiresConfirmation()\n    ->modalIcon('heroicon-o-trash')\n```\n\nBy default, the icon will inherit the color of the action button. You may customize the color of the icon using the modalIconColor() method:\n\n`modalIconColor()````\nuse App\\Models\\Post;\n\nAction::make('delete')\n    ->action(fn (Post $record) => $record->delete())\n    ->requiresConfirmation()\n    ->color('danger')\n    ->modalIcon('heroicon-o-trash')\n    ->modalIconColor('warning')\n```\n\n## #Customizing the alignment of modal content\n\nBy default, modal content will be aligned to the start, or centered if the modal is xs or sm in width. If you wish to change the alignment of content in a modal, you can use the modalAlignment() method and pass it Alignment::Start or Alignment::Center:\n\n`xs``sm``modalAlignment()``Alignment::Start``Alignment::Center````\nuse Filament\\Support\\Enums\\Alignment;\n\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->modalAlignment(Alignment::Center)\n```\n\n## #Custom modal content\n\nYou may define custom content to be rendered inside your modal, which you can specify by passing a Blade view into the modalContent() method:\n\n`modalContent()````\nuse App\\Models\\Post;\n\nAction::make('advance')\n    ->action(fn (Post $record) => $record->advance())\n    ->modalContent(view('filament.pages.actions.advance'))\n```\n\n### #Passing data to the custom modal content\n\nYou can pass data to the view by returning it from a function. For example, if the $record of an action is set, you can pass that through to the view:\n\n`$record````\nuse Illuminate\\Contracts\\View\\View;\n\nAction::make('advance')\n    ->action(fn (Contract $record) => $record->advance())\n    ->modalContent(fn (Contract $record): View => view(\n        'filament.pages.actions.advance',\n        ['record' => $record],\n    ))\n```\n\n### #Adding custom modal content below the form\n\nBy default, the custom content is displayed above the modal form if there is one, but you can add content below using modalContentFooter() if you wish:\n\n`modalContentFooter()````\nuse App\\Models\\Post;\n\nAction::make('advance')\n    ->action(fn (Post $record) => $record->advance())\n    ->modalContentFooter(view('filament.pages.actions.advance'))\n```\n\n### #Adding an action to custom modal content\n\nYou can add an action button to your custom modal content, which is useful if you want to add a button that performs an action other than the main action. You can do this by registering an action with the registerModalActions() method, and then passing it to the view:\n\n`registerModalActions()````\nuse App\\Models\\Post;\nuse Illuminate\\Contracts\\View\\View;\n\nAction::make('advance')\n    ->registerModalActions([\n        Action::make('report')\n            ->requiresConfirmation()\n            ->action(fn (Post $record) => $record->report()),\n    ])\n    ->action(fn (Post $record) => $record->advance())\n    ->modalContent(fn (Action $action): View => view(\n        'filament.pages.actions.advance',\n        ['action' => $action],\n    ))\n```\n\nNow, in the view file, you can render the action button by calling getModalAction():\n\n`getModalAction()````\n<div>\n    {{ $action->getModalAction('report') }}\n</div>\n```\n\n## #Using a slide-over instead of a modal\n\nYou can open a “slide-over” dialog instead of a modal by using the slideOver() method:\n\n`slideOver()````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->slideOver()\n```\n\nInstead of opening in the center of the screen, the modal content will now slide in from the right and consume the entire height of the browser.\n\n## #Making the modal header sticky\n\nThe header of a modal scrolls out of view with the modal content when it overflows the modal size. However, slide-overs have a sticky header that’s always visible. You may control this behavior using stickyModalHeader():\n\n`stickyModalHeader()````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->stickyModalHeader()\n```\n\n## #Making the modal footer sticky\n\nThe footer of a modal is rendered inline after the content by default. Slide-overs, however, have a sticky footer that always shows when scrolling the content. You may enable this for a modal too using stickyModalFooter():\n\n`stickyModalFooter()````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->stickyModalFooter()\n```\n\n## #Changing the modal width\n\nYou can change the width of the modal by using the modalWidth() method. Options correspond to Tailwind’s max-width scale. The options are ExtraSmall, Small, Medium, Large, ExtraLarge, TwoExtraLarge, ThreeExtraLarge, FourExtraLarge, FiveExtraLarge, SixExtraLarge, SevenExtraLarge, and Screen:\n\n`modalWidth()``ExtraSmall``Small``Medium``Large``ExtraLarge``TwoExtraLarge``ThreeExtraLarge``FourExtraLarge``FiveExtraLarge``SixExtraLarge``SevenExtraLarge``Screen````\nuse Filament\\Support\\Enums\\MaxWidth;\n\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->modalWidth(MaxWidth::FiveExtraLarge)\n```\n\n## #Executing code when the modal opens\n\nYou may execute code within a closure when the modal opens, by passing it to the mountUsing() method:\n\n`mountUsing()````\nuse Filament\\Forms\\Form;\n\nAction::make('create')\n    ->mountUsing(function (Form $form) {\n        $form->fill();\n\n        // ...\n    })\n```\n\n> The mountUsing() method, by default, is used by Filament to initialize the form. If you override this method, you will need to call $form->fill() to ensure the form is initialized correctly. If you wish to populate the form with data, you can do so by passing an array to the fill() method, instead of using fillForm() on the action itself.\n\nThe mountUsing() method, by default, is used by Filament to initialize the form. If you override this method, you will need to call $form->fill() to ensure the form is initialized correctly. If you wish to populate the form with data, you can do so by passing an array to the fill() method, instead of using fillForm() on the action itself.\n\n`mountUsing()``$form->fill()``fill()``fillForm()`## #Customizing the action buttons in the footer of the modal\n\nBy default, there are two actions in the footer of a modal. The first is a button to submit, which executes the action(). The second button closes the modal and cancels the action.\n\n`action()`### #Modifying a default modal footer action button\n\nTo modify the action instance that is used to render one of the default action buttons, you may pass a closure to the modalSubmitAction() and modalCancelAction() methods:\n\n`modalSubmitAction()``modalCancelAction()````\nuse Filament\\Actions\\StaticAction;\n\nAction::make('help')\n    ->modalContent(view('actions.help'))\n    ->modalCancelAction(fn (StaticAction $action) => $action->label('Close'))\n```\n\nThe methods available to customize trigger buttons will work to modify the $action instance inside the closure.\n\n`$action`### #Removing a default modal footer action button\n\nTo remove a default action, you may pass false to either modalSubmitAction() or modalCancelAction():\n\n`false``modalSubmitAction()``modalCancelAction()````\nAction::make('help')\n    ->modalContent(view('actions.help'))\n    ->modalSubmitAction(false)\n```\n\n### #Adding an extra modal action button to the footer\n\nYou may pass an array of extra actions to be rendered, between the default actions, in the footer of the modal using the extraModalFooterActions() method:\n\n`extraModalFooterActions()````\nAction::make('create')\n    ->form([\n        // ...\n    ])\n    // ...\n    ->extraModalFooterActions(fn (Action $action): array => [\n        $action->makeModalSubmitAction('createAnother', arguments: ['another' => true]),\n    ])\n```\n\n$action->makeModalSubmitAction() returns an action instance that can be customized using the methods available to customize trigger buttons.\n\n`$action->makeModalSubmitAction()`The second parameter of makeModalSubmitAction() allows you to pass an array of arguments that will be accessible inside the action’s action() closure as $arguments. These could be useful as flags to indicate that the action should behave differently based on the user’s decision:\n\n`makeModalSubmitAction()``action()``$arguments````\nAction::make('create')\n    ->form([\n        // ...\n    ])\n    // ...\n    ->extraModalFooterActions(fn (Action $action): array => [\n        $action->makeModalSubmitAction('createAnother', arguments: ['another' => true]),\n    ])\n    ->action(function (array $data, array $arguments): void {\n        // Create\n\n        if ($arguments['another'] ?? false) {\n            // Reset the form and don't close the modal\n        }\n    })\n```\n\n#### #Opening another modal from an extra footer action\n\nYou can nest actions within each other, allowing you to open a new modal from an extra footer action:\n\n```\nAction::make('edit')\n    // ...\n    ->extraModalFooterActions([\n        Action::make('delete')\n            ->requiresConfirmation()\n            ->action(function () {\n                // ...\n            }),\n    ])\n```\n\nNow, the edit modal will have a “Delete” button in the footer, which will open a confirmation modal when clicked. This action is completely independent of the edit action, and will not run the edit action when it is clicked.\n\n`edit``edit`In this example though, you probably want to cancel the edit action if the delete action is run. You can do this using the cancelParentActions() method:\n\n`edit``delete``cancelParentActions()````\nAction::make('delete')\n    ->requiresConfirmation()\n    ->action(function () {\n        // ...\n    })\n    ->cancelParentActions()\n```\n\nIf you have deep nesting with multiple parent actions, but you don’t want to cancel all of them, you can pass the name of the parent action you want to cancel, including its children, to cancelParentActions():\n\n`cancelParentActions()````\nAction::make('first')\n    ->requiresConfirmation()\n    ->action(function () {\n        // ...\n    })\n    ->extraModalFooterActions([\n        Action::make('second')\n            ->requiresConfirmation()\n            ->action(function () {\n                // ...\n            })\n            ->extraModalFooterActions([\n                Action::make('third')\n                    ->requiresConfirmation()\n                    ->action(function () {\n                        // ...\n                    })\n                    ->extraModalFooterActions([\n                        Action::make('fourth')\n                            ->requiresConfirmation()\n                            ->action(function () {\n                                // ...\n                            })\n                            ->cancelParentActions('second'),\n                    ]),\n            ]),\n    ])\n```\n\nIn this example, if the fourth action is run, the second action is canceled, but so is the third action since it is a child of second. The first action is not canceled, however, since it is the parent of second. The first action’s modal will remain open.\n\n`fourth``second``third``second``first``second``first`## #Closing the modal by clicking away\n\nBy default, when you click away from a modal, it will close itself. If you wish to disable this behavior for a specific action, you can use the closeModalByClickingAway(false) method:\n\n`closeModalByClickingAway(false)````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->closeModalByClickingAway(false)\n```\n\nIf you’d like to change the behavior for all modals in the application, you can do so by calling Modal::closedByClickingAway() inside a service provider or middleware:\n\n`Modal::closedByClickingAway()````\nuse Filament\\Support\\View\\Components\\Modal;\n\nModal::closedByClickingAway(false);\n```\n\n## #Closing the modal by escaping\n\nBy default, when you press escape on a modal, it will close itself. If you wish to disable this behavior for a specific action, you can use the closeModalByEscaping(false) method:\n\n`closeModalByEscaping(false)````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->closeModalByEscaping(false)\n```\n\nIf you’d like to change the behavior for all modals in the application, you can do so by calling Modal::closedByEscaping() inside a service provider or middleware:\n\n`Modal::closedByEscaping()````\nuse Filament\\Support\\View\\Components\\Modal;\n\nModal::closedByEscaping(false);\n```\n\n## #Hiding the modal close button\n\nBy default, modals have a close button in the top right corner. If you wish to hide the close button, you can use the modalCloseButton(false) method:\n\n`modalCloseButton(false)````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->modalCloseButton(false)\n```\n\nIf you’d like to hide the close button for all modals in the application, you can do so by calling Modal::closeButton(false) inside a service provider or middleware:\n\n`Modal::closeButton(false)````\nuse Filament\\Support\\View\\Components\\Modal;\n\nModal::closeButton(false);\n```\n\n## #Preventing the modal from autofocusing\n\nBy default, modals will autofocus on the first focusable element when opened. If you wish to disable this behavior, you can use the modalAutofocus(false) method:\n\n`modalAutofocus(false)````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->modalAutofocus(false)\n```\n\nIf you’d like to disable autofocus for all modals in the application, you can do so by calling Modal::autofocus(false) inside a service provider or middleware:\n\n`Modal::autofocus(false)````\nuse Filament\\Support\\View\\Components\\Modal;\n\nModal::autofocus(false);\n```\n\n## #Optimizing modal configuration methods\n\nWhen you use database queries or other heavy operations inside modal configuration methods like modalHeading(), they can be executed more than once. This is because Filament uses these methods to decide whether to render the modal or not, and also to render the modal’s content.\n\n`modalHeading()`To skip the check that Filament does to decide whether to render the modal, you can use the modal() method, which will inform Filament that the modal exists for this action and it does not need to check again:\n\n`modal()````\nAction::make('updateAuthor')\n    ->modal()\n```\n\n## #Conditionally hiding the modal\n\nYou may have a need to conditionally show a modal for confirmation reasons while falling back to the default action. This can be achieved using modalHidden():\n\n`modalHidden()````\nAction::make('create')\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->modalHidden(fn (): bool => $this->role !== 'admin')\n    ->modalContent(view('filament.pages.actions.create'))\n```\n\n## #Adding extra attributes to the modal window\n\nYou may also pass extra HTML attributes to the modal window using extraModalWindowAttributes():\n\n`extraModalWindowAttributes()````\nAction::make('updateAuthor')\n    ->extraModalWindowAttributes(['class' => 'update-author-modal'])\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Modals - Actions - Filament",
                "content": "Actions",
                "level": 1
              },
              {
                "title": "# Modals",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Actions may require additional confirmation or input from the user before they run. You may open a modal before an action is executed to do this.",
                "level": 3
              },
              {
                "title": "## #Confirmation modals",
                "content": "You may require confirmation before an action is run using the requiresConfirmation() method. This is useful for particularly destructive actions, such as those that delete records.\n\n`requiresConfirmation()````\nuse App\\Models\\Post;\n\nAction::make('delete')\n    ->action(fn (Post $record) => $record->delete())\n    ->requiresConfirmation()\n```\n\n> The confirmation modal is not available when a url() is set instead of an action(). Instead, you should redirect to the URL within the action() closure.\n\nThe confirmation modal is not available when a url() is set instead of an action(). Instead, you should redirect to the URL within the action() closure.\n\n`url()``action()``action()`## #Modal forms\n\nYou may also render a form in the modal to collect extra information from the user before the action runs.\n\nYou may use components from the Form Builder to create custom action modal forms. The data from the form is available in the $data array of the action() closure:\n\n`$data``action()````\nuse App\\Models\\Post;\nuse App\\Models\\User;\nuse Filament\\Forms\\Components\\Select;\n\nAction::make('updateAuthor')\n    ->form([\n        Select::make('authorId')\n            ->label('Author')\n            ->options(User::query()->pluck('name', 'id'))\n            ->required(),\n    ])\n    ->action(function (array $data, Post $record): void {\n        $record->author()->associate($data['authorId']);\n        $record->save();\n    })\n```",
                "level": 3
              },
              {
                "title": "### #Filling the form with existing data",
                "content": "You may fill the form with existing data, using the fillForm() method:\n\n`fillForm()````\nuse App\\Models\\Post;\nuse App\\Models\\User;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Forms\\Form;\n\nAction::make('updateAuthor')\n    ->fillForm(fn (Post $record): array => [\n        'authorId' => $record->author->id,\n    ])\n    ->form([\n        Select::make('authorId')\n            ->label('Author')\n            ->options(User::query()->pluck('name', 'id'))\n            ->required(),\n    ])\n    ->action(function (array $data, Post $record): void {\n        $record->author()->associate($data['authorId']);\n        $record->save();\n    })\n```",
                "level": 4
              },
              {
                "title": "### #Using a wizard as a modal form",
                "content": "You may create a multistep form wizard inside a modal. Instead of using a form(), define a steps() array and pass your Step objects:\n\n`form()``steps()``Step````\nuse Filament\\Forms\\Components\\MarkdownEditor;\nuse Filament\\Forms\\Components\\TextInput;\nuse Filament\\Forms\\Components\\Toggle;\nuse Filament\\Forms\\Components\\Wizard\\Step;\n\nAction::make('create')\n    ->steps([\n        Step::make('Name')\n            ->description('Give the category a unique name')\n            ->schema([\n                TextInput::make('name')\n                    ->required()\n                    ->live()\n                    ->afterStateUpdated(fn ($state, callable $set) => $set('slug', Str::slug($state))),\n                TextInput::make('slug')\n                    ->disabled()\n                    ->required()\n                    ->unique(Category::class, 'slug'),\n            ])\n            ->columns(2),\n        Step::make('Description')\n            ->description('Add some extra details')\n            ->schema([\n                MarkdownEditor::make('description'),\n            ]),\n        Step::make('Visibility')\n            ->description('Control who can view it')\n            ->schema([\n                Toggle::make('is_visible')\n                    ->label('Visible to customers.')\n                    ->default(true),\n            ]),\n    ])\n```",
                "level": 4
              },
              {
                "title": "### #Disabling all form fields",
                "content": "You may wish to disable all form fields in the modal, ensuring the user cannot edit them. You may do so using the disabledForm() method:\n\n`disabledForm()````\nuse App\\Models\\Post;\nuse App\\Models\\User;\nuse Filament\\Forms\\Components\\Textarea;\nuse Filament\\Forms\\Components\\TextInput;\n\nAction::make('approvePost')\n    ->form([\n        TextInput::make('title'),\n        Textarea::make('content'),\n    ])\n    ->fillForm(fn (Post $record): array => [\n        'title' => $record->title,\n        'content' => $record->content,\n    ])\n    ->disabledForm()\n    ->action(function (Post $record): void {\n        $record->approve();\n    })\n```",
                "level": 4
              },
              {
                "title": "## #Customizing the modal’s heading, description, and submit action label",
                "content": "You may customize the heading, description and label of the submit button in the modal:\n\n```\nuse App\\Models\\Post;\n\nAction::make('delete')\n    ->action(fn (Post $record) => $record->delete())\n    ->requiresConfirmation()\n    ->modalHeading('Delete post')\n    ->modalDescription('Are you sure you\\'d like to delete this post? This cannot be undone.')\n    ->modalSubmitActionLabel('Yes, delete it')\n```",
                "level": 3
              },
              {
                "title": "## #Adding an icon inside the modal",
                "content": "You may add an icon inside the modal using the modalIcon() method:\n\n`modalIcon()````\nuse App\\Models\\Post;\n\nAction::make('delete')\n    ->action(fn (Post $record) => $record->delete())\n    ->requiresConfirmation()\n    ->modalIcon('heroicon-o-trash')\n```\n\nBy default, the icon will inherit the color of the action button. You may customize the color of the icon using the modalIconColor() method:\n\n`modalIconColor()````\nuse App\\Models\\Post;\n\nAction::make('delete')\n    ->action(fn (Post $record) => $record->delete())\n    ->requiresConfirmation()\n    ->color('danger')\n    ->modalIcon('heroicon-o-trash')\n    ->modalIconColor('warning')\n```",
                "level": 3
              },
              {
                "title": "## #Customizing the alignment of modal content",
                "content": "By default, modal content will be aligned to the start, or centered if the modal is xs or sm in width. If you wish to change the alignment of content in a modal, you can use the modalAlignment() method and pass it Alignment::Start or Alignment::Center:\n\n`xs``sm``modalAlignment()``Alignment::Start``Alignment::Center````\nuse Filament\\Support\\Enums\\Alignment;\n\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->modalAlignment(Alignment::Center)\n```",
                "level": 3
              },
              {
                "title": "## #Custom modal content",
                "content": "You may define custom content to be rendered inside your modal, which you can specify by passing a Blade view into the modalContent() method:\n\n`modalContent()````\nuse App\\Models\\Post;\n\nAction::make('advance')\n    ->action(fn (Post $record) => $record->advance())\n    ->modalContent(view('filament.pages.actions.advance'))\n```",
                "level": 3
              },
              {
                "title": "### #Passing data to the custom modal content",
                "content": "You can pass data to the view by returning it from a function. For example, if the $record of an action is set, you can pass that through to the view:\n\n`$record````\nuse Illuminate\\Contracts\\View\\View;\n\nAction::make('advance')\n    ->action(fn (Contract $record) => $record->advance())\n    ->modalContent(fn (Contract $record): View => view(\n        'filament.pages.actions.advance',\n        ['record' => $record],\n    ))\n```",
                "level": 4
              },
              {
                "title": "### #Adding custom modal content below the form",
                "content": "By default, the custom content is displayed above the modal form if there is one, but you can add content below using modalContentFooter() if you wish:\n\n`modalContentFooter()````\nuse App\\Models\\Post;\n\nAction::make('advance')\n    ->action(fn (Post $record) => $record->advance())\n    ->modalContentFooter(view('filament.pages.actions.advance'))\n```",
                "level": 4
              },
              {
                "title": "### #Adding an action to custom modal content",
                "content": "You can add an action button to your custom modal content, which is useful if you want to add a button that performs an action other than the main action. You can do this by registering an action with the registerModalActions() method, and then passing it to the view:\n\n`registerModalActions()````\nuse App\\Models\\Post;\nuse Illuminate\\Contracts\\View\\View;\n\nAction::make('advance')\n    ->registerModalActions([\n        Action::make('report')\n            ->requiresConfirmation()\n            ->action(fn (Post $record) => $record->report()),\n    ])\n    ->action(fn (Post $record) => $record->advance())\n    ->modalContent(fn (Action $action): View => view(\n        'filament.pages.actions.advance',\n        ['action' => $action],\n    ))\n```\n\nNow, in the view file, you can render the action button by calling getModalAction():\n\n`getModalAction()````\n<div>\n    {{ $action->getModalAction('report') }}\n</div>\n```",
                "level": 4
              },
              {
                "title": "## #Using a slide-over instead of a modal",
                "content": "You can open a “slide-over” dialog instead of a modal by using the slideOver() method:\n\n`slideOver()````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->slideOver()\n```\n\nInstead of opening in the center of the screen, the modal content will now slide in from the right and consume the entire height of the browser.",
                "level": 3
              },
              {
                "title": "## #Making the modal header sticky",
                "content": "The header of a modal scrolls out of view with the modal content when it overflows the modal size. However, slide-overs have a sticky header that’s always visible. You may control this behavior using stickyModalHeader():\n\n`stickyModalHeader()````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->stickyModalHeader()\n```",
                "level": 3
              },
              {
                "title": "## #Making the modal footer sticky",
                "content": "The footer of a modal is rendered inline after the content by default. Slide-overs, however, have a sticky footer that always shows when scrolling the content. You may enable this for a modal too using stickyModalFooter():\n\n`stickyModalFooter()````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->stickyModalFooter()\n```",
                "level": 3
              },
              {
                "title": "## #Changing the modal width",
                "content": "You can change the width of the modal by using the modalWidth() method. Options correspond to Tailwind’s max-width scale. The options are ExtraSmall, Small, Medium, Large, ExtraLarge, TwoExtraLarge, ThreeExtraLarge, FourExtraLarge, FiveExtraLarge, SixExtraLarge, SevenExtraLarge, and Screen:\n\n`modalWidth()``ExtraSmall``Small``Medium``Large``ExtraLarge``TwoExtraLarge``ThreeExtraLarge``FourExtraLarge``FiveExtraLarge``SixExtraLarge``SevenExtraLarge``Screen````\nuse Filament\\Support\\Enums\\MaxWidth;\n\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->modalWidth(MaxWidth::FiveExtraLarge)\n```",
                "level": 3
              },
              {
                "title": "## #Executing code when the modal opens",
                "content": "You may execute code within a closure when the modal opens, by passing it to the mountUsing() method:\n\n`mountUsing()````\nuse Filament\\Forms\\Form;\n\nAction::make('create')\n    ->mountUsing(function (Form $form) {\n        $form->fill();\n\n        // ...\n    })\n```\n\n> The mountUsing() method, by default, is used by Filament to initialize the form. If you override this method, you will need to call $form->fill() to ensure the form is initialized correctly. If you wish to populate the form with data, you can do so by passing an array to the fill() method, instead of using fillForm() on the action itself.\n\nThe mountUsing() method, by default, is used by Filament to initialize the form. If you override this method, you will need to call $form->fill() to ensure the form is initialized correctly. If you wish to populate the form with data, you can do so by passing an array to the fill() method, instead of using fillForm() on the action itself.\n\n`mountUsing()``$form->fill()``fill()``fillForm()`## #Customizing the action buttons in the footer of the modal\n\nBy default, there are two actions in the footer of a modal. The first is a button to submit, which executes the action(). The second button closes the modal and cancels the action.\n\n`action()`### #Modifying a default modal footer action button\n\nTo modify the action instance that is used to render one of the default action buttons, you may pass a closure to the modalSubmitAction() and modalCancelAction() methods:\n\n`modalSubmitAction()``modalCancelAction()````\nuse Filament\\Actions\\StaticAction;\n\nAction::make('help')\n    ->modalContent(view('actions.help'))\n    ->modalCancelAction(fn (StaticAction $action) => $action->label('Close'))\n```\n\nThe methods available to customize trigger buttons will work to modify the $action instance inside the closure.\n\n`$action`### #Removing a default modal footer action button\n\nTo remove a default action, you may pass false to either modalSubmitAction() or modalCancelAction():\n\n`false``modalSubmitAction()``modalCancelAction()````\nAction::make('help')\n    ->modalContent(view('actions.help'))\n    ->modalSubmitAction(false)\n```",
                "level": 3
              },
              {
                "title": "### #Adding an extra modal action button to the footer",
                "content": "You may pass an array of extra actions to be rendered, between the default actions, in the footer of the modal using the extraModalFooterActions() method:\n\n`extraModalFooterActions()````\nAction::make('create')\n    ->form([\n        // ...\n    ])\n    // ...\n    ->extraModalFooterActions(fn (Action $action): array => [\n        $action->makeModalSubmitAction('createAnother', arguments: ['another' => true]),\n    ])\n```\n\n$action->makeModalSubmitAction() returns an action instance that can be customized using the methods available to customize trigger buttons.\n\n`$action->makeModalSubmitAction()`The second parameter of makeModalSubmitAction() allows you to pass an array of arguments that will be accessible inside the action’s action() closure as $arguments. These could be useful as flags to indicate that the action should behave differently based on the user’s decision:\n\n`makeModalSubmitAction()``action()``$arguments````\nAction::make('create')\n    ->form([\n        // ...\n    ])\n    // ...\n    ->extraModalFooterActions(fn (Action $action): array => [\n        $action->makeModalSubmitAction('createAnother', arguments: ['another' => true]),\n    ])\n    ->action(function (array $data, array $arguments): void {\n        // Create\n\n        if ($arguments['another'] ?? false) {\n            // Reset the form and don't close the modal\n        }\n    })\n```",
                "level": 4
              },
              {
                "title": "#### #Opening another modal from an extra footer action",
                "content": "You can nest actions within each other, allowing you to open a new modal from an extra footer action:\n\n```\nAction::make('edit')\n    // ...\n    ->extraModalFooterActions([\n        Action::make('delete')\n            ->requiresConfirmation()\n            ->action(function () {\n                // ...\n            }),\n    ])\n```\n\nNow, the edit modal will have a “Delete” button in the footer, which will open a confirmation modal when clicked. This action is completely independent of the edit action, and will not run the edit action when it is clicked.\n\n`edit``edit`In this example though, you probably want to cancel the edit action if the delete action is run. You can do this using the cancelParentActions() method:\n\n`edit``delete``cancelParentActions()````\nAction::make('delete')\n    ->requiresConfirmation()\n    ->action(function () {\n        // ...\n    })\n    ->cancelParentActions()\n```\n\nIf you have deep nesting with multiple parent actions, but you don’t want to cancel all of them, you can pass the name of the parent action you want to cancel, including its children, to cancelParentActions():\n\n`cancelParentActions()````\nAction::make('first')\n    ->requiresConfirmation()\n    ->action(function () {\n        // ...\n    })\n    ->extraModalFooterActions([\n        Action::make('second')\n            ->requiresConfirmation()\n            ->action(function () {\n                // ...\n            })\n            ->extraModalFooterActions([\n                Action::make('third')\n                    ->requiresConfirmation()\n                    ->action(function () {\n                        // ...\n                    })\n                    ->extraModalFooterActions([\n                        Action::make('fourth')\n                            ->requiresConfirmation()\n                            ->action(function () {\n                                // ...\n                            })\n                            ->cancelParentActions('second'),\n                    ]),\n            ]),\n    ])\n```\n\nIn this example, if the fourth action is run, the second action is canceled, but so is the third action since it is a child of second. The first action is not canceled, however, since it is the parent of second. The first action’s modal will remain open.\n\n`fourth``second``third``second``first``second``first`## #Closing the modal by clicking away\n\nBy default, when you click away from a modal, it will close itself. If you wish to disable this behavior for a specific action, you can use the closeModalByClickingAway(false) method:\n\n`closeModalByClickingAway(false)````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->closeModalByClickingAway(false)\n```\n\nIf you’d like to change the behavior for all modals in the application, you can do so by calling Modal::closedByClickingAway() inside a service provider or middleware:\n\n`Modal::closedByClickingAway()````\nuse Filament\\Support\\View\\Components\\Modal;\n\nModal::closedByClickingAway(false);\n```",
                "level": 5
              },
              {
                "title": "## #Closing the modal by escaping",
                "content": "By default, when you press escape on a modal, it will close itself. If you wish to disable this behavior for a specific action, you can use the closeModalByEscaping(false) method:\n\n`closeModalByEscaping(false)````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->closeModalByEscaping(false)\n```\n\nIf you’d like to change the behavior for all modals in the application, you can do so by calling Modal::closedByEscaping() inside a service provider or middleware:\n\n`Modal::closedByEscaping()````\nuse Filament\\Support\\View\\Components\\Modal;\n\nModal::closedByEscaping(false);\n```",
                "level": 3
              },
              {
                "title": "## #Hiding the modal close button",
                "content": "By default, modals have a close button in the top right corner. If you wish to hide the close button, you can use the modalCloseButton(false) method:\n\n`modalCloseButton(false)````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->modalCloseButton(false)\n```\n\nIf you’d like to hide the close button for all modals in the application, you can do so by calling Modal::closeButton(false) inside a service provider or middleware:\n\n`Modal::closeButton(false)````\nuse Filament\\Support\\View\\Components\\Modal;\n\nModal::closeButton(false);\n```",
                "level": 3
              },
              {
                "title": "## #Preventing the modal from autofocusing",
                "content": "By default, modals will autofocus on the first focusable element when opened. If you wish to disable this behavior, you can use the modalAutofocus(false) method:\n\n`modalAutofocus(false)````\nAction::make('updateAuthor')\n    ->form([\n        // ...\n    ])\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->modalAutofocus(false)\n```\n\nIf you’d like to disable autofocus for all modals in the application, you can do so by calling Modal::autofocus(false) inside a service provider or middleware:\n\n`Modal::autofocus(false)````\nuse Filament\\Support\\View\\Components\\Modal;\n\nModal::autofocus(false);\n```",
                "level": 3
              },
              {
                "title": "## #Optimizing modal configuration methods",
                "content": "When you use database queries or other heavy operations inside modal configuration methods like modalHeading(), they can be executed more than once. This is because Filament uses these methods to decide whether to render the modal or not, and also to render the modal’s content.\n\n`modalHeading()`To skip the check that Filament does to decide whether to render the modal, you can use the modal() method, which will inform Filament that the modal exists for this action and it does not need to check again:\n\n`modal()````\nAction::make('updateAuthor')\n    ->modal()\n```",
                "level": 3
              },
              {
                "title": "## #Conditionally hiding the modal",
                "content": "You may have a need to conditionally show a modal for confirmation reasons while falling back to the default action. This can be achieved using modalHidden():\n\n`modalHidden()````\nAction::make('create')\n    ->action(function (array $data): void {\n        // ...\n    })\n    ->modalHidden(fn (): bool => $this->role !== 'admin')\n    ->modalContent(view('filament.pages.actions.create'))\n```",
                "level": 3
              },
              {
                "title": "## #Adding extra attributes to the modal window",
                "content": "You may also pass extra HTML attributes to the modal window using extraModalWindowAttributes():\n\n`extraModalWindowAttributes()````\nAction::make('updateAuthor')\n    ->extraModalWindowAttributes(['class' => 'update-author-modal'])\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Confirmation modals",
              "Filling the form with existing data",
              "Using a wizard as a modal form",
              "Disabling all form fields",
              "Customizing the modal’s heading, description, and submit action label",
              "Adding an icon inside the modal",
              "Customizing the alignment of modal content",
              "Custom modal content",
              "Passing data to the custom modal content"
            ],
            "code_examples_count": 74,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "grouping": {
          "metadata": {
            "title": "Grouping",
            "url": "https://filamentphp.com/docs/3.x/actions/grouping",
            "section": "actions",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "adding-an-action-to-a-livewire-component": {
          "metadata": {
            "title": "Adding An Action To A Livewire Component",
            "url": "https://filamentphp.com/docs/3.x/actions/adding-an-action-to-a-livewire-component",
            "section": "actions",
            "word_count": 935,
            "character_count": 8039
          },
          "content": {
            "full_text": "\n# Adding an action to a Livewire component - Actions - Filament\n\nActions\n\n# Adding an action to a Livewire component\n\n## #Setting up the Livewire component\n\nFirst, generate a new Livewire component:\n\n```\nphp artisan make:livewire ManageProduct\n```\n\nThen, render your Livewire component on the page:\n\n```\n@livewire('manage-product')\n```\n\nAlternatively, you can use a full-page Livewire component:\n\n```\nuse App\\Livewire\\ManageProduct;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('products/{product}/manage', ManageProduct::class);\n```\n\nYou must use the InteractsWithActions and InteractsWithForms traits, and implement the HasActions and HasForms interfaces on your Livewire component class:\n\n`InteractsWithActions``InteractsWithForms``HasActions``HasForms````\nuse Filament\\Actions\\Concerns\\InteractsWithActions;\nuse Filament\\Actions\\Contracts\\HasActions;\nuse Filament\\Forms\\Concerns\\InteractsWithForms;\nuse Filament\\Forms\\Contracts\\HasForms;\nuse Livewire\\Component;\n\nclass ManagePost extends Component implements HasForms, HasActions\n{\n    use InteractsWithActions;\n    use InteractsWithForms;\n\n    // ...\n}\n```\n\n## #Adding the action\n\nAdd a method that returns your action. The method must share the exact same name as the action, or the name followed by Action:\n\n`Action````\nuse App\\Models\\Post;\nuse Filament\\Actions\\Action;\nuse Filament\\Actions\\Concerns\\InteractsWithActions;\nuse Filament\\Actions\\Contracts\\HasActions;\nuse Filament\\Forms\\Concerns\\InteractsWithForms;\nuse Filament\\Forms\\Contracts\\HasForms;\nuse Livewire\\Component;\n\nclass ManagePost extends Component implements HasForms, HasActions\n{\n    use InteractsWithActions;\n    use InteractsWithForms;\n\n    public Post $post;\n\n    public function deleteAction(): Action\n    {\n        return Action::make('delete')\n            ->requiresConfirmation()\n            ->action(fn () => $this->post->delete());\n    }\n    \n    // This method name also works, since the action name is `delete`:\n    // public function delete(): Action\n    \n    // This method name does not work, since the action name is `delete`, not `deletePost`:\n    // public function deletePost(): Action\n\n    // ...\n}\n```\n\nFinally, you need to render the action in your view. To do this, you can use {{ $this->deleteAction }}, where you replace deleteAction with the name of your action method:\n\n`{{ $this->deleteAction }}``deleteAction````\n<div>\n    {{ $this->deleteAction }}\n\n    <x-filament-actions::modals />\n</div>\n```\n\nYou also need <x-filament-actions::modals /> which injects the HTML required to render action modals. This only needs to be included within the Livewire component once, regardless of how many actions you have for that component.\n\n`<x-filament-actions::modals />`## #Passing action arguments\n\nSometimes, you may wish to pass arguments to your action. For example, if you’re rendering the same action multiple times in the same view, but each time for a different model, you could pass the model ID as an argument, and then retrieve it later. To do this, you can invoke the action in your view and pass in the arguments as an array:\n\n```\n<div>\n    @foreach ($posts as $post)\n        <h2>{{ $post->title }}</h2>\n\n        {{ ($this->deleteAction)(['post' => $post->id]) }}\n    @endforeach\n\n    <x-filament-actions::modals />\n</div>\n```\n\nNow, you can access the post ID in your action method:\n\n```\nuse App\\Models\\Post;\nuse Filament\\Actions\\Action;\n\npublic function deleteAction(): Action\n{\n    return Action::make('delete')\n        ->requiresConfirmation()\n        ->action(function (array $arguments) {\n            $post = Post::find($arguments['post']);\n\n            $post?->delete();\n        });\n}\n```\n\n## #Hiding actions in a Livewire view\n\nIf you use hidden() or visible() to control if an action is rendered, you should wrap the action in an @if check for isVisible():\n\n`hidden()``visible()``@if``isVisible()````\n<div>\n    @if ($this->deleteAction->isVisible())\n        {{ $this->deleteAction }}\n    @endif\n    \n    {{-- Or --}}\n    \n    @if (($this->deleteAction)(['post' => $post->id])->isVisible())\n        {{ ($this->deleteAction)(['post' => $post->id]) }}\n    @endif\n</div>\n```\n\nThe hidden() and visible() methods also control if the action is disabled(), so they are still useful to protect the action from being run if the user does not have permission. Encapsulating this logic in the hidden() or visible() of the action itself is good practice otherwise you need to define the condition in the view and in disabled().\n\n`hidden()``visible()``disabled()``hidden()``visible()``disabled()`You can also take advantage of this to hide any wrapping elements that may not need to be rendered if the action is hidden:\n\n```\n<div>\n    @if ($this->deleteAction->isVisible())\n        <div>\n            {{ $this->deleteAction }}\n        </div>\n    @endif\n</div>\n```\n\n## #Grouping actions in a Livewire view\n\nYou may group actions together into a dropdown menu by using the <x-filament-actions::group> Blade component, passing in the actions array as an attribute:\n\n`<x-filament-actions::group>``actions````\n<div>\n    <x-filament-actions::group :actions=\"[\n        $this->editAction,\n        $this->viewAction,\n        $this->deleteAction,\n    ]\" />\n\n    <x-filament-actions::modals />\n</div>\n```\n\nYou can also pass in any attributes to customize the appearance of the trigger button and dropdown:\n\n```\n<div>\n    <x-filament-actions::group\n        :actions=\"[\n            $this->editAction,\n            $this->viewAction,\n            $this->deleteAction,\n        ]\"\n        label=\"Actions\"\n        icon=\"heroicon-m-ellipsis-vertical\"\n        color=\"primary\"\n        size=\"md\"\n        tooltip=\"More actions\"\n        dropdown-placement=\"bottom-start\"\n    />\n\n    <x-filament-actions::modals />\n</div>\n```\n\n## #Chaining actions\n\nYou can chain multiple actions together, by calling the replaceMountedAction() method to replace the current action with another when it has finished:\n\n`replaceMountedAction()````\nuse App\\Models\\Post;\nuse Filament\\Actions\\Action;\n\npublic function editAction(): Action\n{\n    return Action::make('edit')\n        ->form([\n            // ...\n        ])\n        // ...\n        ->action(function (array $arguments) {\n            $post = Post::find($arguments['post']);\n\n            // ...\n\n            $this->replaceMountedAction('publish', $arguments);\n        });\n}\n\npublic function publishAction(): Action\n{\n    return Action::make('publish')\n        ->requiresConfirmation()\n        // ...\n        ->action(function (array $arguments) {\n            $post = Post::find($arguments['post']);\n\n            $post->publish();\n        });\n}\n```\n\nNow, when the first action is submitted, the second action will open in its place. The arguments that were originally passed to the first action get passed to the second action, so you can use them to persist data between requests.\n\nIf the first action is canceled, the second one is not opened. If the second action is canceled, the first one has already run and cannot be cancelled.\n\n## #Programmatically triggering actions\n\nSometimes you may need to trigger an action without the user clicking on the built-in trigger button, especially from JavaScript. Here is an example action which could be registered on a Livewire component:\n\n```\nuse Filament\\Actions\\Action;\n\npublic function testAction(): Action\n{\n    return Action::make('test')\n        ->requiresConfirmation()\n        ->action(function (array $arguments) {\n            dd('Test action called', $arguments);\n        });\n}\n```\n\nYou can trigger that action from a click in your HTML using the wire:click attribute, calling the mountAction() method and optionally passing in any arguments that you want to be available:\n\n`wire:click``mountAction()````\n<button wire:click=\"mountAction('test', { id: 12345 })\">\n    Button\n</button>\n```\n\nTo trigger that action from JavaScript, you can use the $wire utility, passing in the same arguments:\n\n`$wire````\n$wire.mountAction('test', { id: 12345 })\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Adding an action to a Livewire component - Actions - Filament",
                "content": "Actions",
                "level": 1
              },
              {
                "title": "# Adding an action to a Livewire component",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Setting up the Livewire component",
                "content": "First, generate a new Livewire component:\n\n```\nphp artisan make:livewire ManageProduct\n```\n\nThen, render your Livewire component on the page:\n\n```\n@livewire('manage-product')\n```\n\nAlternatively, you can use a full-page Livewire component:\n\n```\nuse App\\Livewire\\ManageProduct;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('products/{product}/manage', ManageProduct::class);\n```\n\nYou must use the InteractsWithActions and InteractsWithForms traits, and implement the HasActions and HasForms interfaces on your Livewire component class:\n\n`InteractsWithActions``InteractsWithForms``HasActions``HasForms````\nuse Filament\\Actions\\Concerns\\InteractsWithActions;\nuse Filament\\Actions\\Contracts\\HasActions;\nuse Filament\\Forms\\Concerns\\InteractsWithForms;\nuse Filament\\Forms\\Contracts\\HasForms;\nuse Livewire\\Component;\n\nclass ManagePost extends Component implements HasForms, HasActions\n{\n    use InteractsWithActions;\n    use InteractsWithForms;\n\n    // ...\n}\n```",
                "level": 3
              },
              {
                "title": "## #Adding the action",
                "content": "Add a method that returns your action. The method must share the exact same name as the action, or the name followed by Action:\n\n`Action````\nuse App\\Models\\Post;\nuse Filament\\Actions\\Action;\nuse Filament\\Actions\\Concerns\\InteractsWithActions;\nuse Filament\\Actions\\Contracts\\HasActions;\nuse Filament\\Forms\\Concerns\\InteractsWithForms;\nuse Filament\\Forms\\Contracts\\HasForms;\nuse Livewire\\Component;\n\nclass ManagePost extends Component implements HasForms, HasActions\n{\n    use InteractsWithActions;\n    use InteractsWithForms;\n\n    public Post $post;\n\n    public function deleteAction(): Action\n    {\n        return Action::make('delete')\n            ->requiresConfirmation()\n            ->action(fn () => $this->post->delete());\n    }\n    \n    // This method name also works, since the action name is `delete`:\n    // public function delete(): Action\n    \n    // This method name does not work, since the action name is `delete`, not `deletePost`:\n    // public function deletePost(): Action\n\n    // ...\n}\n```\n\nFinally, you need to render the action in your view. To do this, you can use {{ $this->deleteAction }}, where you replace deleteAction with the name of your action method:\n\n`{{ $this->deleteAction }}``deleteAction````\n<div>\n    {{ $this->deleteAction }}\n\n    <x-filament-actions::modals />\n</div>\n```\n\nYou also need <x-filament-actions::modals /> which injects the HTML required to render action modals. This only needs to be included within the Livewire component once, regardless of how many actions you have for that component.\n\n`<x-filament-actions::modals />`## #Passing action arguments\n\nSometimes, you may wish to pass arguments to your action. For example, if you’re rendering the same action multiple times in the same view, but each time for a different model, you could pass the model ID as an argument, and then retrieve it later. To do this, you can invoke the action in your view and pass in the arguments as an array:\n\n```\n<div>\n    @foreach ($posts as $post)\n        <h2>{{ $post->title }}</h2>\n\n        {{ ($this->deleteAction)(['post' => $post->id]) }}\n    @endforeach\n\n    <x-filament-actions::modals />\n</div>\n```\n\nNow, you can access the post ID in your action method:\n\n```\nuse App\\Models\\Post;\nuse Filament\\Actions\\Action;\n\npublic function deleteAction(): Action\n{\n    return Action::make('delete')\n        ->requiresConfirmation()\n        ->action(function (array $arguments) {\n            $post = Post::find($arguments['post']);\n\n            $post?->delete();\n        });\n}\n```",
                "level": 3
              },
              {
                "title": "## #Hiding actions in a Livewire view",
                "content": "If you use hidden() or visible() to control if an action is rendered, you should wrap the action in an @if check for isVisible():\n\n`hidden()``visible()``@if``isVisible()````\n<div>\n    @if ($this->deleteAction->isVisible())\n        {{ $this->deleteAction }}\n    @endif\n    \n    {{-- Or --}}\n    \n    @if (($this->deleteAction)(['post' => $post->id])->isVisible())\n        {{ ($this->deleteAction)(['post' => $post->id]) }}\n    @endif\n</div>\n```\n\nThe hidden() and visible() methods also control if the action is disabled(), so they are still useful to protect the action from being run if the user does not have permission. Encapsulating this logic in the hidden() or visible() of the action itself is good practice otherwise you need to define the condition in the view and in disabled().\n\n`hidden()``visible()``disabled()``hidden()``visible()``disabled()`You can also take advantage of this to hide any wrapping elements that may not need to be rendered if the action is hidden:\n\n```\n<div>\n    @if ($this->deleteAction->isVisible())\n        <div>\n            {{ $this->deleteAction }}\n        </div>\n    @endif\n</div>\n```",
                "level": 3
              },
              {
                "title": "## #Grouping actions in a Livewire view",
                "content": "You may group actions together into a dropdown menu by using the <x-filament-actions::group> Blade component, passing in the actions array as an attribute:\n\n`<x-filament-actions::group>``actions````\n<div>\n    <x-filament-actions::group :actions=\"[\n        $this->editAction,\n        $this->viewAction,\n        $this->deleteAction,\n    ]\" />\n\n    <x-filament-actions::modals />\n</div>\n```\n\nYou can also pass in any attributes to customize the appearance of the trigger button and dropdown:\n\n```\n<div>\n    <x-filament-actions::group\n        :actions=\"[\n            $this->editAction,\n            $this->viewAction,\n            $this->deleteAction,\n        ]\"\n        label=\"Actions\"\n        icon=\"heroicon-m-ellipsis-vertical\"\n        color=\"primary\"\n        size=\"md\"\n        tooltip=\"More actions\"\n        dropdown-placement=\"bottom-start\"\n    />\n\n    <x-filament-actions::modals />\n</div>\n```",
                "level": 3
              },
              {
                "title": "## #Chaining actions",
                "content": "You can chain multiple actions together, by calling the replaceMountedAction() method to replace the current action with another when it has finished:\n\n`replaceMountedAction()````\nuse App\\Models\\Post;\nuse Filament\\Actions\\Action;\n\npublic function editAction(): Action\n{\n    return Action::make('edit')\n        ->form([\n            // ...\n        ])\n        // ...\n        ->action(function (array $arguments) {\n            $post = Post::find($arguments['post']);\n\n            // ...\n\n            $this->replaceMountedAction('publish', $arguments);\n        });\n}\n\npublic function publishAction(): Action\n{\n    return Action::make('publish')\n        ->requiresConfirmation()\n        // ...\n        ->action(function (array $arguments) {\n            $post = Post::find($arguments['post']);\n\n            $post->publish();\n        });\n}\n```\n\nNow, when the first action is submitted, the second action will open in its place. The arguments that were originally passed to the first action get passed to the second action, so you can use them to persist data between requests.\n\nIf the first action is canceled, the second one is not opened. If the second action is canceled, the first one has already run and cannot be cancelled.",
                "level": 3
              },
              {
                "title": "## #Programmatically triggering actions",
                "content": "Sometimes you may need to trigger an action without the user clicking on the built-in trigger button, especially from JavaScript. Here is an example action which could be registered on a Livewire component:\n\n```\nuse Filament\\Actions\\Action;\n\npublic function testAction(): Action\n{\n    return Action::make('test')\n        ->requiresConfirmation()\n        ->action(function (array $arguments) {\n            dd('Test action called', $arguments);\n        });\n}\n```\n\nYou can trigger that action from a click in your HTML using the wire:click attribute, calling the mountAction() method and optionally passing in any arguments that you want to be available:\n\n`wire:click``mountAction()````\n<button wire:click=\"mountAction('test', { id: 12345 })\">\n    Button\n</button>\n```\n\nTo trigger that action from JavaScript, you can use the $wire utility, passing in the same arguments:\n\n`$wire````\n$wire.mountAction('test', { id: 12345 })\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Setting up the Livewire component",
              "Adding the action",
              "Hiding actions in a Livewire view",
              "Grouping actions in a Livewire view",
              "Chaining actions",
              "Programmatically triggering actions"
            ],
            "code_examples_count": 32,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "prebuilt-actions": {
          "metadata": {
            "title": "Prebuilt Actions",
            "url": "https://filamentphp.com/docs/3.x/actions/prebuilt-actions",
            "section": "actions",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "advanced": {
          "metadata": {
            "title": "Advanced",
            "url": "https://filamentphp.com/docs/3.x/actions/advanced",
            "section": "actions",
            "word_count": 315,
            "character_count": 2181
          },
          "content": {
            "full_text": "\n# Advanced actions - Actions - Filament\n\nActions\n\n# Advanced actions\n\n## #Action utility injection\n\nThe vast majority of methods used to configure actions accept functions as parameters instead of hardcoded values:\n\n```\nAction::make('edit')\n    ->label('Edit post')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n```\n\nThis alone unlocks many customization possibilities.\n\nThe package is also able to inject many utilities to use inside these functions, as parameters. All customization methods that accept functions as arguments can inject utilities.\n\nThese injected utilities require specific parameter names to be used. Otherwise, Filament doesn’t know what to inject.\n\n### #Injecting the current modal form data\n\nIf you wish to access the current modal form data, define a $data parameter:\n\n`$data````\nfunction (array $data) {\n    // ...\n}\n```\n\nBe aware that this will be empty if the modal has not been submitted yet.\n\n### #Injecting the current arguments\n\nIf you wish to access the current arguments that have been passed to the action, define an $arguments parameter:\n\n`$arguments````\nfunction (array $arguments) {\n    // ...\n}\n```\n\n### #Injecting the current Livewire component instance\n\nIf you wish to access the current Livewire component instance that the action belongs to, define a $livewire parameter:\n\n`$livewire````\nuse Livewire\\Component;\n\nfunction (Component $livewire) {\n    // ...\n}\n```\n\n### #Injecting the current action instance\n\nIf you wish to access the current action instance, define a $action parameter:\n\n`$action````\nfunction (Action $action) {\n    // ...\n}\n```\n\n### #Injecting multiple utilities\n\nThe parameters are injected dynamically using reflection, so you are able to combine multiple parameters in any order:\n\n```\nuse Livewire\\Component;\n\nfunction (array $arguments, Component $livewire) {\n    // ...\n}\n```\n\n### #Injecting dependencies from Laravel’s container\n\nYou may inject anything from Laravel’s container like normal, alongside utilities:\n\n```\nuse Illuminate\\Http\\Request;\n\nfunction (Request $request, array $arguments) {\n    // ...\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Advanced actions - Actions - Filament",
                "content": "Actions",
                "level": 1
              },
              {
                "title": "# Advanced actions",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Action utility injection",
                "content": "The vast majority of methods used to configure actions accept functions as parameters instead of hardcoded values:\n\n```\nAction::make('edit')\n    ->label('Edit post')\n    ->url(fn (): string => route('posts.edit', ['post' => $this->post]))\n```\n\nThis alone unlocks many customization possibilities.\n\nThe package is also able to inject many utilities to use inside these functions, as parameters. All customization methods that accept functions as arguments can inject utilities.\n\nThese injected utilities require specific parameter names to be used. Otherwise, Filament doesn’t know what to inject.",
                "level": 3
              },
              {
                "title": "### #Injecting the current modal form data",
                "content": "If you wish to access the current modal form data, define a $data parameter:\n\n`$data````\nfunction (array $data) {\n    // ...\n}\n```\n\nBe aware that this will be empty if the modal has not been submitted yet.",
                "level": 4
              },
              {
                "title": "### #Injecting the current arguments",
                "content": "If you wish to access the current arguments that have been passed to the action, define an $arguments parameter:\n\n`$arguments````\nfunction (array $arguments) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting the current Livewire component instance",
                "content": "If you wish to access the current Livewire component instance that the action belongs to, define a $livewire parameter:\n\n`$livewire````\nuse Livewire\\Component;\n\nfunction (Component $livewire) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting the current action instance",
                "content": "If you wish to access the current action instance, define a $action parameter:\n\n`$action````\nfunction (Action $action) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting multiple utilities",
                "content": "The parameters are injected dynamically using reflection, so you are able to combine multiple parameters in any order:\n\n```\nuse Livewire\\Component;\n\nfunction (array $arguments, Component $livewire) {\n    // ...\n}\n```",
                "level": 4
              },
              {
                "title": "### #Injecting dependencies from Laravel’s container",
                "content": "You may inject anything from Laravel’s container like normal, alongside utilities:\n\n```\nuse Illuminate\\Http\\Request;\n\nfunction (Request $request, array $arguments) {\n    // ...\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Action utility injection",
              "Injecting the current modal form data",
              "Injecting the current arguments",
              "Injecting the current Livewire component instance",
              "Injecting the current action instance",
              "Injecting multiple utilities",
              "Injecting dependencies from Laravel’s container"
            ],
            "code_examples_count": 14,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "testing": {
          "metadata": {
            "title": "Testing",
            "url": "https://filamentphp.com/docs/3.x/actions/testing",
            "section": "actions",
            "word_count": 865,
            "character_count": 9090
          },
          "content": {
            "full_text": "\n# Testing - Actions - Filament\n\nActions\n\n# Testing\n\n## #Overview\n\nAll examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\nSince all actions are mounted to a Livewire component, we’re just using Livewire testing helpers everywhere. If you’ve never tested Livewire components before, please read this guide from the Livewire docs.\n\n## #Getting started\n\nYou can call an action by passing its name or class to callAction():\n\n`callAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callAction('send');\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue();\n});\n```\n\nTo pass an array of data into an action, use the data parameter:\n\n`data````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callAction('send', data: [\n            'email' => $email = fake()->email(),\n        ])\n        ->assertHasNoActionErrors();\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($email);\n});\n```\n\nIf you ever need to only set an action’s data without immediately calling it, you can use setActionData():\n\n`setActionData()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountAction('send')\n        ->setActionData([\n            'email' => $email = fake()->email(),\n        ])\n});\n```\n\n## #Execution\n\nTo check if an action has been halted, you can use assertActionHalted():\n\n`assertActionHalted()````\nuse function Pest\\Livewire\\livewire;\n\nit('stops sending if invoice has no email address', function () {\n    $invoice = Invoice::factory(['email' => null])->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callAction('send')\n        ->assertActionHalted('send');\n});\n```\n\n## #Modal content\n\nTo assert the content of a modal, you should first mount the action (rather than call it which closes the modal). You can then use Livewire assertions such as assertSee() to assert the modal contains the content that you expect it to:\n\n`assertSee()````\nuse function Pest\\Livewire\\livewire;\n\nit('confirms the target address before sending', function () {\n    $invoice = Invoice::factory()->create();\n    $recipientEmail = $invoice->company->primaryContact->email;\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountAction('send')\n        ->assertSee($recipientEmail);\n});\n```\n\n## #Errors\n\nassertHasNoActionErrors() is used to assert that no validation errors occurred when submitting the action form.\n\n`assertHasNoActionErrors()`To check if a validation error has occurred with the data, use assertHasActionErrors(), similar to assertHasErrors() in Livewire:\n\n`assertHasActionErrors()``assertHasErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate invoice recipient email', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callAction('send', data: [\n            'email' => Str::random(),\n        ])\n        ->assertHasActionErrors(['email' => ['email']]);\n});\n```\n\nTo check if an action is pre-filled with data, you can use the assertActionDataSet() method:\n\n`assertActionDataSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices to the primary contact by default', function () {\n    $invoice = Invoice::factory()->create();\n    $recipientEmail = $invoice->company->primaryContact->email;\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountAction('send')\n        ->assertActionDataSet([\n            'email' => $recipientEmail,\n        ])\n        ->callMountedAction()\n        ->assertHasNoActionErrors();\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($recipientEmail);\n});\n```\n\n## #Action state\n\nTo ensure that an action exists or doesn’t, you can use the assertActionExists() or  assertActionDoesNotExist() method:\n\n`assertActionExists()``assertActionDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send but not unsend invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionExists('send')\n        ->assertActionDoesNotExist('unsend');\n});\n```\n\nTo ensure an action is hidden or visible for a user, you can use the assertActionHidden() or assertActionVisible() methods:\n\n`assertActionHidden()``assertActionVisible()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionHidden('send')\n        ->assertActionVisible('print');\n});\n```\n\nTo ensure an action is enabled or disabled for a user, you can use the assertActionEnabled() or assertActionDisabled() methods:\n\n`assertActionEnabled()``assertActionDisabled()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print a sent invoice', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionDisabled('send')\n        ->assertActionEnabled('print');\n});\n```\n\nTo ensure sets of actions exist in the correct order, you can use assertActionsExistInOrder():\n\n`assertActionsExistInOrder()````\nuse function Pest\\Livewire\\livewire;\n\nit('can have actions in order', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionsExistInOrder(['send', 'export']);\n});\n```\n\nTo check if an action is hidden to a user, you can use the assertActionHidden() method:\n\n`assertActionHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionHidden('send');\n});\n```\n\n## #Button appearance\n\nTo ensure an action has the correct label, you can use assertActionHasLabel() and assertActionDoesNotHaveLabel():\n\n`assertActionHasLabel()``assertActionDoesNotHaveLabel()````\nuse function Pest\\Livewire\\livewire;\n\nit('send action has correct label', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionHasLabel('send', 'Email Invoice')\n        ->assertActionDoesNotHaveLabel('send', 'Send');\n});\n```\n\nTo ensure an action’s button is showing the correct icon, you can use assertActionHasIcon() or assertActionDoesNotHaveIcon():\n\n`assertActionHasIcon()``assertActionDoesNotHaveIcon()````\nuse function Pest\\Livewire\\livewire;\n\nit('when enabled the send button has correct icon', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionEnabled('send')\n        ->assertActionHasIcon('send', 'envelope-open')\n        ->assertActionDoesNotHaveIcon('send', 'envelope');\n});\n```\n\nTo ensure that an action’s button is displaying the right color, you can use assertActionHasColor() or assertActionDoesNotHaveColor():\n\n`assertActionHasColor()``assertActionDoesNotHaveColor()````\nuse function Pest\\Livewire\\livewire;\n\nit('actions display proper colors', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionHasColor('delete', 'danger')\n        ->assertActionDoesNotHaveColor('print', 'danger');\n});\n```\n\n## #URL\n\nTo ensure an action has the correct URL, you can use assertActionHasUrl(), assertActionDoesNotHaveUrl(), assertActionShouldOpenUrlInNewTab(), and assertActionShouldNotOpenUrlInNewTab():\n\n`assertActionHasUrl()``assertActionDoesNotHaveUrl()``assertActionShouldOpenUrlInNewTab()``assertActionShouldNotOpenUrlInNewTab()````\nuse function Pest\\Livewire\\livewire;\n\nit('links to the correct Filament sites', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionHasUrl('filament', 'https://filamentphp.com/')\n        ->assertActionDoesNotHaveUrl('filament', 'https://github.com/filamentphp/filament')\n        ->assertActionShouldOpenUrlInNewTab('filament')\n        ->assertActionShouldNotOpenUrlInNewTab('github');\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Testing - Actions - Filament",
                "content": "Actions",
                "level": 1
              },
              {
                "title": "# Testing",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "All examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\nSince all actions are mounted to a Livewire component, we’re just using Livewire testing helpers everywhere. If you’ve never tested Livewire components before, please read this guide from the Livewire docs.",
                "level": 3
              },
              {
                "title": "## #Getting started",
                "content": "You can call an action by passing its name or class to callAction():\n\n`callAction()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callAction('send');\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue();\n});\n```\n\nTo pass an array of data into an action, use the data parameter:\n\n`data````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callAction('send', data: [\n            'email' => $email = fake()->email(),\n        ])\n        ->assertHasNoActionErrors();\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($email);\n});\n```\n\nIf you ever need to only set an action’s data without immediately calling it, you can use setActionData():\n\n`setActionData()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountAction('send')\n        ->setActionData([\n            'email' => $email = fake()->email(),\n        ])\n});\n```",
                "level": 3
              },
              {
                "title": "## #Execution",
                "content": "To check if an action has been halted, you can use assertActionHalted():\n\n`assertActionHalted()````\nuse function Pest\\Livewire\\livewire;\n\nit('stops sending if invoice has no email address', function () {\n    $invoice = Invoice::factory(['email' => null])->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callAction('send')\n        ->assertActionHalted('send');\n});\n```",
                "level": 3
              },
              {
                "title": "## #Modal content",
                "content": "To assert the content of a modal, you should first mount the action (rather than call it which closes the modal). You can then use Livewire assertions such as assertSee() to assert the modal contains the content that you expect it to:\n\n`assertSee()````\nuse function Pest\\Livewire\\livewire;\n\nit('confirms the target address before sending', function () {\n    $invoice = Invoice::factory()->create();\n    $recipientEmail = $invoice->company->primaryContact->email;\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountAction('send')\n        ->assertSee($recipientEmail);\n});\n```",
                "level": 3
              },
              {
                "title": "## #Errors",
                "content": "assertHasNoActionErrors() is used to assert that no validation errors occurred when submitting the action form.\n\n`assertHasNoActionErrors()`To check if a validation error has occurred with the data, use assertHasActionErrors(), similar to assertHasErrors() in Livewire:\n\n`assertHasActionErrors()``assertHasErrors()````\nuse function Pest\\Livewire\\livewire;\n\nit('can validate invoice recipient email', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->callAction('send', data: [\n            'email' => Str::random(),\n        ])\n        ->assertHasActionErrors(['email' => ['email']]);\n});\n```\n\nTo check if an action is pre-filled with data, you can use the assertActionDataSet() method:\n\n`assertActionDataSet()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send invoices to the primary contact by default', function () {\n    $invoice = Invoice::factory()->create();\n    $recipientEmail = $invoice->company->primaryContact->email;\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->mountAction('send')\n        ->assertActionDataSet([\n            'email' => $recipientEmail,\n        ])\n        ->callMountedAction()\n        ->assertHasNoActionErrors();\n\n    expect($invoice->refresh())\n        ->isSent()->toBeTrue()\n        ->recipient_email->toBe($recipientEmail);\n});\n```",
                "level": 3
              },
              {
                "title": "## #Action state",
                "content": "To ensure that an action exists or doesn’t, you can use the assertActionExists() or  assertActionDoesNotExist() method:\n\n`assertActionExists()``assertActionDoesNotExist()````\nuse function Pest\\Livewire\\livewire;\n\nit('can send but not unsend invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionExists('send')\n        ->assertActionDoesNotExist('unsend');\n});\n```\n\nTo ensure an action is hidden or visible for a user, you can use the assertActionHidden() or assertActionVisible() methods:\n\n`assertActionHidden()``assertActionVisible()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionHidden('send')\n        ->assertActionVisible('print');\n});\n```\n\nTo ensure an action is enabled or disabled for a user, you can use the assertActionEnabled() or assertActionDisabled() methods:\n\n`assertActionEnabled()``assertActionDisabled()````\nuse function Pest\\Livewire\\livewire;\n\nit('can only print a sent invoice', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionDisabled('send')\n        ->assertActionEnabled('print');\n});\n```\n\nTo ensure sets of actions exist in the correct order, you can use assertActionsExistInOrder():\n\n`assertActionsExistInOrder()````\nuse function Pest\\Livewire\\livewire;\n\nit('can have actions in order', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionsExistInOrder(['send', 'export']);\n});\n```\n\nTo check if an action is hidden to a user, you can use the assertActionHidden() method:\n\n`assertActionHidden()````\nuse function Pest\\Livewire\\livewire;\n\nit('can not send invoices', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionHidden('send');\n});\n```",
                "level": 3
              },
              {
                "title": "## #Button appearance",
                "content": "To ensure an action has the correct label, you can use assertActionHasLabel() and assertActionDoesNotHaveLabel():\n\n`assertActionHasLabel()``assertActionDoesNotHaveLabel()````\nuse function Pest\\Livewire\\livewire;\n\nit('send action has correct label', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionHasLabel('send', 'Email Invoice')\n        ->assertActionDoesNotHaveLabel('send', 'Send');\n});\n```\n\nTo ensure an action’s button is showing the correct icon, you can use assertActionHasIcon() or assertActionDoesNotHaveIcon():\n\n`assertActionHasIcon()``assertActionDoesNotHaveIcon()````\nuse function Pest\\Livewire\\livewire;\n\nit('when enabled the send button has correct icon', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionEnabled('send')\n        ->assertActionHasIcon('send', 'envelope-open')\n        ->assertActionDoesNotHaveIcon('send', 'envelope');\n});\n```\n\nTo ensure that an action’s button is displaying the right color, you can use assertActionHasColor() or assertActionDoesNotHaveColor():\n\n`assertActionHasColor()``assertActionDoesNotHaveColor()````\nuse function Pest\\Livewire\\livewire;\n\nit('actions display proper colors', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionHasColor('delete', 'danger')\n        ->assertActionDoesNotHaveColor('print', 'danger');\n});\n```",
                "level": 3
              },
              {
                "title": "## #URL",
                "content": "To ensure an action has the correct URL, you can use assertActionHasUrl(), assertActionDoesNotHaveUrl(), assertActionShouldOpenUrlInNewTab(), and assertActionShouldNotOpenUrlInNewTab():\n\n`assertActionHasUrl()``assertActionDoesNotHaveUrl()``assertActionShouldOpenUrlInNewTab()``assertActionShouldNotOpenUrlInNewTab()````\nuse function Pest\\Livewire\\livewire;\n\nit('links to the correct Filament sites', function () {\n    $invoice = Invoice::factory()->create();\n\n    livewire(EditInvoice::class, [\n        'invoice' => $invoice,\n    ])\n        ->assertActionHasUrl('filament', 'https://filamentphp.com/')\n        ->assertActionDoesNotHaveUrl('filament', 'https://github.com/filamentphp/filament')\n        ->assertActionShouldOpenUrlInNewTab('filament')\n        ->assertActionShouldNotOpenUrlInNewTab('github');\n});\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Getting started",
              "Execution",
              "Modal content",
              "Errors",
              "Action state",
              "Button appearance"
            ],
            "code_examples_count": 32,
            "has_installation_info": true,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "upgrading": {
          "metadata": {
            "title": "Upgrading",
            "url": "https://filamentphp.com/docs/3.x/actions/upgrading",
            "section": "actions",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        }
      }
    },
    "notifications": {
      "section_info": {
        "name": "notifications",
        "page_count": 7,
        "description": "Toast notifications and database notification system"
      },
      "pages": {
        "installation": {
          "metadata": {
            "title": "Installation",
            "url": "https://filamentphp.com/docs/3.x/notifications/installation",
            "section": "notifications",
            "word_count": 674,
            "character_count": 5688
          },
          "content": {
            "full_text": "\n# Installation - Notifications - Filament\n\nNotifications\n\n# Installation\n\nThe Notifications package is pre-installed with the Panel Builder. This guide is for using the Notifications package in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)\n\nRequire the Notifications package using Composer:\n\n```\ncomposer require filament/notifications:\"^3.3\" -W\n```\n\n## #New Laravel projects\n\nTo quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --notifications\n\nnpm install\n\nnpm run dev\n```\n\n## #Existing Laravel projects\n\nRun the following command to install the Notifications package assets:\n\n```\nphp artisan filament:install --notifications\n```\n\n### #Installing Tailwind CSS\n\n> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```\n\n### #Configuring styles\n\nAdd Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```\n\n### #Automatically refreshing the browser\n\nYou may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```\n\n### #Compiling assets\n\nCompile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @livewire('notifications')\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```\n\n## #Publishing configuration\n\nYou can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Notifications - Filament",
                "content": "Notifications",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "The Notifications package is pre-installed with the Panel Builder. This guide is for using the Notifications package in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)\n\nRequire the Notifications package using Composer:\n\n```\ncomposer require filament/notifications:\"^3.3\" -W\n```",
                "level": 3
              },
              {
                "title": "## #New Laravel projects",
                "content": "To quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --notifications\n\nnpm install\n\nnpm run dev\n```",
                "level": 3
              },
              {
                "title": "## #Existing Laravel projects",
                "content": "Run the following command to install the Notifications package assets:\n\n```\nphp artisan filament:install --notifications\n```",
                "level": 3
              },
              {
                "title": "### #Installing Tailwind CSS",
                "content": "> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```",
                "level": 4
              },
              {
                "title": "### #Configuring styles",
                "content": "Add Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```",
                "level": 4
              },
              {
                "title": "### #Automatically refreshing the browser",
                "content": "You may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```",
                "level": 4
              },
              {
                "title": "### #Compiling assets",
                "content": "Compile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @livewire('notifications')\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```",
                "level": 4
              },
              {
                "title": "## #Publishing configuration",
                "content": "You can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "New Laravel projects",
              "Existing Laravel projects",
              "Installing Tailwind CSS",
              "Configuring styles",
              "Automatically refreshing the browser",
              "Compiling assets",
              "Publishing configuration",
              "Upgrading"
            ],
            "code_examples_count": 24,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "sending-notifications": {
          "metadata": {
            "title": "Sending Notifications",
            "url": "https://filamentphp.com/docs/3.x/notifications/sending-notifications",
            "section": "notifications",
            "word_count": 1275,
            "character_count": 12577
          },
          "content": {
            "full_text": "\n# Sending notifications - Notifications - Filament\n\nNotifications\n\n# Sending notifications\n\n## #Overview\n\n> To start, make sure the package is installed - @livewire('notifications') should be in your Blade layout somewhere.\n\nTo start, make sure the package is installed - @livewire('notifications') should be in your Blade layout somewhere.\n\n`@livewire('notifications')`Notifications are sent using a Notification object that’s constructed through a fluent API. Calling the send() method on the Notification object will dispatch the notification and display it in your application. As the session is used to flash notifications, they can be sent from anywhere in your code, including JavaScript, not just Livewire components.\n\n`Notification``send()``Notification````\n<?php\n\nnamespace App\\Livewire;\n\nuse Filament\\Notifications\\Notification;\nuse Livewire\\Component;\n\nclass EditPost extends Component\n{\n    public function save(): void\n    {\n        // ...\n\n        Notification::make()\n            ->title('Saved successfully')\n            ->success()\n            ->send();\n    }\n}\n```\n\n## #Setting a title\n\nThe main message of the notification is shown in the title. You can set the title as follows:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->send();\n```\n\nThe title text can contain basic, safe HTML elements. To generate safe HTML with Markdown, you can use the Str::markdown() helper: title(Str::markdown('Saved **successfully**'))\n\n`Str::markdown()``title(Str::markdown('Saved **successfully**'))`Or with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .send()\n```\n\n## #Setting an icon\n\nOptionally, a notification can have an icon that’s displayed in front of its content. You may also set a color for the icon, which is gray by default:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->icon('heroicon-o-document-text')\n    ->iconColor('success')\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .icon('heroicon-o-document-text')\n    .iconColor('success')\n    .send()\n```\n\nNotifications often have a status like success, warning, danger or info. Instead of manually setting the corresponding icons and colors, there’s a status() method which you can pass the status. You may also use the dedicated success(), warning(), danger() and info() methods instead. So, cleaning up the above example would look like this:\n\n`success``warning``danger``info``status()``success()``warning()``danger()``info()````\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .send()\n```\n\n## #Setting a background color\n\nNotifications have no background color by default. You may want to provide additional context to your notification by setting a color as follows:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->color('success')\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .color('success')\n    .send()\n```\n\n## #Setting a duration\n\nBy default, notifications are shown for 6 seconds before they’re automatically closed. You may specify a custom duration value in milliseconds as follows:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->duration(5000)\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .duration(5000)\n    .send()\n```\n\nIf you prefer setting a duration in seconds instead of milliseconds, you can do so:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->seconds(5)\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .seconds(5)\n    .send()\n```\n\nYou might want some notifications to not automatically close and require the user to close them manually. This can be achieved by making the notification persistent:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->persistent()\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .persistent()\n    .send()\n```\n\n## #Setting body text\n\nAdditional notification text can be shown in the body():\n\n`body()````\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->send();\n```\n\nThe body text can contain basic, safe HTML elements. To generate safe HTML with Markdown, you can use the Str::markdown() helper: body(Str::markdown('Changes to the **post** have been saved.'))\n\n`Str::markdown()``body(Str::markdown('Changes to the **post** have been saved.'))`Or with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .body('Changes to the post have been saved.')\n    .send()\n```\n\n## #Adding actions to notifications\n\nNotifications support Actions, which are buttons that render below the content of the notification. They can open a URL or dispatch a Livewire event. Actions can be defined as follows:\n\n```\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('view')\n            ->button(),\n        Action::make('undo')\n            ->color('gray'),\n    ])\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .body('Changes to the post have been saved.')\n    .actions([\n        new FilamentNotificationAction('view')\n            .button(),\n        new FilamentNotificationAction('undo')\n            .color('gray'),\n    ])\n    .send()\n```\n\nYou can learn more about how to style action buttons here.\n\n### #Opening URLs from notification actions\n\nYou can open a URL, optionally in a new tab, when clicking on an action:\n\n```\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('view')\n            ->button()\n            ->url(route('posts.show', $post), shouldOpenInNewTab: true),\n        Action::make('undo')\n            ->color('gray'),\n    ])\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .body('Changes to the post have been saved.')\n    .actions([\n        new FilamentNotificationAction('view')\n            .button()\n            .url('/view')\n            .openUrlInNewTab(),\n        new FilamentNotificationAction('undo')\n            .color('gray'),\n    ])\n    .send()\n```\n\n### #Dispatching Livewire events from notification actions\n\nSometimes you want to execute additional code when a notification action is clicked. This can be achieved by setting a Livewire event which should be dispatched on clicking the action. You may optionally pass an array of data, which will be available as parameters in the event listener on your Livewire component:\n\n```\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('view')\n            ->button()\n            ->url(route('posts.show', $post), shouldOpenInNewTab: true),\n        Action::make('undo')\n            ->color('gray')\n            ->dispatch('undoEditingPost', [$post->id]),\n    ])\n    ->send();\n```\n\nYou can also dispatchSelf and dispatchTo:\n\n`dispatchSelf``dispatchTo````\nAction::make('undo')\n    ->color('gray')\n    ->dispatchSelf('undoEditingPost', [$post->id])\n\nAction::make('undo')\n    ->color('gray')\n    ->dispatchTo('another_component', 'undoEditingPost', [$post->id])\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .body('Changes to the post have been saved.')\n    .actions([\n        new FilamentNotificationAction('view')\n            .button()\n            .url('/view')\n            .openUrlInNewTab(),\n        new FilamentNotificationAction('undo')\n            .color('gray')\n            .dispatch('undoEditingPost'),\n    ])\n    .send()\n```\n\nSimilarly, dispatchSelf and dispatchTo are also available:\n\n`dispatchSelf``dispatchTo````\nnew FilamentNotificationAction('undo')\n    .color('gray')\n    .dispatchSelf('undoEditingPost')\n\nnew FilamentNotificationAction('undo')\n    .color('gray')\n    .dispatchTo('another_component', 'undoEditingPost')\n```\n\n### #Closing notifications from actions\n\nAfter opening a URL or dispatching an event from your action, you may want to close the notification right away:\n\n```\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('view')\n            ->button()\n            ->url(route('posts.show', $post), shouldOpenInNewTab: true),\n        Action::make('undo')\n            ->color('gray')\n            ->dispatch('undoEditingPost', [$post->id])\n            ->close(),\n    ])\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .body('Changes to the post have been saved.')\n    .actions([\n        new FilamentNotificationAction('view')\n            .button()\n            .url('/view')\n            .openUrlInNewTab(),\n        new FilamentNotificationAction('undo')\n            .color('gray')\n            .dispatch('undoEditingPost')\n            .close(),\n    ])\n    .send()\n```\n\n## #Using the JavaScript objects\n\nThe JavaScript objects (FilamentNotification and FilamentNotificationAction) are assigned to window.FilamentNotification and window.FilamentNotificationAction, so they are available in on-page scripts.\n\n`FilamentNotification``FilamentNotificationAction``window.FilamentNotification``window.FilamentNotificationAction`You may also import them in a bundled JavaScript file:\n\n```\nimport { Notification, NotificationAction } from '../../vendor/filament/notifications/dist/index.js'\n\n// ...\n```\n\n## #Closing a notification with JavaScript\n\nOnce a notification has been sent, you can close it on demand by dispatching a browser event on the window called close-notification.\n\n`close-notification`The event needs to contain the ID of the notification you sent. To get the ID, you can use the getId() method on the Notification object:\n\n`getId()``Notification````\nuse Filament\\Notifications\\Notification;\n\n$notification = Notification::make()\n    ->title('Hello')\n    ->persistent()\n    ->send()\n\n$notificationId = $notification->getId()\n```\n\nTo close the notification, you can dispatch the event from Livewire:\n\n```\n$this->dispatch('close-notification', id: $notificationId);\n```\n\nOr from JavaScript, in this case Alpine.js:\n\n```\n<button x-on:click=\"$dispatch('close-notification', { id: notificationId })\" type=\"button\">\n    Close Notification\n</button>\n```\n\nIf you are able to retrieve the notification ID, persist it, and then use it to close the notification, that is the recommended approach, as IDs are generated uniquely, and you will not risk closing the wrong notification. However, if it is not possible to persist the random ID, you can pass in a custom ID when sending the notification:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make('greeting')\n    ->title('Hello')\n    ->persistent()\n    ->send()\n```\n\nIn this case, you can close the notification by dispatching the event with the custom ID:\n\n```\n<button x-on:click=\"$dispatch('close-notification', { id: 'greeting' })\" type=\"button\">\n    Close Notification\n</button>\n```\n\nPlease be aware that if you send multiple notifications with the same ID, you may experience unexpected side effects, so random IDs are recommended.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Sending notifications - Notifications - Filament",
                "content": "Notifications",
                "level": 1
              },
              {
                "title": "# Sending notifications",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "> To start, make sure the package is installed - @livewire('notifications') should be in your Blade layout somewhere.\n\nTo start, make sure the package is installed - @livewire('notifications') should be in your Blade layout somewhere.\n\n`@livewire('notifications')`Notifications are sent using a Notification object that’s constructed through a fluent API. Calling the send() method on the Notification object will dispatch the notification and display it in your application. As the session is used to flash notifications, they can be sent from anywhere in your code, including JavaScript, not just Livewire components.\n\n`Notification``send()``Notification````\n<?php\n\nnamespace App\\Livewire;\n\nuse Filament\\Notifications\\Notification;\nuse Livewire\\Component;\n\nclass EditPost extends Component\n{\n    public function save(): void\n    {\n        // ...\n\n        Notification::make()\n            ->title('Saved successfully')\n            ->success()\n            ->send();\n    }\n}\n```",
                "level": 3
              },
              {
                "title": "## #Setting a title",
                "content": "The main message of the notification is shown in the title. You can set the title as follows:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->send();\n```\n\nThe title text can contain basic, safe HTML elements. To generate safe HTML with Markdown, you can use the Str::markdown() helper: title(Str::markdown('Saved **successfully**'))\n\n`Str::markdown()``title(Str::markdown('Saved **successfully**'))`Or with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .send()\n```",
                "level": 3
              },
              {
                "title": "## #Setting an icon",
                "content": "Optionally, a notification can have an icon that’s displayed in front of its content. You may also set a color for the icon, which is gray by default:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->icon('heroicon-o-document-text')\n    ->iconColor('success')\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .icon('heroicon-o-document-text')\n    .iconColor('success')\n    .send()\n```\n\nNotifications often have a status like success, warning, danger or info. Instead of manually setting the corresponding icons and colors, there’s a status() method which you can pass the status. You may also use the dedicated success(), warning(), danger() and info() methods instead. So, cleaning up the above example would look like this:\n\n`success``warning``danger``info``status()``success()``warning()``danger()``info()````\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .send()\n```",
                "level": 3
              },
              {
                "title": "## #Setting a background color",
                "content": "Notifications have no background color by default. You may want to provide additional context to your notification by setting a color as follows:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->color('success')\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .color('success')\n    .send()\n```",
                "level": 3
              },
              {
                "title": "## #Setting a duration",
                "content": "By default, notifications are shown for 6 seconds before they’re automatically closed. You may specify a custom duration value in milliseconds as follows:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->duration(5000)\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .duration(5000)\n    .send()\n```\n\nIf you prefer setting a duration in seconds instead of milliseconds, you can do so:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->seconds(5)\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .seconds(5)\n    .send()\n```\n\nYou might want some notifications to not automatically close and require the user to close them manually. This can be achieved by making the notification persistent:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->persistent()\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .persistent()\n    .send()\n```",
                "level": 3
              },
              {
                "title": "## #Setting body text",
                "content": "Additional notification text can be shown in the body():\n\n`body()````\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->send();\n```\n\nThe body text can contain basic, safe HTML elements. To generate safe HTML with Markdown, you can use the Str::markdown() helper: body(Str::markdown('Changes to the **post** have been saved.'))\n\n`Str::markdown()``body(Str::markdown('Changes to the **post** have been saved.'))`Or with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .body('Changes to the post have been saved.')\n    .send()\n```",
                "level": 3
              },
              {
                "title": "## #Adding actions to notifications",
                "content": "Notifications support Actions, which are buttons that render below the content of the notification. They can open a URL or dispatch a Livewire event. Actions can be defined as follows:\n\n```\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('view')\n            ->button(),\n        Action::make('undo')\n            ->color('gray'),\n    ])\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .body('Changes to the post have been saved.')\n    .actions([\n        new FilamentNotificationAction('view')\n            .button(),\n        new FilamentNotificationAction('undo')\n            .color('gray'),\n    ])\n    .send()\n```\n\nYou can learn more about how to style action buttons here.",
                "level": 3
              },
              {
                "title": "### #Opening URLs from notification actions",
                "content": "You can open a URL, optionally in a new tab, when clicking on an action:\n\n```\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('view')\n            ->button()\n            ->url(route('posts.show', $post), shouldOpenInNewTab: true),\n        Action::make('undo')\n            ->color('gray'),\n    ])\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .body('Changes to the post have been saved.')\n    .actions([\n        new FilamentNotificationAction('view')\n            .button()\n            .url('/view')\n            .openUrlInNewTab(),\n        new FilamentNotificationAction('undo')\n            .color('gray'),\n    ])\n    .send()\n```",
                "level": 4
              },
              {
                "title": "### #Dispatching Livewire events from notification actions",
                "content": "Sometimes you want to execute additional code when a notification action is clicked. This can be achieved by setting a Livewire event which should be dispatched on clicking the action. You may optionally pass an array of data, which will be available as parameters in the event listener on your Livewire component:\n\n```\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('view')\n            ->button()\n            ->url(route('posts.show', $post), shouldOpenInNewTab: true),\n        Action::make('undo')\n            ->color('gray')\n            ->dispatch('undoEditingPost', [$post->id]),\n    ])\n    ->send();\n```\n\nYou can also dispatchSelf and dispatchTo:\n\n`dispatchSelf``dispatchTo````\nAction::make('undo')\n    ->color('gray')\n    ->dispatchSelf('undoEditingPost', [$post->id])\n\nAction::make('undo')\n    ->color('gray')\n    ->dispatchTo('another_component', 'undoEditingPost', [$post->id])\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .body('Changes to the post have been saved.')\n    .actions([\n        new FilamentNotificationAction('view')\n            .button()\n            .url('/view')\n            .openUrlInNewTab(),\n        new FilamentNotificationAction('undo')\n            .color('gray')\n            .dispatch('undoEditingPost'),\n    ])\n    .send()\n```\n\nSimilarly, dispatchSelf and dispatchTo are also available:\n\n`dispatchSelf``dispatchTo````\nnew FilamentNotificationAction('undo')\n    .color('gray')\n    .dispatchSelf('undoEditingPost')\n\nnew FilamentNotificationAction('undo')\n    .color('gray')\n    .dispatchTo('another_component', 'undoEditingPost')\n```",
                "level": 4
              },
              {
                "title": "### #Closing notifications from actions",
                "content": "After opening a URL or dispatching an event from your action, you may want to close the notification right away:\n\n```\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('view')\n            ->button()\n            ->url(route('posts.show', $post), shouldOpenInNewTab: true),\n        Action::make('undo')\n            ->color('gray')\n            ->dispatch('undoEditingPost', [$post->id])\n            ->close(),\n    ])\n    ->send();\n```\n\nOr with JavaScript:\n\n```\nnew FilamentNotification()\n    .title('Saved successfully')\n    .success()\n    .body('Changes to the post have been saved.')\n    .actions([\n        new FilamentNotificationAction('view')\n            .button()\n            .url('/view')\n            .openUrlInNewTab(),\n        new FilamentNotificationAction('undo')\n            .color('gray')\n            .dispatch('undoEditingPost')\n            .close(),\n    ])\n    .send()\n```",
                "level": 4
              },
              {
                "title": "## #Using the JavaScript objects",
                "content": "The JavaScript objects (FilamentNotification and FilamentNotificationAction) are assigned to window.FilamentNotification and window.FilamentNotificationAction, so they are available in on-page scripts.\n\n`FilamentNotification``FilamentNotificationAction``window.FilamentNotification``window.FilamentNotificationAction`You may also import them in a bundled JavaScript file:\n\n```\nimport { Notification, NotificationAction } from '../../vendor/filament/notifications/dist/index.js'\n\n// ...\n```",
                "level": 3
              },
              {
                "title": "## #Closing a notification with JavaScript",
                "content": "Once a notification has been sent, you can close it on demand by dispatching a browser event on the window called close-notification.\n\n`close-notification`The event needs to contain the ID of the notification you sent. To get the ID, you can use the getId() method on the Notification object:\n\n`getId()``Notification````\nuse Filament\\Notifications\\Notification;\n\n$notification = Notification::make()\n    ->title('Hello')\n    ->persistent()\n    ->send()\n\n$notificationId = $notification->getId()\n```\n\nTo close the notification, you can dispatch the event from Livewire:\n\n```\n$this->dispatch('close-notification', id: $notificationId);\n```\n\nOr from JavaScript, in this case Alpine.js:\n\n```\n<button x-on:click=\"$dispatch('close-notification', { id: notificationId })\" type=\"button\">\n    Close Notification\n</button>\n```\n\nIf you are able to retrieve the notification ID, persist it, and then use it to close the notification, that is the recommended approach, as IDs are generated uniquely, and you will not risk closing the wrong notification. However, if it is not possible to persist the random ID, you can pass in a custom ID when sending the notification:\n\n```\nuse Filament\\Notifications\\Notification;\n\nNotification::make('greeting')\n    ->title('Hello')\n    ->persistent()\n    ->send()\n```\n\nIn this case, you can close the notification by dispatching the event with the custom ID:\n\n```\n<button x-on:click=\"$dispatch('close-notification', { id: 'greeting' })\" type=\"button\">\n    Close Notification\n</button>\n```\n\nPlease be aware that if you send multiple notifications with the same ID, you may experience unexpected side effects, so random IDs are recommended.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Setting a title",
              "Setting an icon",
              "Setting a background color",
              "Setting a duration",
              "Setting body text",
              "Adding actions to notifications",
              "Opening URLs from notification actions",
              "Dispatching Livewire events from notification actions",
              "Closing notifications from actions"
            ],
            "code_examples_count": 66,
            "has_installation_info": true,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "database-notifications": {
          "metadata": {
            "title": "Database Notifications",
            "url": "https://filamentphp.com/docs/3.x/notifications/database-notifications",
            "section": "notifications",
            "word_count": 795,
            "character_count": 6861
          },
          "content": {
            "full_text": "\n# Database notifications - Notifications - Filament\n\nNotifications\n\n# Database notifications\n\n## #Setting up the notifications database table\n\nBefore we start, make sure that the Laravel notifications table is added to your database:\n\n```\n# Laravel 11 and higher\nphp artisan make:notifications-table\n\n# Laravel 10\nphp artisan notifications:table\n```\n\n> If you’re using PostgreSQL, make sure that the data column in the migration is using json(): $table->json('data').\n\nIf you’re using PostgreSQL, make sure that the data column in the migration is using json(): $table->json('data').\n\n`data``json()``$table->json('data')`> If you’re using UUIDs for your User model, make sure that your notifiable column is using uuidMorphs(): $table->uuidMorphs('notifiable').\n\nIf you’re using UUIDs for your User model, make sure that your notifiable column is using uuidMorphs(): $table->uuidMorphs('notifiable').\n\n`User``notifiable``uuidMorphs()``$table->uuidMorphs('notifiable')`## #Rendering the database notifications modal\n\n> If you want to add database notifications to a panel, follow this part of the guide.\n\nIf you want to add database notifications to a panel, follow this part of the guide.\n\nIf you’d like to render the database notifications modal outside of the Panel Builder, you’ll need to add a new Livewire component to your Blade layout:\n\n```\n@livewire('database-notifications')\n```\n\nTo open the modal, you must have a “trigger” button in your view. Create a new trigger button component in your app, for instance at /resources/views/filament/notifications/database-notifications-trigger.blade.php:\n\n`/resources/views/filament/notifications/database-notifications-trigger.blade.php````\n<button type=\"button\">\n    Notifications ({{ $unreadNotificationsCount }} unread)\n</button>\n```\n\n$unreadNotificationsCount is a variable automatically passed to this view, which provides it with a real-time count of unread notifications the user has.\n\n`$unreadNotificationsCount`In the service provider, point to this new trigger view:\n\n```\nuse Filament\\Notifications\\Livewire\\DatabaseNotifications;\n\nDatabaseNotifications::trigger('filament.notifications.database-notifications-trigger');\n```\n\nNow, click on the trigger button that is rendered in your view. A modal should appear containing your database notifications when clicked!\n\n### #Adding the database notifications modal to a panel\n\nYou can enable database notifications in a panel’s configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->databaseNotifications();\n}\n```\n\nTo learn more, visit the Panel Builder documentation.\n\n## #Sending database notifications\n\nThere are several ways to send database notifications, depending on which one suits you best.\n\nYou may use our fluent API:\n\n```\nuse Filament\\Notifications\\Notification;\n\n$recipient = auth()->user();\n\nNotification::make()\n    ->title('Saved successfully')\n    ->sendToDatabase($recipient);\n```\n\nOr, use the notify() method:\n\n`notify()````\nuse Filament\\Notifications\\Notification;\n\n$recipient = auth()->user();\n\n$recipient->notify(\n    Notification::make()\n        ->title('Saved successfully')\n        ->toDatabase(),\n);\n```\n\n> Laravel sends database notifications using the queue. Ensure your queue is running in order to receive the notifications.\n\nLaravel sends database notifications using the queue. Ensure your queue is running in order to receive the notifications.\n\nAlternatively, use a traditional Laravel notification class by returning the notification from the toDatabase() method:\n\n`toDatabase()````\nuse App\\Models\\User;\nuse Filament\\Notifications\\Notification;\n\npublic function toDatabase(User $notifiable): array\n{\n    return Notification::make()\n        ->title('Saved successfully')\n        ->getDatabaseMessage();\n}\n```\n\n## #Receiving database notifications\n\nWithout any setup, new database notifications will only be received when the page is first loaded.\n\n### #Polling for new database notifications\n\nPolling is the practice of periodically making a request to the server to check for new notifications. This is a good approach as the setup is simple, but some may say that it is not a scalable solution as it increases server load.\n\nBy default, Livewire polls for new notifications every 30 seconds:\n\n```\nuse Filament\\Notifications\\Livewire\\DatabaseNotifications;\n\nDatabaseNotifications::pollingInterval('30s');\n```\n\nYou may completely disable polling if you wish:\n\n```\nuse Filament\\Notifications\\Livewire\\DatabaseNotifications;\n\nDatabaseNotifications::pollingInterval(null);\n```\n\n### #Using Echo to receive new database notifications with websockets\n\nAlternatively, the package has a native integration with Laravel Echo. Make sure Echo is installed, as well as a server-side websockets integration like Pusher.\n\nOnce websockets are set up, you can automatically dispatch a DatabaseNotificationsSent event by setting the isEventDispatched parameter to true when sending the notification. This will trigger the immediate fetching of new notifications for the user:\n\n`DatabaseNotificationsSent``isEventDispatched``true````\nuse Filament\\Notifications\\Notification;\n\n$recipient = auth()->user();\n\nNotification::make()\n    ->title('Saved successfully')\n    ->sendToDatabase($recipient, isEventDispatched: true);\n```\n\n## #Marking database notifications as read\n\nThere is a button at the top of the modal to mark all notifications as read at once. You may also add Actions to notifications, which you can use to mark individual notifications as read. To do this, use the markAsRead() method on the action:\n\n`markAsRead()````\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('view')\n            ->button()\n            ->markAsRead(),\n    ])\n    ->send();\n```\n\nAlternatively, you may use the markAsUnread() method to mark a notification as unread:\n\n`markAsUnread()````\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('markAsUnread')\n            ->button()\n            ->markAsUnread(),\n    ])\n    ->send();\n```\n\n## #Opening the database notifications modal\n\nInstead of rendering the trigger button as described above, you can always open the database notifications modal from anywhere by dispatching an open-modal browser event:\n\n`open-modal````\n<button\n    x-data=\"{}\"\n    x-on:click=\"$dispatch('open-modal', { id: 'database-notifications' })\"\n    type=\"button\"\n>\n    Notifications\n</button>\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Database notifications - Notifications - Filament",
                "content": "Notifications",
                "level": 1
              },
              {
                "title": "# Database notifications",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Setting up the notifications database table",
                "content": "Before we start, make sure that the Laravel notifications table is added to your database:\n\n```",
                "level": 3
              },
              {
                "title": "# Laravel 11 and higher",
                "content": "php artisan make:notifications-table",
                "level": 1
              },
              {
                "title": "# Laravel 10",
                "content": "php artisan notifications:table\n```\n\n> If you’re using PostgreSQL, make sure that the data column in the migration is using json(): $table->json('data').\n\nIf you’re using PostgreSQL, make sure that the data column in the migration is using json(): $table->json('data').\n\n`data``json()``$table->json('data')`> If you’re using UUIDs for your User model, make sure that your notifiable column is using uuidMorphs(): $table->uuidMorphs('notifiable').\n\nIf you’re using UUIDs for your User model, make sure that your notifiable column is using uuidMorphs(): $table->uuidMorphs('notifiable').\n\n`User``notifiable``uuidMorphs()``$table->uuidMorphs('notifiable')`## #Rendering the database notifications modal\n\n> If you want to add database notifications to a panel, follow this part of the guide.\n\nIf you want to add database notifications to a panel, follow this part of the guide.\n\nIf you’d like to render the database notifications modal outside of the Panel Builder, you’ll need to add a new Livewire component to your Blade layout:\n\n```\n@livewire('database-notifications')\n```\n\nTo open the modal, you must have a “trigger” button in your view. Create a new trigger button component in your app, for instance at /resources/views/filament/notifications/database-notifications-trigger.blade.php:\n\n`/resources/views/filament/notifications/database-notifications-trigger.blade.php````\n<button type=\"button\">\n    Notifications ({{ $unreadNotificationsCount }} unread)\n</button>\n```\n\n$unreadNotificationsCount is a variable automatically passed to this view, which provides it with a real-time count of unread notifications the user has.\n\n`$unreadNotificationsCount`In the service provider, point to this new trigger view:\n\n```\nuse Filament\\Notifications\\Livewire\\DatabaseNotifications;\n\nDatabaseNotifications::trigger('filament.notifications.database-notifications-trigger');\n```\n\nNow, click on the trigger button that is rendered in your view. A modal should appear containing your database notifications when clicked!",
                "level": 1
              },
              {
                "title": "### #Adding the database notifications modal to a panel",
                "content": "You can enable database notifications in a panel’s configuration:\n\n```\nuse Filament\\Panel;\n\npublic function panel(Panel $panel): Panel\n{\n    return $panel\n        // ...\n        ->databaseNotifications();\n}\n```\n\nTo learn more, visit the Panel Builder documentation.",
                "level": 4
              },
              {
                "title": "## #Sending database notifications",
                "content": "There are several ways to send database notifications, depending on which one suits you best.\n\nYou may use our fluent API:\n\n```\nuse Filament\\Notifications\\Notification;\n\n$recipient = auth()->user();\n\nNotification::make()\n    ->title('Saved successfully')\n    ->sendToDatabase($recipient);\n```\n\nOr, use the notify() method:\n\n`notify()````\nuse Filament\\Notifications\\Notification;\n\n$recipient = auth()->user();\n\n$recipient->notify(\n    Notification::make()\n        ->title('Saved successfully')\n        ->toDatabase(),\n);\n```\n\n> Laravel sends database notifications using the queue. Ensure your queue is running in order to receive the notifications.\n\nLaravel sends database notifications using the queue. Ensure your queue is running in order to receive the notifications.\n\nAlternatively, use a traditional Laravel notification class by returning the notification from the toDatabase() method:\n\n`toDatabase()````\nuse App\\Models\\User;\nuse Filament\\Notifications\\Notification;\n\npublic function toDatabase(User $notifiable): array\n{\n    return Notification::make()\n        ->title('Saved successfully')\n        ->getDatabaseMessage();\n}\n```",
                "level": 3
              },
              {
                "title": "## #Receiving database notifications",
                "content": "Without any setup, new database notifications will only be received when the page is first loaded.",
                "level": 3
              },
              {
                "title": "### #Polling for new database notifications",
                "content": "Polling is the practice of periodically making a request to the server to check for new notifications. This is a good approach as the setup is simple, but some may say that it is not a scalable solution as it increases server load.\n\nBy default, Livewire polls for new notifications every 30 seconds:\n\n```\nuse Filament\\Notifications\\Livewire\\DatabaseNotifications;\n\nDatabaseNotifications::pollingInterval('30s');\n```\n\nYou may completely disable polling if you wish:\n\n```\nuse Filament\\Notifications\\Livewire\\DatabaseNotifications;\n\nDatabaseNotifications::pollingInterval(null);\n```",
                "level": 4
              },
              {
                "title": "### #Using Echo to receive new database notifications with websockets",
                "content": "Alternatively, the package has a native integration with Laravel Echo. Make sure Echo is installed, as well as a server-side websockets integration like Pusher.\n\nOnce websockets are set up, you can automatically dispatch a DatabaseNotificationsSent event by setting the isEventDispatched parameter to true when sending the notification. This will trigger the immediate fetching of new notifications for the user:\n\n`DatabaseNotificationsSent``isEventDispatched``true````\nuse Filament\\Notifications\\Notification;\n\n$recipient = auth()->user();\n\nNotification::make()\n    ->title('Saved successfully')\n    ->sendToDatabase($recipient, isEventDispatched: true);\n```",
                "level": 4
              },
              {
                "title": "## #Marking database notifications as read",
                "content": "There is a button at the top of the modal to mark all notifications as read at once. You may also add Actions to notifications, which you can use to mark individual notifications as read. To do this, use the markAsRead() method on the action:\n\n`markAsRead()````\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('view')\n            ->button()\n            ->markAsRead(),\n    ])\n    ->send();\n```\n\nAlternatively, you may use the markAsUnread() method to mark a notification as unread:\n\n`markAsUnread()````\nuse Filament\\Notifications\\Actions\\Action;\nuse Filament\\Notifications\\Notification;\n\nNotification::make()\n    ->title('Saved successfully')\n    ->success()\n    ->body('Changes to the post have been saved.')\n    ->actions([\n        Action::make('markAsUnread')\n            ->button()\n            ->markAsUnread(),\n    ])\n    ->send();\n```",
                "level": 3
              },
              {
                "title": "## #Opening the database notifications modal",
                "content": "Instead of rendering the trigger button as described above, you can always open the database notifications modal from anywhere by dispatching an open-modal browser event:\n\n`open-modal````\n<button\n    x-data=\"{}\"\n    x-on:click=\"$dispatch('open-modal', { id: 'database-notifications' })\"\n    type=\"button\"\n>\n    Notifications\n</button>\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Setting up the notifications database table",
              "Adding the database notifications modal to a panel",
              "Sending database notifications",
              "Receiving database notifications",
              "Polling for new database notifications",
              "Using Echo to receive new database notifications with websockets",
              "Marking database notifications as read",
              "Opening the database notifications modal"
            ],
            "code_examples_count": 28,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "broadcast-notifications": {
          "metadata": {
            "title": "Broadcast Notifications",
            "url": "https://filamentphp.com/docs/3.x/notifications/broadcast-notifications",
            "section": "notifications",
            "word_count": 216,
            "character_count": 1865
          },
          "content": {
            "full_text": "\n# Broadcast notifications - Notifications - Filament\n\nNotifications\n\n# Broadcast notifications\n\n## #Overview\n\n> To start, make sure the package is installed - @livewire('notifications') should be in your Blade layout somewhere.\n\nTo start, make sure the package is installed - @livewire('notifications') should be in your Blade layout somewhere.\n\n`@livewire('notifications')`By default, Filament will send flash notifications via the Laravel session. However, you may wish that your notifications are “broadcast” to a user in real-time, instead. This could be used to send a temporary success notification from a queued job after it has finished processing.\n\nWe have a native integration with Laravel Echo. Make sure Echo is installed, as well as a server-side websockets integration like Pusher.\n\n## #Sending broadcast notifications\n\nThere are several ways to send broadcast notifications, depending on which one suits you best.\n\nYou may use our fluent API:\n\n```\nuse Filament\\Notifications\\Notification;\n\n$recipient = auth()->user();\n\nNotification::make()\n    ->title('Saved successfully')\n    ->broadcast($recipient);\n```\n\nOr, use the notify() method:\n\n`notify()````\nuse Filament\\Notifications\\Notification;\n\n$recipient = auth()->user();\n\n$recipient->notify(\n    Notification::make()\n        ->title('Saved successfully')\n        ->toBroadcast(),\n)\n```\n\nAlternatively, use a traditional Laravel notification class by returning the notification from the toBroadcast() method:\n\n`toBroadcast()````\nuse App\\Models\\User;\nuse Filament\\Notifications\\Notification;\nuse Illuminate\\Notifications\\Messages\\BroadcastMessage;\n\npublic function toBroadcast(User $notifiable): BroadcastMessage\n{\n    return Notification::make()\n        ->title('Saved successfully')\n        ->getBroadcastMessage();\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Broadcast notifications - Notifications - Filament",
                "content": "Notifications",
                "level": 1
              },
              {
                "title": "# Broadcast notifications",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "> To start, make sure the package is installed - @livewire('notifications') should be in your Blade layout somewhere.\n\nTo start, make sure the package is installed - @livewire('notifications') should be in your Blade layout somewhere.\n\n`@livewire('notifications')`By default, Filament will send flash notifications via the Laravel session. However, you may wish that your notifications are “broadcast” to a user in real-time, instead. This could be used to send a temporary success notification from a queued job after it has finished processing.\n\nWe have a native integration with Laravel Echo. Make sure Echo is installed, as well as a server-side websockets integration like Pusher.",
                "level": 3
              },
              {
                "title": "## #Sending broadcast notifications",
                "content": "There are several ways to send broadcast notifications, depending on which one suits you best.\n\nYou may use our fluent API:\n\n```\nuse Filament\\Notifications\\Notification;\n\n$recipient = auth()->user();\n\nNotification::make()\n    ->title('Saved successfully')\n    ->broadcast($recipient);\n```\n\nOr, use the notify() method:\n\n`notify()````\nuse Filament\\Notifications\\Notification;\n\n$recipient = auth()->user();\n\n$recipient->notify(\n    Notification::make()\n        ->title('Saved successfully')\n        ->toBroadcast(),\n)\n```\n\nAlternatively, use a traditional Laravel notification class by returning the notification from the toBroadcast() method:\n\n`toBroadcast()````\nuse App\\Models\\User;\nuse Filament\\Notifications\\Notification;\nuse Illuminate\\Notifications\\Messages\\BroadcastMessage;\n\npublic function toBroadcast(User $notifiable): BroadcastMessage\n{\n    return Notification::make()\n        ->title('Saved successfully')\n        ->getBroadcastMessage();\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Sending broadcast notifications"
            ],
            "code_examples_count": 6,
            "has_installation_info": true,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "customizing-notifications": {
          "metadata": {
            "title": "Customizing Notifications",
            "url": "https://filamentphp.com/docs/3.x/notifications/customizing-notifications",
            "section": "notifications",
            "word_count": 455,
            "character_count": 4681
          },
          "content": {
            "full_text": "\n# Customizing notifications - Notifications - Filament\n\nNotifications\n\n# Customizing notifications\n\n## #Overview\n\nNotifications come fully styled out of the box. However, if you want to apply your own styling or use a custom view to render notifications, there are multiple options.\n\n## #Styling notifications\n\nNotifications have dedicated CSS classes you can hook into to apply your own styling. Open the inspector in your browser to find out which classes you need to target.\n\n## #Positioning notifications\n\nYou can configure the alignment of the notifications in a service provider or middleware, by calling Notifications::alignment() and Notifications::verticalAlignment(). You can pass Alignment::Start, Alignment::Center, Alignment::End, VerticalAlignment::Start, VerticalAlignment::Center or VerticalAlignment::End:\n\n`Notifications::alignment()``Notifications::verticalAlignment()``Alignment::Start``Alignment::Center``Alignment::End``VerticalAlignment::Start``VerticalAlignment::Center``VerticalAlignment::End````\nuse Filament\\Notifications\\Livewire\\Notifications;\nuse Filament\\Support\\Enums\\Alignment;\nuse Filament\\Support\\Enums\\VerticalAlignment;\n\nNotifications::alignment(Alignment::Start);\nNotifications::verticalAlignment(VerticalAlignment::End);\n```\n\n## #Using a custom notification view\n\nIf your desired customization can’t be achieved using the CSS classes above, you can create a custom view to render the notification. To configure the notification view, call the static configureUsing() method inside a service provider’s boot() method and specify the view to use:\n\n`configureUsing()``boot()````\nuse Filament\\Notifications\\Notification;\n\nNotification::configureUsing(function (Notification $notification): void {\n    $notification->view('filament.notifications.notification');\n});\n```\n\nNext, create the view, in this example resources/views/filament/notifications/notification.blade.php. The view should use the package’s base notification component for the notification functionality and pass the available $notification variable through the notification attribute. This is the bare minimum required to create your own notification view:\n\n`resources/views/filament/notifications/notification.blade.php``$notification``notification````\n<x-filament-notifications::notification :notification=\"$notification\">\n    {{-- Notification content --}}\n</x-filament-notifications::notification>\n```\n\nGetters for all notification properties will be available in the view. So, a custom notification view might look like this:\n\n```\n<x-filament-notifications::notification\n    :notification=\"$notification\"\n    class=\"flex w-80 rounded-lg transition duration-200\"\n    x-transition:enter-start=\"opacity-0\"\n    x-transition:leave-end=\"opacity-0\"\n>\n    <h4>\n        {{ $getTitle() }}\n    </h4>\n\n    <p>\n        {{ $getDate() }}\n    </p>\n\n    <p>\n        {{ $getBody() }}\n    </p>\n\n    <span x-on:click=\"close\">\n        Close\n    </span>\n</x-filament-notifications::notification>\n```\n\n## #Using a custom notification object\n\nMaybe your notifications require additional functionality that’s not defined in the package’s Notification class. Then you can create your own Notification class, which extends the package’s Notification class. For example, your notification design might need a size property.\n\n`Notification``Notification``Notification`Your custom Notification class in app/Notifications/Notification.php might contain:\n\n`Notification``app/Notifications/Notification.php````\n<?php\n\nnamespace App\\Notifications;\n\nuse Filament\\Notifications\\Notification as BaseNotification;\n\nclass Notification extends BaseNotification\n{\n    protected string $size = 'md';\n\n    public function toArray(): array\n    {\n        return [\n            ...parent::toArray(),\n            'size' => $this->getSize(),\n        ];\n    }\n\n    public static function fromArray(array $data): static\n    {\n        return parent::fromArray($data)->size($data['size']);\n    }\n\n    public function size(string $size): static\n    {\n        $this->size = $size;\n\n        return $this;\n    }\n\n    public function getSize(): string\n    {\n        return $this->size;\n    }\n}\n```\n\nNext, you should bind your custom Notification class into the container inside a service provider’s register() method:\n\n`Notification``register()````\nuse App\\Notifications\\Notification;\nuse Filament\\Notifications\\Notification as BaseNotification;\n\n$this->app->bind(BaseNotification::class, Notification::class);\n```\n\nYou can now use your custom Notification class in the same way as you would with the default Notification object.\n\n`Notification``Notification`Still need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Customizing notifications - Notifications - Filament",
                "content": "Notifications",
                "level": 1
              },
              {
                "title": "# Customizing notifications",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Notifications come fully styled out of the box. However, if you want to apply your own styling or use a custom view to render notifications, there are multiple options.",
                "level": 3
              },
              {
                "title": "## #Styling notifications",
                "content": "Notifications have dedicated CSS classes you can hook into to apply your own styling. Open the inspector in your browser to find out which classes you need to target.",
                "level": 3
              },
              {
                "title": "## #Positioning notifications",
                "content": "You can configure the alignment of the notifications in a service provider or middleware, by calling Notifications::alignment() and Notifications::verticalAlignment(). You can pass Alignment::Start, Alignment::Center, Alignment::End, VerticalAlignment::Start, VerticalAlignment::Center or VerticalAlignment::End:\n\n`Notifications::alignment()``Notifications::verticalAlignment()``Alignment::Start``Alignment::Center``Alignment::End``VerticalAlignment::Start``VerticalAlignment::Center``VerticalAlignment::End````\nuse Filament\\Notifications\\Livewire\\Notifications;\nuse Filament\\Support\\Enums\\Alignment;\nuse Filament\\Support\\Enums\\VerticalAlignment;\n\nNotifications::alignment(Alignment::Start);\nNotifications::verticalAlignment(VerticalAlignment::End);\n```",
                "level": 3
              },
              {
                "title": "## #Using a custom notification view",
                "content": "If your desired customization can’t be achieved using the CSS classes above, you can create a custom view to render the notification. To configure the notification view, call the static configureUsing() method inside a service provider’s boot() method and specify the view to use:\n\n`configureUsing()``boot()````\nuse Filament\\Notifications\\Notification;\n\nNotification::configureUsing(function (Notification $notification): void {\n    $notification->view('filament.notifications.notification');\n});\n```\n\nNext, create the view, in this example resources/views/filament/notifications/notification.blade.php. The view should use the package’s base notification component for the notification functionality and pass the available $notification variable through the notification attribute. This is the bare minimum required to create your own notification view:\n\n`resources/views/filament/notifications/notification.blade.php``$notification``notification````\n<x-filament-notifications::notification :notification=\"$notification\">\n    {{-- Notification content --}}\n</x-filament-notifications::notification>\n```\n\nGetters for all notification properties will be available in the view. So, a custom notification view might look like this:\n\n```\n<x-filament-notifications::notification\n    :notification=\"$notification\"\n    class=\"flex w-80 rounded-lg transition duration-200\"\n    x-transition:enter-start=\"opacity-0\"\n    x-transition:leave-end=\"opacity-0\"\n>\n    <h4>\n        {{ $getTitle() }}\n    </h4>\n\n    <p>\n        {{ $getDate() }}\n    </p>\n\n    <p>\n        {{ $getBody() }}\n    </p>\n\n    <span x-on:click=\"close\">\n        Close\n    </span>\n</x-filament-notifications::notification>\n```",
                "level": 3
              },
              {
                "title": "## #Using a custom notification object",
                "content": "Maybe your notifications require additional functionality that’s not defined in the package’s Notification class. Then you can create your own Notification class, which extends the package’s Notification class. For example, your notification design might need a size property.\n\n`Notification``Notification``Notification`Your custom Notification class in app/Notifications/Notification.php might contain:\n\n`Notification``app/Notifications/Notification.php````\n<?php\n\nnamespace App\\Notifications;\n\nuse Filament\\Notifications\\Notification as BaseNotification;\n\nclass Notification extends BaseNotification\n{\n    protected string $size = 'md';\n\n    public function toArray(): array\n    {\n        return [\n            ...parent::toArray(),\n            'size' => $this->getSize(),\n        ];\n    }\n\n    public static function fromArray(array $data): static\n    {\n        return parent::fromArray($data)->size($data['size']);\n    }\n\n    public function size(string $size): static\n    {\n        $this->size = $size;\n\n        return $this;\n    }\n\n    public function getSize(): string\n    {\n        return $this->size;\n    }\n}\n```\n\nNext, you should bind your custom Notification class into the container inside a service provider’s register() method:\n\n`Notification``register()````\nuse App\\Notifications\\Notification;\nuse Filament\\Notifications\\Notification as BaseNotification;\n\n$this->app->bind(BaseNotification::class, Notification::class);\n```\n\nYou can now use your custom Notification class in the same way as you would with the default Notification object.\n\n`Notification``Notification`Still need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Styling notifications",
              "Positioning notifications",
              "Using a custom notification view",
              "Using a custom notification object"
            ],
            "code_examples_count": 12,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "testing": {
          "metadata": {
            "title": "Testing",
            "url": "https://filamentphp.com/docs/3.x/notifications/testing",
            "section": "notifications",
            "word_count": 230,
            "character_count": 2190
          },
          "content": {
            "full_text": "\n# Testing - Notifications - Filament\n\nNotifications\n\n# Testing\n\n## #Overview\n\nAll examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.\n\n## #Testing session notifications\n\nTo check if a notification was sent using the session, use the assertNotified() helper:\n\n`assertNotified()````\nuse function Pest\\Livewire\\livewire;\n\nit('sends a notification', function () {\n    livewire(CreatePost::class)\n        ->assertNotified();\n});\n```\n\n```\nuse Filament\\Notifications\\Notification;\n\nit('sends a notification', function () {\n    Notification::assertNotified();\n});\n```\n\n```\nuse function Filament\\Notifications\\Testing\\assertNotified;\n\nit('sends a notification', function () {\n    assertNotified();\n});\n```\n\nYou may optionally pass a notification title to test for:\n\n```\nuse Filament\\Notifications\\Notification;\nuse function Pest\\Livewire\\livewire;\n\nit('sends a notification', function () {\n    livewire(CreatePost::class)\n        ->assertNotified('Unable to create post');\n});\n```\n\nOr test if the exact notification was sent:\n\n```\nuse Filament\\Notifications\\Notification;\nuse function Pest\\Livewire\\livewire;\n\nit('sends a notification', function () {\n    livewire(CreatePost::class)\n        ->assertNotified(\n            Notification::make()\n                ->danger()\n                ->title('Unable to create post')\n                ->body('Something went wrong.'),\n        );\n});\n```\n\nConversely, you can assert that a notification was not sent:\n\n```\nuse Filament\\Notifications\\Notification;\nuse function Pest\\Livewire\\livewire;\n\nit('does not send a notification', function () {\n    livewire(CreatePost::class)\n        ->assertNotNotified()\n        // or\n        ->assertNotNotified('Unable to create post')\n        // or\n        ->assertNotNotified(\n            Notification::make()\n                ->danger()\n                ->title('Unable to create post')\n                ->body('Something went wrong.'),\n        );\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Testing - Notifications - Filament",
                "content": "Notifications",
                "level": 1
              },
              {
                "title": "# Testing",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "All examples in this guide will be written using Pest. To use Pest’s Livewire plugin for testing, you can follow the installation instructions in the Pest documentation on plugins: Livewire plugin for Pest. However, you can easily adapt this to PHPUnit.",
                "level": 3
              },
              {
                "title": "## #Testing session notifications",
                "content": "To check if a notification was sent using the session, use the assertNotified() helper:\n\n`assertNotified()````\nuse function Pest\\Livewire\\livewire;\n\nit('sends a notification', function () {\n    livewire(CreatePost::class)\n        ->assertNotified();\n});\n```\n\n```\nuse Filament\\Notifications\\Notification;\n\nit('sends a notification', function () {\n    Notification::assertNotified();\n});\n```\n\n```\nuse function Filament\\Notifications\\Testing\\assertNotified;\n\nit('sends a notification', function () {\n    assertNotified();\n});\n```\n\nYou may optionally pass a notification title to test for:\n\n```\nuse Filament\\Notifications\\Notification;\nuse function Pest\\Livewire\\livewire;\n\nit('sends a notification', function () {\n    livewire(CreatePost::class)\n        ->assertNotified('Unable to create post');\n});\n```\n\nOr test if the exact notification was sent:\n\n```\nuse Filament\\Notifications\\Notification;\nuse function Pest\\Livewire\\livewire;\n\nit('sends a notification', function () {\n    livewire(CreatePost::class)\n        ->assertNotified(\n            Notification::make()\n                ->danger()\n                ->title('Unable to create post')\n                ->body('Something went wrong.'),\n        );\n});\n```\n\nConversely, you can assert that a notification was not sent:\n\n```\nuse Filament\\Notifications\\Notification;\nuse function Pest\\Livewire\\livewire;\n\nit('does not send a notification', function () {\n    livewire(CreatePost::class)\n        ->assertNotNotified()\n        // or\n        ->assertNotNotified('Unable to create post')\n        // or\n        ->assertNotNotified(\n            Notification::make()\n                ->danger()\n                ->title('Unable to create post')\n                ->body('Something went wrong.'),\n        );\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Testing session notifications"
            ],
            "code_examples_count": 12,
            "has_installation_info": true,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "upgrading": {
          "metadata": {
            "title": "Upgrading",
            "url": "https://filamentphp.com/docs/3.x/notifications/upgrading",
            "section": "notifications",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        }
      }
    },
    "widgets": {
      "section_info": {
        "name": "widgets",
        "page_count": 5,
        "description": "Dashboard widgets including stats, charts, and tables"
      },
      "pages": {
        "installation": {
          "metadata": {
            "title": "Installation",
            "url": "https://filamentphp.com/docs/3.x/widgets/installation",
            "section": "widgets",
            "word_count": 656,
            "character_count": 5490
          },
          "content": {
            "full_text": "\n# Installation - Widgets - Filament\n\nWidgets\n\n# Installation\n\nThe Widgets package is pre-installed with the Panel Builder. This guide is for using the Widgets package in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)\n\n## #Installation\n\nRequire the Widgets package using Composer:\n\n```\ncomposer require filament/widgets:\"^3.3\" -W\n```\n\n## #New Laravel projects\n\nTo quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --widgets\n\nnpm install\n\nnpm run dev\n```\n\n## #Existing Laravel projects\n\nRun the following command to install the Widgets package assets:\n\n```\nphp artisan filament:install --widgets\n```\n\n### #Installing Tailwind CSS\n\n> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```\n\n### #Configuring styles\n\nAdd Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```\n\n### #Automatically refreshing the browser\n\nYou may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```\n\n### #Compiling assets\n\nCompile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```\n\n## #Publishing configuration\n\nYou can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Upgrading\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Widgets - Filament",
                "content": "Widgets",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "The Widgets package is pre-installed with the Panel Builder. This guide is for using the Widgets package in a custom TALL Stack application (Tailwind, Alpine, Livewire, Laravel).",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n- Tailwind v3.0+ (Using Tailwind v4?)",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "Require the Widgets package using Composer:\n\n```\ncomposer require filament/widgets:\"^3.3\" -W\n```",
                "level": 3
              },
              {
                "title": "## #New Laravel projects",
                "content": "To quickly get started with Filament in a new Laravel project, run the following commands to install Livewire, Alpine.js, and Tailwind CSS:\n\n> Since these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\nSince these commands will overwrite existing files in your application, only run this in a new Laravel project!\n\n```\nphp artisan filament:install --scaffold --widgets\n\nnpm install\n\nnpm run dev\n```",
                "level": 3
              },
              {
                "title": "## #Existing Laravel projects",
                "content": "Run the following command to install the Widgets package assets:\n\n```\nphp artisan filament:install --widgets\n```",
                "level": 3
              },
              {
                "title": "### #Installing Tailwind CSS",
                "content": "> Filament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nFilament uses Tailwind CSS v3 for styling. If your project uses Tailwind CSS v4, you will unfortunately need to downgrade it to v3 to use Filament. Filament v3 can’t support Tailwind CSS v4 since it introduces breaking changes. Filament v4 will support Tailwind CSS v4.\n\nRun the following command to install Tailwind CSS with the Tailwind Forms and Typography plugins:\n\n```\nnpm install tailwindcss@3 @tailwindcss/forms @tailwindcss/typography postcss postcss-nesting autoprefixer --save-dev\n```\n\nCreate a new tailwind.config.js file and add the Filament preset (includes the Filament color scheme and the required Tailwind plugins):\n\n`tailwind.config.js``preset````\nimport preset from './vendor/filament/support/tailwind.config.preset'\n\nexport default {\n    presets: [preset],\n    content: [\n        './app/Filament/**/*.php',\n        './resources/views/filament/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n    ],\n}\n```",
                "level": 4
              },
              {
                "title": "### #Configuring styles",
                "content": "Add Tailwind’s CSS layers to your resources/css/app.css:\n\n`resources/css/app.css````\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n@tailwind variants;\n```\n\nCreate a postcss.config.js file in the root of your project and register Tailwind CSS, PostCSS Nesting and Autoprefixer as plugins:\n\n`postcss.config.js````\nexport default {\n    plugins: {\n        'tailwindcss/nesting': 'postcss-nesting',\n        tailwindcss: {},\n        autoprefixer: {},\n    },\n}\n```",
                "level": 4
              },
              {
                "title": "### #Automatically refreshing the browser",
                "content": "You may also want to update your vite.config.js file to refresh the page automatically when Livewire components are updated:\n\n`vite.config.js````\nimport { defineConfig } from 'vite'\nimport laravel, { refreshPaths } from 'laravel-vite-plugin'\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: ['resources/css/app.css', 'resources/js/app.js'],\n            refresh: [\n                ...refreshPaths,\n                'app/Livewire/**',\n            ],\n        }),\n    ],\n})\n```",
                "level": 4
              },
              {
                "title": "### #Compiling assets",
                "content": "Compile your new CSS and Javascript assets using npm run dev.\n\n`npm run dev`### #Configuring your layout\n\nCreate a new resources/views/components/layouts/app.blade.php layout file for Livewire components:\n\n`resources/views/components/layouts/app.blade.php````\n<!DOCTYPE html>\n<html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\n    <head>\n        <meta charset=\"utf-8\">\n\n        <meta name=\"application-name\" content=\"{{ config('app.name') }}\">\n        <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>{{ config('app.name') }}</title>\n\n        <style>\n            [x-cloak] {\n                display: none !important;\n            }\n        </style>\n\n        @filamentStyles\n        @vite('resources/css/app.css')\n    </head>\n\n    <body class=\"antialiased\">\n        {{ $slot }}\n\n        @filamentScripts\n        @vite('resources/js/app.js')\n    </body>\n</html>\n```",
                "level": 4
              },
              {
                "title": "## #Publishing configuration",
                "content": "You can publish the package configuration using the following command (optional):\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "Filament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "New Laravel projects",
              "Existing Laravel projects",
              "Installing Tailwind CSS",
              "Configuring styles",
              "Automatically refreshing the browser",
              "Compiling assets",
              "Publishing configuration",
              "Upgrading"
            ],
            "code_examples_count": 24,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        },
        "stats-overview": {
          "metadata": {
            "title": "Stats Overview",
            "url": "https://filamentphp.com/docs/3.x/widgets/stats-overview",
            "section": "widgets",
            "word_count": 599,
            "character_count": 5628
          },
          "content": {
            "full_text": "\n# Stats overview widgets - Widgets - Filament\n\nWidgets\n\n# Stats overview widgets\n\n## #Overview\n\nFilament comes with a “stats overview” widget template, which you can use to display a number of different stats in a single widget, without needing to write a custom view.\n\nStart by creating a widget with the command:\n\n```\nphp artisan make:filament-widget StatsOverview --stats-overview\n```\n\nThis command will create a new StatsOverview.php file. Open it, and return Stat instances from the getStats() method:\n\n`StatsOverview.php``Stat``getStats()````\n<?php\n\nnamespace App\\Filament\\Widgets;\n\nuse Filament\\Widgets\\StatsOverviewWidget as BaseWidget;\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nclass StatsOverview extends BaseWidget\n{\n    protected function getStats(): array\n    {\n        return [\n            Stat::make('Unique views', '192.1k'),\n            Stat::make('Bounce rate', '21%'),\n            Stat::make('Average time on page', '3:12'),\n        ];\n    }\n}\n```\n\nNow, check out your widget in the dashboard.\n\n## #Adding a description and icon to a stat\n\nYou may add a description() to provide additional information, along with a descriptionIcon():\n\n`description()``descriptionIcon()````\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nprotected function getStats(): array\n{\n    return [\n        Stat::make('Unique views', '192.1k')\n            ->description('32k increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-up'),\n        Stat::make('Bounce rate', '21%')\n            ->description('7% decrease')\n            ->descriptionIcon('heroicon-m-arrow-trending-down'),\n        Stat::make('Average time on page', '3:12')\n            ->description('3% increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-up'),\n    ];\n}\n```\n\nThe descriptionIcon() method also accepts a second parameter to put the icon before the description instead of after it:\n\n`descriptionIcon()````\nuse Filament\\Support\\Enums\\IconPosition;\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nStat::make('Unique views', '192.1k')\n    ->description('32k increase')\n    ->descriptionIcon('heroicon-m-arrow-trending-up', IconPosition::Before)\n```\n\n## #Changing the color of the stat\n\nYou may also give stats a color() (danger, gray, info, primary, success or warning):\n\n`color()``danger``gray``info``primary``success``warning````\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nprotected function getStats(): array\n{\n    return [\n        Stat::make('Unique views', '192.1k')\n            ->description('32k increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-up')\n            ->color('success'),\n        Stat::make('Bounce rate', '21%')\n            ->description('7% increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-down')\n            ->color('danger'),\n        Stat::make('Average time on page', '3:12')\n            ->description('3% increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-up')\n            ->color('success'),\n    ];\n}\n```\n\n## #Adding extra HTML attributes to a stat\n\nYou may also pass extra HTML attributes to stats using extraAttributes():\n\n`extraAttributes()````\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nprotected function getStats(): array\n{\n    return [\n        Stat::make('Processed', '192.1k')\n            ->color('success')\n            ->extraAttributes([\n                'class' => 'cursor-pointer',\n                'wire:click' => \"\\$dispatch('setStatusFilter', { filter: 'processed' })\",\n            ]),\n        // ...\n    ];\n}\n```\n\nIn this example, we are deliberately escaping the $ in $dispatch() since this needs to be passed directly to the HTML, it is not a PHP variable.\n\n`$``$dispatch()`## #Adding a chart to a stat\n\nYou may also add or chain a chart() to each stat to provide historical data. The chart() method accepts an array of data points to plot:\n\n`chart()``chart()````\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nprotected function getStats(): array\n{\n    return [\n        Stat::make('Unique views', '192.1k')\n            ->description('32k increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-up')\n            ->chart([7, 2, 10, 3, 15, 4, 17])\n            ->color('success'),\n        // ...\n    ];\n}\n```\n\n## #Live updating stats (polling)\n\nBy default, stats overview widgets refresh their data every 5 seconds.\n\nTo customize this, you may override the $pollingInterval property on the class to a new interval:\n\n`$pollingInterval````\nprotected static ?string $pollingInterval = '10s';\n```\n\nAlternatively, you may disable polling altogether:\n\n```\nprotected static ?string $pollingInterval = null;\n```\n\n## #Disabling lazy loading\n\nBy default, widgets are lazy-loaded. This means that they will only be loaded when they are visible on the page.\n\nTo disable this behavior, you may override the $isLazy property on the widget class:\n\n`$isLazy````\nprotected static bool $isLazy = false;\n```\n\n## #Adding a heading and description\n\nYou may also add heading and description text above the widget by overriding the $heading and $description properties:\n\n`$heading``$description````\nprotected ?string $heading = 'Analytics';\n\nprotected ?string $description = 'An overview of some analytics.';\n```\n\nIf you need to dynamically generate the heading or description text, you can instead override the getHeading() and getDescription() methods:\n\n`getHeading()``getDescription()````\nprotected function getHeading(): ?string\n{\n    return 'Analytics';\n}\n\nprotected function getDescription(): ?string\n{\n    return 'An overview of some analytics.';\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Stats overview widgets - Widgets - Filament",
                "content": "Widgets",
                "level": 1
              },
              {
                "title": "# Stats overview widgets",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament comes with a “stats overview” widget template, which you can use to display a number of different stats in a single widget, without needing to write a custom view.\n\nStart by creating a widget with the command:\n\n```\nphp artisan make:filament-widget StatsOverview --stats-overview\n```\n\nThis command will create a new StatsOverview.php file. Open it, and return Stat instances from the getStats() method:\n\n`StatsOverview.php``Stat``getStats()````\n<?php\n\nnamespace App\\Filament\\Widgets;\n\nuse Filament\\Widgets\\StatsOverviewWidget as BaseWidget;\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nclass StatsOverview extends BaseWidget\n{\n    protected function getStats(): array\n    {\n        return [\n            Stat::make('Unique views', '192.1k'),\n            Stat::make('Bounce rate', '21%'),\n            Stat::make('Average time on page', '3:12'),\n        ];\n    }\n}\n```\n\nNow, check out your widget in the dashboard.",
                "level": 3
              },
              {
                "title": "## #Adding a description and icon to a stat",
                "content": "You may add a description() to provide additional information, along with a descriptionIcon():\n\n`description()``descriptionIcon()````\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nprotected function getStats(): array\n{\n    return [\n        Stat::make('Unique views', '192.1k')\n            ->description('32k increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-up'),\n        Stat::make('Bounce rate', '21%')\n            ->description('7% decrease')\n            ->descriptionIcon('heroicon-m-arrow-trending-down'),\n        Stat::make('Average time on page', '3:12')\n            ->description('3% increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-up'),\n    ];\n}\n```\n\nThe descriptionIcon() method also accepts a second parameter to put the icon before the description instead of after it:\n\n`descriptionIcon()````\nuse Filament\\Support\\Enums\\IconPosition;\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nStat::make('Unique views', '192.1k')\n    ->description('32k increase')\n    ->descriptionIcon('heroicon-m-arrow-trending-up', IconPosition::Before)\n```",
                "level": 3
              },
              {
                "title": "## #Changing the color of the stat",
                "content": "You may also give stats a color() (danger, gray, info, primary, success or warning):\n\n`color()``danger``gray``info``primary``success``warning````\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nprotected function getStats(): array\n{\n    return [\n        Stat::make('Unique views', '192.1k')\n            ->description('32k increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-up')\n            ->color('success'),\n        Stat::make('Bounce rate', '21%')\n            ->description('7% increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-down')\n            ->color('danger'),\n        Stat::make('Average time on page', '3:12')\n            ->description('3% increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-up')\n            ->color('success'),\n    ];\n}\n```",
                "level": 3
              },
              {
                "title": "## #Adding extra HTML attributes to a stat",
                "content": "You may also pass extra HTML attributes to stats using extraAttributes():\n\n`extraAttributes()````\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nprotected function getStats(): array\n{\n    return [\n        Stat::make('Processed', '192.1k')\n            ->color('success')\n            ->extraAttributes([\n                'class' => 'cursor-pointer',\n                'wire:click' => \"\\$dispatch('setStatusFilter', { filter: 'processed' })\",\n            ]),\n        // ...\n    ];\n}\n```\n\nIn this example, we are deliberately escaping the $ in $dispatch() since this needs to be passed directly to the HTML, it is not a PHP variable.\n\n`$``$dispatch()`## #Adding a chart to a stat\n\nYou may also add or chain a chart() to each stat to provide historical data. The chart() method accepts an array of data points to plot:\n\n`chart()``chart()````\nuse Filament\\Widgets\\StatsOverviewWidget\\Stat;\n\nprotected function getStats(): array\n{\n    return [\n        Stat::make('Unique views', '192.1k')\n            ->description('32k increase')\n            ->descriptionIcon('heroicon-m-arrow-trending-up')\n            ->chart([7, 2, 10, 3, 15, 4, 17])\n            ->color('success'),\n        // ...\n    ];\n}\n```",
                "level": 3
              },
              {
                "title": "## #Live updating stats (polling)",
                "content": "By default, stats overview widgets refresh their data every 5 seconds.\n\nTo customize this, you may override the $pollingInterval property on the class to a new interval:\n\n`$pollingInterval````\nprotected static ?string $pollingInterval = '10s';\n```\n\nAlternatively, you may disable polling altogether:\n\n```\nprotected static ?string $pollingInterval = null;\n```",
                "level": 3
              },
              {
                "title": "## #Disabling lazy loading",
                "content": "By default, widgets are lazy-loaded. This means that they will only be loaded when they are visible on the page.\n\nTo disable this behavior, you may override the $isLazy property on the widget class:\n\n`$isLazy````\nprotected static bool $isLazy = false;\n```",
                "level": 3
              },
              {
                "title": "## #Adding a heading and description",
                "content": "You may also add heading and description text above the widget by overriding the $heading and $description properties:\n\n`$heading``$description````\nprotected ?string $heading = 'Analytics';\n\nprotected ?string $description = 'An overview of some analytics.';\n```\n\nIf you need to dynamically generate the heading or description text, you can instead override the getHeading() and getDescription() methods:\n\n`getHeading()``getDescription()````\nprotected function getHeading(): ?string\n{\n    return 'Analytics';\n}\n\nprotected function getDescription(): ?string\n{\n    return 'An overview of some analytics.';\n}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Adding a description and icon to a stat",
              "Changing the color of the stat",
              "Adding extra HTML attributes to a stat",
              "Live updating stats (polling)",
              "Disabling lazy loading",
              "Adding a heading and description"
            ],
            "code_examples_count": 24,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "charts": {
          "metadata": {
            "title": "Charts",
            "url": "https://filamentphp.com/docs/3.x/widgets/charts",
            "section": "widgets",
            "word_count": 1353,
            "character_count": 10203
          },
          "content": {
            "full_text": "\n# Chart widgets - Widgets - Filament\n\nWidgets\n\n# Chart widgets\n\n## #Overview\n\nFilament comes with many “chart” widget templates, which you can use to display real-time, interactive charts.\n\nStart by creating a widget with the command:\n\n```\nphp artisan make:filament-widget BlogPostsChart --chart\n```\n\nThere is a single ChartWidget class that is used for all charts. The type of chart is set by the getType() method. In this example, that method returns the string 'line'.\n\n`ChartWidget``getType()``'line'`The protected static ?string $heading variable is used to set the heading that describes the chart. If you need to set the heading dynamically, you can override the getHeading() method.\n\n`protected static ?string $heading``getHeading()`The getData() method is used to return an array of datasets and labels. Each dataset is a labeled array of points to plot on the chart, and each label is a string. This structure is identical to the Chart.js library, which Filament uses to render charts. You may use the Chart.js documentation to fully understand the possibilities to return from getData(), based on the chart type.\n\n`getData()``getData()````\n<?php\n\nnamespace App\\Filament\\Widgets;\n\nuse Filament\\Widgets\\ChartWidget;\n\nclass BlogPostsChart extends ChartWidget\n{\n    protected static ?string $heading = 'Blog Posts';\n\n    protected function getData(): array\n    {\n        return [\n            'datasets' => [\n                [\n                    'label' => 'Blog posts created',\n                    'data' => [0, 10, 5, 2, 21, 32, 45, 74, 65, 45, 77, 89],\n                ],\n            ],\n            'labels' => ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        ];\n    }\n\n    protected function getType(): string\n    {\n        return 'line';\n    }\n}\n```\n\nNow, check out your widget in the dashboard.\n\n## #Available chart types\n\nBelow is a list of available chart widget classes which you may extend, and their corresponding Chart.js documentation page, for inspiration on what to return from getData():\n\n`getData()`- Bar chart - Chart.js documentation\n- Bubble chart - Chart.js documentation\n- Doughnut chart - Chart.js documentation\n- Line chart - Chart.js documentation\n- Pie chart - Chart.js documentation\n- Polar area chart - Chart.js documentation\n- Radar chart - Chart.js documentation\n- Scatter chart - Chart.js documentation\n\n## #Customizing the chart color\n\nYou can customize the color of the chart data by setting the $color property to either danger, gray, info, primary, success or warning:\n\n`$color``danger``gray``info``primary``success``warning````\nprotected static string $color = 'info';\n```\n\nIf you’re looking to customize the color further, or use multiple colors across multiple datasets, you can still make use of Chart.js’s color options in the data:\n\n```\nprotected function getData(): array\n{\n    return [\n        'datasets' => [\n            [\n                'label' => 'Blog posts created',\n                'data' => [0, 10, 5, 2, 21, 32, 45, 74, 65, 45, 77, 89],\n                'backgroundColor' => '#36A2EB',\n                'borderColor' => '#9BD0F5',\n            ],\n        ],\n        'labels' => ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n    ];\n}\n```\n\n## #Generating chart data from an Eloquent model\n\nTo generate chart data from an Eloquent model, Filament recommends that you install the flowframe/laravel-trend package. You can view the documentation.\n\n`flowframe/laravel-trend`Here is an example of generating chart data from a model using the laravel-trend package:\n\n`laravel-trend````\nuse Flowframe\\Trend\\Trend;\nuse Flowframe\\Trend\\TrendValue;\n\nprotected function getData(): array\n{\n    $data = Trend::model(BlogPost::class)\n        ->between(\n            start: now()->startOfYear(),\n            end: now()->endOfYear(),\n        )\n        ->perMonth()\n        ->count();\n\n    return [\n        'datasets' => [\n            [\n                'label' => 'Blog posts',\n                'data' => $data->map(fn (TrendValue $value) => $value->aggregate),\n            ],\n        ],\n        'labels' => $data->map(fn (TrendValue $value) => $value->date),\n    ];\n}\n```\n\n## #Filtering chart data\n\nYou can set up chart filters to change the data shown on chart. Commonly, this is used to change the time period that chart data is rendered for.\n\nTo set a default filter value, set the $filter property:\n\n`$filter````\npublic ?string $filter = 'today';\n```\n\nThen, define the getFilters() method to return an array of values and labels for your filter:\n\n`getFilters()````\nprotected function getFilters(): ?array\n{\n    return [\n        'today' => 'Today',\n        'week' => 'Last week',\n        'month' => 'Last month',\n        'year' => 'This year',\n    ];\n}\n```\n\nYou can use the active filter value within your getData() method:\n\n`getData()````\nprotected function getData(): array\n{\n    $activeFilter = $this->filter;\n\n    // ...\n}\n```\n\n## #Live updating chart data (polling)\n\nBy default, chart widgets refresh their data every 5 seconds.\n\nTo customize this, you may override the $pollingInterval property on the class to a new interval:\n\n`$pollingInterval````\nprotected static ?string $pollingInterval = '10s';\n```\n\nAlternatively, you may disable polling altogether:\n\n```\nprotected static ?string $pollingInterval = null;\n```\n\n## #Setting a maximum chart height\n\nYou may place a maximum height on the chart to ensure that it doesn’t get too big, using the $maxHeight property:\n\n`$maxHeight````\nprotected static ?string $maxHeight = '300px';\n```\n\n## #Setting chart configuration options\n\nYou may specify an $options variable on the chart class to control the many configuration options that the Chart.js library provides. For instance, you could turn off the legend for a line chart:\n\n`$options````\nprotected static ?array $options = [\n    'plugins' => [\n        'legend' => [\n            'display' => false,\n        ],\n    ],\n];\n```\n\nAlternatively, you can override the getOptions() method to return a dynamic array of options:\n\n`getOptions()````\nprotected function getOptions(): array\n{\n    return [\n        'plugins' => [\n            'legend' => [\n                'display' => false,\n            ],\n        ],\n    ];\n}\n```\n\nThese PHP arrays will get transformed into JSON objects when the chart is rendered. If you want to return raw JavaScript from this method instead, you can return a RawJs object. This is useful if you want to use a JavaScript callback function, for example:\n\n`RawJs````\nuse Filament\\Support\\RawJs;\n\nprotected function getOptions(): RawJs\n{\n    return RawJs::make(<<<JS\n        {\n            scales: {\n                y: {\n                    ticks: {\n                        callback: (value) => '€' + value,\n                    },\n                },\n            },\n        }\n    JS);\n}\n```\n\n## #Adding a description\n\nYou may add a description, below the heading of the chart, using the getDescription() method:\n\n`getDescription()````\npublic function getDescription(): ?string\n{\n    return 'The number of blog posts published per month.';\n}\n```\n\n## #Disabling lazy loading\n\nBy default, widgets are lazy-loaded. This means that they will only be loaded when they are visible on the page.\n\nTo disable this behavior, you may override the $isLazy property on the widget class:\n\n`$isLazy````\nprotected static bool $isLazy = true;\n```\n\n## #Using custom Chart.js plugins\n\nChart.js offers a powerful plugin system that allows you to extend its functionality and create custom chart behaviors. This guide details how to use them in a chart widget.\n\n### #Step 1: Install the plugin with NPM\n\nTo start with, install the plugin using NPM into your project. In this guide, we will install chartjs-plugin-datalabels:\n\n`chartjs-plugin-datalabels````\nnpm install chartjs-plugin-datalabels --save-dev\n```\n\n### #Step 2: Create a JavaScript file importing the plugin\n\nCreate a new JavaScript file where you will define your custom plugin. In this guide, we’ll call it filament-chart-js-plugins.js. Import the plugin, and add it to the window.filamentChartJsPlugins array:\n\n`filament-chart-js-plugins.js``window.filamentChartJsPlugins````\nimport ChartDataLabels from 'chartjs-plugin-datalabels'\n\nwindow.filamentChartJsPlugins ??= []\nwindow.filamentChartJsPlugins.push(ChartDataLabels)\n```\n\nIt’s important to initialise the array if it has not been already, before pushing onto it. This ensures that mutliple JavaScript files (especially those from Filament plugins) that register Chart.js plugins do not overwrite each other, regardless of the order they are booted in.\n\nYou can push as many plugins to the filamentChartJsPlugins array as you would like to install, you do not need a separate file to import each plugin.\n\n`filamentChartJsPlugins`### #Step 3: Compile the JavaScript file with Vite\n\nNow, you need to build the JavaScript file with Vite, or your bundler of choice. Include the file in your Vite configuration (usually vite.config.js). For example:\n\n`vite.config.js````\nimport { defineConfig } from 'vite';\nimport laravel from 'laravel-vite-plugin';\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: [\n                'resources/css/app.css',\n                'resources/js/app.js',\n                'resources/css/filament/admin/theme.css',\n                'resources/js/filament-chart-js-plugins.js', // Include the new file in the `input` array so it is built\n            ],\n        }),\n    ],\n});\n```\n\nBuild the file with npm run build.\n\n`npm run build`### #Step 4: Register the JavaScript file in Filament\n\nFilament needs to know to include this JavaScript file when rendering chart widgets. You can do this in the boot() method of a service provider like AppServiceProvider:\n\n`boot()``AppServiceProvider````\nuse Filament\\Support\\Assets\\Js;\nuse Filament\\Support\\Facades\\FilamentAsset;\nuse Illuminate\\Support\\Facades\\Vite;\n\nFilamentAsset::register([\n    Js::make('chart-js-plugins', Vite::asset('resources/js/filament-chart-js-plugins.js'))->module(),\n]);\n```\n\nYou can find out more about asset registration, and even register assets for a specific panel.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Chart widgets - Widgets - Filament",
                "content": "Widgets",
                "level": 1
              },
              {
                "title": "# Chart widgets",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament comes with many “chart” widget templates, which you can use to display real-time, interactive charts.\n\nStart by creating a widget with the command:\n\n```\nphp artisan make:filament-widget BlogPostsChart --chart\n```\n\nThere is a single ChartWidget class that is used for all charts. The type of chart is set by the getType() method. In this example, that method returns the string 'line'.\n\n`ChartWidget``getType()``'line'`The protected static ?string $heading variable is used to set the heading that describes the chart. If you need to set the heading dynamically, you can override the getHeading() method.\n\n`protected static ?string $heading``getHeading()`The getData() method is used to return an array of datasets and labels. Each dataset is a labeled array of points to plot on the chart, and each label is a string. This structure is identical to the Chart.js library, which Filament uses to render charts. You may use the Chart.js documentation to fully understand the possibilities to return from getData(), based on the chart type.\n\n`getData()``getData()````\n<?php\n\nnamespace App\\Filament\\Widgets;\n\nuse Filament\\Widgets\\ChartWidget;\n\nclass BlogPostsChart extends ChartWidget\n{\n    protected static ?string $heading = 'Blog Posts';\n\n    protected function getData(): array\n    {\n        return [\n            'datasets' => [\n                [\n                    'label' => 'Blog posts created',\n                    'data' => [0, 10, 5, 2, 21, 32, 45, 74, 65, 45, 77, 89],\n                ],\n            ],\n            'labels' => ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        ];\n    }\n\n    protected function getType(): string\n    {\n        return 'line';\n    }\n}\n```\n\nNow, check out your widget in the dashboard.",
                "level": 3
              },
              {
                "title": "## #Available chart types",
                "content": "Below is a list of available chart widget classes which you may extend, and their corresponding Chart.js documentation page, for inspiration on what to return from getData():\n\n`getData()`- Bar chart - Chart.js documentation\n- Bubble chart - Chart.js documentation\n- Doughnut chart - Chart.js documentation\n- Line chart - Chart.js documentation\n- Pie chart - Chart.js documentation\n- Polar area chart - Chart.js documentation\n- Radar chart - Chart.js documentation\n- Scatter chart - Chart.js documentation",
                "level": 3
              },
              {
                "title": "## #Customizing the chart color",
                "content": "You can customize the color of the chart data by setting the $color property to either danger, gray, info, primary, success or warning:\n\n`$color``danger``gray``info``primary``success``warning````\nprotected static string $color = 'info';\n```\n\nIf you’re looking to customize the color further, or use multiple colors across multiple datasets, you can still make use of Chart.js’s color options in the data:\n\n```\nprotected function getData(): array\n{\n    return [\n        'datasets' => [\n            [\n                'label' => 'Blog posts created',\n                'data' => [0, 10, 5, 2, 21, 32, 45, 74, 65, 45, 77, 89],\n                'backgroundColor' => '#36A2EB',\n                'borderColor' => '#9BD0F5',\n            ],\n        ],\n        'labels' => ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n    ];\n}\n```",
                "level": 3
              },
              {
                "title": "## #Generating chart data from an Eloquent model",
                "content": "To generate chart data from an Eloquent model, Filament recommends that you install the flowframe/laravel-trend package. You can view the documentation.\n\n`flowframe/laravel-trend`Here is an example of generating chart data from a model using the laravel-trend package:\n\n`laravel-trend````\nuse Flowframe\\Trend\\Trend;\nuse Flowframe\\Trend\\TrendValue;\n\nprotected function getData(): array\n{\n    $data = Trend::model(BlogPost::class)\n        ->between(\n            start: now()->startOfYear(),\n            end: now()->endOfYear(),\n        )\n        ->perMonth()\n        ->count();\n\n    return [\n        'datasets' => [\n            [\n                'label' => 'Blog posts',\n                'data' => $data->map(fn (TrendValue $value) => $value->aggregate),\n            ],\n        ],\n        'labels' => $data->map(fn (TrendValue $value) => $value->date),\n    ];\n}\n```",
                "level": 3
              },
              {
                "title": "## #Filtering chart data",
                "content": "You can set up chart filters to change the data shown on chart. Commonly, this is used to change the time period that chart data is rendered for.\n\nTo set a default filter value, set the $filter property:\n\n`$filter````\npublic ?string $filter = 'today';\n```\n\nThen, define the getFilters() method to return an array of values and labels for your filter:\n\n`getFilters()````\nprotected function getFilters(): ?array\n{\n    return [\n        'today' => 'Today',\n        'week' => 'Last week',\n        'month' => 'Last month',\n        'year' => 'This year',\n    ];\n}\n```\n\nYou can use the active filter value within your getData() method:\n\n`getData()````\nprotected function getData(): array\n{\n    $activeFilter = $this->filter;\n\n    // ...\n}\n```",
                "level": 3
              },
              {
                "title": "## #Live updating chart data (polling)",
                "content": "By default, chart widgets refresh their data every 5 seconds.\n\nTo customize this, you may override the $pollingInterval property on the class to a new interval:\n\n`$pollingInterval````\nprotected static ?string $pollingInterval = '10s';\n```\n\nAlternatively, you may disable polling altogether:\n\n```\nprotected static ?string $pollingInterval = null;\n```",
                "level": 3
              },
              {
                "title": "## #Setting a maximum chart height",
                "content": "You may place a maximum height on the chart to ensure that it doesn’t get too big, using the $maxHeight property:\n\n`$maxHeight````\nprotected static ?string $maxHeight = '300px';\n```",
                "level": 3
              },
              {
                "title": "## #Setting chart configuration options",
                "content": "You may specify an $options variable on the chart class to control the many configuration options that the Chart.js library provides. For instance, you could turn off the legend for a line chart:\n\n`$options````\nprotected static ?array $options = [\n    'plugins' => [\n        'legend' => [\n            'display' => false,\n        ],\n    ],\n];\n```\n\nAlternatively, you can override the getOptions() method to return a dynamic array of options:\n\n`getOptions()````\nprotected function getOptions(): array\n{\n    return [\n        'plugins' => [\n            'legend' => [\n                'display' => false,\n            ],\n        ],\n    ];\n}\n```\n\nThese PHP arrays will get transformed into JSON objects when the chart is rendered. If you want to return raw JavaScript from this method instead, you can return a RawJs object. This is useful if you want to use a JavaScript callback function, for example:\n\n`RawJs````\nuse Filament\\Support\\RawJs;\n\nprotected function getOptions(): RawJs\n{\n    return RawJs::make(<<<JS\n        {\n            scales: {\n                y: {\n                    ticks: {\n                        callback: (value) => '€' + value,\n                    },\n                },\n            },\n        }\n    JS);\n}\n```",
                "level": 3
              },
              {
                "title": "## #Adding a description",
                "content": "You may add a description, below the heading of the chart, using the getDescription() method:\n\n`getDescription()````\npublic function getDescription(): ?string\n{\n    return 'The number of blog posts published per month.';\n}\n```",
                "level": 3
              },
              {
                "title": "## #Disabling lazy loading",
                "content": "By default, widgets are lazy-loaded. This means that they will only be loaded when they are visible on the page.\n\nTo disable this behavior, you may override the $isLazy property on the widget class:\n\n`$isLazy````\nprotected static bool $isLazy = true;\n```",
                "level": 3
              },
              {
                "title": "## #Using custom Chart.js plugins",
                "content": "Chart.js offers a powerful plugin system that allows you to extend its functionality and create custom chart behaviors. This guide details how to use them in a chart widget.",
                "level": 3
              },
              {
                "title": "### #Step 1: Install the plugin with NPM",
                "content": "To start with, install the plugin using NPM into your project. In this guide, we will install chartjs-plugin-datalabels:\n\n`chartjs-plugin-datalabels````\nnpm install chartjs-plugin-datalabels --save-dev\n```",
                "level": 4
              },
              {
                "title": "### #Step 2: Create a JavaScript file importing the plugin",
                "content": "Create a new JavaScript file where you will define your custom plugin. In this guide, we’ll call it filament-chart-js-plugins.js. Import the plugin, and add it to the window.filamentChartJsPlugins array:\n\n`filament-chart-js-plugins.js``window.filamentChartJsPlugins````\nimport ChartDataLabels from 'chartjs-plugin-datalabels'\n\nwindow.filamentChartJsPlugins ??= []\nwindow.filamentChartJsPlugins.push(ChartDataLabels)\n```\n\nIt’s important to initialise the array if it has not been already, before pushing onto it. This ensures that mutliple JavaScript files (especially those from Filament plugins) that register Chart.js plugins do not overwrite each other, regardless of the order they are booted in.\n\nYou can push as many plugins to the filamentChartJsPlugins array as you would like to install, you do not need a separate file to import each plugin.\n\n`filamentChartJsPlugins`### #Step 3: Compile the JavaScript file with Vite\n\nNow, you need to build the JavaScript file with Vite, or your bundler of choice. Include the file in your Vite configuration (usually vite.config.js). For example:\n\n`vite.config.js````\nimport { defineConfig } from 'vite';\nimport laravel from 'laravel-vite-plugin';\n\nexport default defineConfig({\n    plugins: [\n        laravel({\n            input: [\n                'resources/css/app.css',\n                'resources/js/app.js',\n                'resources/css/filament/admin/theme.css',\n                'resources/js/filament-chart-js-plugins.js', // Include the new file in the `input` array so it is built\n            ],\n        }),\n    ],\n});\n```\n\nBuild the file with npm run build.\n\n`npm run build`### #Step 4: Register the JavaScript file in Filament\n\nFilament needs to know to include this JavaScript file when rendering chart widgets. You can do this in the boot() method of a service provider like AppServiceProvider:\n\n`boot()``AppServiceProvider````\nuse Filament\\Support\\Assets\\Js;\nuse Filament\\Support\\Facades\\FilamentAsset;\nuse Illuminate\\Support\\Facades\\Vite;\n\nFilamentAsset::register([\n    Js::make('chart-js-plugins', Vite::asset('resources/js/filament-chart-js-plugins.js'))->module(),\n]);\n```\n\nYou can find out more about asset registration, and even register assets for a specific panel.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Available chart types",
              "Customizing the chart color",
              "Generating chart data from an Eloquent model",
              "Filtering chart data",
              "Live updating chart data (polling)",
              "Setting a maximum chart height",
              "Setting chart configuration options",
              "Adding a description",
              "Disabling lazy loading"
            ],
            "code_examples_count": 40,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "tables": {
          "metadata": {
            "title": "Tables",
            "url": "https://filamentphp.com/docs/3.x/widgets/tables",
            "section": "widgets",
            "word_count": 85,
            "character_count": 472
          },
          "content": {
            "full_text": "\n# Table widgets - Widgets - Filament\n\nWidgets\n\n# Table widgets\n\nWhen using the Panel Builder, you can use table widgets. These use the table builder. You can find out how to create them here.\n\nIf you’re not using the Panel Builder, there’s no need to use a “widget” to render a table. You can simply add a table to a Livewire component, which does not provide any specific benefits over a widget.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Table widgets - Widgets - Filament",
                "content": "Widgets",
                "level": 1
              },
              {
                "title": "# Table widgets",
                "content": "When using the Panel Builder, you can use table widgets. These use the table builder. You can find out how to create them here.\n\nIf you’re not using the Panel Builder, there’s no need to use a “widget” to render a table. You can simply add a table to a Livewire component, which does not provide any specific benefits over a widget.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 1
              }
            ]
          },
          "ai_summary": {
            "main_topics": [],
            "code_examples_count": 0,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "adding-a-widget-to-a-blade-view": {
          "metadata": {
            "title": "Adding A Widget To A Blade View",
            "url": "https://filamentphp.com/docs/3.x/widgets/adding-a-widget-to-a-blade-view",
            "section": "widgets",
            "word_count": 59,
            "character_count": 398
          },
          "content": {
            "full_text": "\n# Adding a widget to a Blade view - Widgets - Filament\n\nWidgets\n\n# Adding a widget to a Blade view\n\n## #Overview\n\nSince widgets are Livewire components, you can easily render a widget in any Blade view using the @livewire directive:\n\n`@livewire````\n<div>\n    @livewire(\\App\\Livewire\\Dashboard\\PostsChart::class)\n</div>\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Adding a widget to a Blade view - Widgets - Filament",
                "content": "Widgets",
                "level": 1
              },
              {
                "title": "# Adding a widget to a Blade view",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Since widgets are Livewire components, you can easily render a widget in any Blade view using the @livewire directive:\n\n`@livewire````\n<div>\n    @livewire(\\App\\Livewire\\Dashboard\\PostsChart::class)\n</div>\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview"
            ],
            "code_examples_count": 2,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        }
      }
    },
    "support": {
      "section_info": {
        "name": "support",
        "page_count": 12,
        "description": "Core concepts, styling, assets, and framework fundamentals"
      },
      "pages": {
        "overview": {
          "metadata": {
            "title": "Overview",
            "url": "https://filamentphp.com/docs/3.x/support/overview",
            "section": "support",
            "word_count": 79,
            "character_count": 490
          },
          "content": {
            "full_text": "\n# Overview - Core Concepts - Filament\n\nCore Concepts\n\n# Overview\n\nThis section of the documentation contains information that applies to all packages in the Filament ecosystem.\n\n## #Eloquent Models\n\nAll of Filament’s database interactions rely on Eloquent. If your application needs to work with a static data source like a plain PHP array, you may find Sushi useful for accessing that data from an Eloquent model.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Overview - Core Concepts - Filament",
                "content": "Core Concepts",
                "level": 1
              },
              {
                "title": "# Overview",
                "content": "This section of the documentation contains information that applies to all packages in the Filament ecosystem.",
                "level": 1
              },
              {
                "title": "## #Eloquent Models",
                "content": "All of Filament’s database interactions rely on Eloquent. If your application needs to work with a static data source like a plain PHP array, you may find Sushi useful for accessing that data from an Eloquent model.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Eloquent Models"
            ],
            "code_examples_count": 0,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "assets": {
          "metadata": {
            "title": "Assets",
            "url": "https://filamentphp.com/docs/3.x/support/assets",
            "section": "support",
            "word_count": 2255,
            "character_count": 17816
          },
          "content": {
            "full_text": "\n# Assets - Core Concepts - Filament\n\nCore Concepts\n\n# Assets\n\n## #Overview\n\nAll packages in the Filament ecosystem share an asset management system. This allows both official plugins and third-party plugins to register CSS and JavaScript files that can then be consumed by Blade views.\n\n## #The FilamentAsset facade\n\n`FilamentAsset`The FilamentAsset facade is used to register files into the asset system. These files may be sourced from anywhere in the filesystem, but are then copied into the /public directory of the application when the php artisan filament:assets command is run. By copying them into the /public directory for you, we can predictably load them in Blade views, and also ensure that third party packages are able to load their assets without having to worry about where they are located.\n\n`FilamentAsset``/public``php artisan filament:assets``/public`Assets always have a unique ID chosen by you, which is used as the file name when the asset is copied into the /public directory. This ID is also used to reference the asset in Blade views. While the ID is unique, if you are registering assets for a plugin, then you do not need to worry about IDs clashing with other plugins, since the asset will be copied into a directory named after your plugin.\n\n`/public`The FilamentAsset facade should be used in the boot() method of a service provider. It can be used inside an application service provider such as AppServiceProvider, or inside a plugin service provider.\n\n`FilamentAsset``boot()``AppServiceProvider`The FilamentAsset facade has one main method, register(), which accepts an array of assets to register:\n\n`FilamentAsset``register()````\nuse Filament\\Support\\Facades\\FilamentAsset;\n\npublic function boot(): void\n{\n    // ...\n    \n    FilamentAsset::register([\n        // ...\n    ]);\n    \n    // ...\n}\n```\n\n### #Registering assets for a plugin\n\nWhen registering assets for a plugin, you should pass the name of the Composer package as the second argument of the register() method:\n\n`register()````\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    // ...\n], package: 'danharrin/filament-blog');\n```\n\nNow, all the assets for this plugin will be copied into their own directory inside /public, to avoid the possibility of clashing with other plugins’ files with the same names.\n\n`/public`## #Registering CSS files\n\nTo register a CSS file with the asset system, use the FilamentAsset::register() method in the boot() method of a service provider. You must pass in an array of Css objects, which each represents a CSS file that should be registered in the asset system.\n\n`FilamentAsset::register()``boot()``Css`Each Css object has a unique ID and a path to the CSS file:\n\n`Css````\nuse Filament\\Support\\Assets\\Css;\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    Css::make('custom-stylesheet', __DIR__ . '/../../resources/css/custom.css'),\n]);\n```\n\nIn this example, we use __DIR__ to generate a relative path to the asset from the current file. For instance, if you were adding this code to /app/Providers/AppServiceProvider.php, then the CSS file should exist in /resources/css/custom.css.\n\n`__DIR__``/app/Providers/AppServiceProvider.php``/resources/css/custom.css`Now, when the php artisan filament:assets command is run, this CSS file is copied into the /public directory. In addition, it is now loaded into all Blade views that use Filament. If you’re interested in only loading the CSS when it is required by an element on the page, check out the Lazy loading CSS section.\n\n`php artisan filament:assets``/public`### #Using Tailwind CSS in plugins\n\nTypically, registering CSS files is used to register custom stylesheets for your application. If you want to process these files using Tailwind CSS, you need to consider the implications of that, especially if you are a plugin developer.\n\nTailwind builds are unique to every application - they contain a minimal set of utility classes, only the ones that you are actually using in your application. This means that if you are a plugin developer, you probably should not be building your Tailwind CSS files into your plugin. Instead, you should provide the raw CSS files and instruct the user that they should build the Tailwind CSS file themselves. To do this, they probably just need to add your vendor directory into the content array of their tailwind.config.js file:\n\n`content``tailwind.config.js````\nexport default {\n    content: [\n        './resources/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n        './vendor/danharrin/filament-blog/resources/views/**/*.blade.php', // Your plugin's vendor directory\n    ],\n    // ...\n}\n```\n\nThis means that when they build their Tailwind CSS file, it will include all the utility classes that are used in your plugin’s views, as well as the utility classes that are used in their application and the Filament core.\n\nHowever, with this technique, there might be extra complications for users who use your plugin with the Panel Builder. If they have a custom theme, they will be fine, since they are building their own CSS file anyway using Tailwind CSS. However, if they are using the default stylesheet which is shipped with the Panel Builder, you might have to be careful about the utility classes that you use in your plugin’s views. For instance, if you use a utility class that is not included in the default stylesheet, the user is not compiling it themselves, and it will not be included in the final CSS file. This means that your plugin’s views might not look as expected. This is one of the few situations where I would recommend compiling and registering a Tailwind CSS-compiled stylesheet in your plugin.\n\n### #Lazy loading CSS\n\nBy default, all CSS files registered with the asset system are loaded in the <head> of every Filament page. This is the simplest way to load CSS files, but sometimes they may be quite heavy and not required on every page. In this case, you can leverage the Alpine.js Lazy Load Assets package that comes bundled with Filament. It allows you to easily load CSS files on-demand using Alpine.js. The premise is very simple, you use the x-load-css directive on an element, and when that element is loaded onto the page, the specified CSS files are loaded into the <head> of the page. This is perfect for both small UI elements and entire pages that require a CSS file:\n\n`<head>``x-load-css``<head>````\n<div\n    x-data=\"{}\"\n    x-load-css=\"[@js(\\Filament\\Support\\Facades\\FilamentAsset::getStyleHref('custom-stylesheet'))]\"\n>\n    <!-- ... -->\n</div>\n```\n\nTo prevent the CSS file from being loaded automatically, you can use the loadedOnRequest() method:\n\n`loadedOnRequest()````\nuse Filament\\Support\\Assets\\Css;\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    Css::make('custom-stylesheet', __DIR__ . '/../../resources/css/custom.css')->loadedOnRequest(),\n]);\n```\n\nIf your CSS file was registered to a plugin, you must pass that in as the second argument to the FilamentAsset::getStyleHref() method:\n\n`FilamentAsset::getStyleHref()````\n<div\n    x-data=\"{}\"\n    x-load-css=\"[@js(\\Filament\\Support\\Facades\\FilamentAsset::getStyleHref('custom-stylesheet', package: 'danharrin/filament-blog'))]\"\n>\n    <!-- ... -->\n</div>\n```\n\n### #Registering CSS files from a URL\n\nIf you want to register a CSS file from a URL, you may do so. These assets will be loaded on every page as normal, but not copied into the /public directory when the php artisan filament:assets command is run. This is useful for registering external stylesheets from a CDN, or stylesheets that you are already compiling directly into the /public directory:\n\n`/public``php artisan filament:assets``/public````\nuse Filament\\Support\\Assets\\Css;\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    Css::make('example-external-stylesheet', 'https://example.com/external.css'),\n    Css::make('example-local-stylesheet', asset('css/local.css')),\n]);\n```\n\n### #Registering CSS variables\n\nSometimes, you may wish to use dynamic data from the backend in CSS files. To do this, you can use the FilamentAsset::registerCssVariables() method in the boot() method of a service provider:\n\n`FilamentAsset::registerCssVariables()``boot()````\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::registerCssVariables([\n    'background-image' => asset('images/background.jpg'),\n]);\n```\n\nNow, you can access these variables from any CSS file:\n\n```\nbackground-image: var(--background-image);\n```\n\n## #Registering JavaScript files\n\nTo register a JavaScript file with the asset system, use the FilamentAsset::register() method in the boot() method of a service provider. You must pass in an array of Js objects, which each represents a JavaScript file that should be registered in the asset system.\n\n`FilamentAsset::register()``boot()``Js`Each Js object has a unique ID and a path to the JavaScript file:\n\n`Js````\nuse Filament\\Support\\Assets\\Js;\n\nFilamentAsset::register([\n    Js::make('custom-script', __DIR__ . '/../../resources/js/custom.js'),\n]);\n```\n\nIn this example, we use __DIR__ to generate a relative path to the asset from the current file. For instance, if you were adding this code to /app/Providers/AppServiceProvider.php, then the JavaScript file should exist in /resources/js/custom.js.\n\n`__DIR__``/app/Providers/AppServiceProvider.php``/resources/js/custom.js`Now, when the php artisan filament:assets command is run, this JavaScript file is copied into the /public directory. In addition, it is now loaded into all Blade views that use Filament. If you’re interested in only loading the JavaScript when it is required by an element on the page, check out the Lazy loading JavaScript section.\n\n`php artisan filament:assets``/public`### #Lazy loading JavaScript\n\nBy default, all JavaScript files registered with the asset system are loaded at the bottom of every Filament page. This is the simplest way to load JavaScript files, but sometimes they may be quite heavy and not required on every page. In this case, you can leverage the Alpine.js Lazy Load Assets package that comes bundled with Filament. It allows you to easily load JavaScript files on-demand using Alpine.js. The premise is very simple, you use the x-load-js directive on an element, and when that element is loaded onto the page, the specified JavaScript files are loaded at the bottom of the page. This is perfect for both small UI elements and entire pages that require a JavaScript file:\n\n`x-load-js````\n<div\n    x-data=\"{}\"\n    x-load-js=\"[@js(\\Filament\\Support\\Facades\\FilamentAsset::getScriptSrc('custom-script'))]\"\n>\n    <!-- ... -->\n</div>\n```\n\nTo prevent the JavaScript file from being loaded automatically, you can use the loadedOnRequest() method:\n\n`loadedOnRequest()````\nuse Filament\\Support\\Assets\\Js;\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    Js::make('custom-script', __DIR__ . '/../../resources/js/custom.js')->loadedOnRequest(),\n]);\n```\n\nIf your JavaScript file was registered to a plugin, you must pass that in as the second argument to the FilamentAsset::getScriptSrc() method:\n\n`FilamentAsset::getScriptSrc()````\n<div\n    x-data=\"{}\"\n    x-load-js=\"[@js(\\Filament\\Support\\Facades\\FilamentAsset::getScriptSrc('custom-script', package: 'danharrin/filament-blog'))]\"\n>\n    <!-- ... -->\n</div>\n```\n\n#### #Asynchronous Alpine.js components\n\nSometimes, you may want to load external JavaScript libraries for your Alpine.js-based components. The best way to do this is by storing the compiled JavaScript and Alpine component in a separate file, and letting us load it whenever the component is rendered.\n\nFirstly, you should install esbuild via NPM, which we will use to create a single JavaScript file containing your external library and Alpine component:\n\n```\nnpm install esbuild --save-dev\n```\n\nThen, you must create a script to compile your JavaScript and Alpine component. You can put this anywhere, for example bin/build.js:\n\n`bin/build.js````\nimport * as esbuild from 'esbuild'\n\nconst isDev = process.argv.includes('--dev')\n\nasync function compile(options) {\n    const context = await esbuild.context(options)\n\n    if (isDev) {\n        await context.watch()\n    } else {\n        await context.rebuild()\n        await context.dispose()\n    }\n}\n\nconst defaultOptions = {\n    define: {\n        'process.env.NODE_ENV': isDev ? `'development'` : `'production'`,\n    },\n    bundle: true,\n    mainFields: ['module', 'main'],\n    platform: 'neutral',\n    sourcemap: isDev ? 'inline' : false,\n    sourcesContent: isDev,\n    treeShaking: true,\n    target: ['es2020'],\n    minify: !isDev,\n    plugins: [{\n        name: 'watchPlugin',\n        setup: function (build) {\n            build.onStart(() => {\n                console.log(`Build started at ${new Date(Date.now()).toLocaleTimeString()}: ${build.initialOptions.outfile}`)\n            })\n\n            build.onEnd((result) => {\n                if (result.errors.length > 0) {\n                    console.log(`Build failed at ${new Date(Date.now()).toLocaleTimeString()}: ${build.initialOptions.outfile}`, result.errors)\n                } else {\n                    console.log(`Build finished at ${new Date(Date.now()).toLocaleTimeString()}: ${build.initialOptions.outfile}`)\n                }\n            })\n        }\n    }],\n}\n\ncompile({\n    ...defaultOptions,\n    entryPoints: ['./resources/js/components/test-component.js'],\n    outfile: './resources/js/dist/components/test-component.js',\n})\n```\n\nAs you can see at the bottom of the script, we are compiling a file called resources/js/components/test-component.js into resources/js/dist/components/test-component.js. You can change these paths to suit your needs. You can compile as many components as you want.\n\n`resources/js/components/test-component.js``resources/js/dist/components/test-component.js`Now, create a new file called resources/js/components/test-component.js:\n\n`resources/js/components/test-component.js````\n// Import any external JavaScript libraries from NPM here.\n\nexport default function testComponent({\n    state,\n}) {\n    return {\n        state,\n        \n        // You can define any other Alpine.js properties here.\n\n        init: function () {\n            // Initialise the Alpine component here, if you need to.\n        },\n        \n        // You can define any other Alpine.js functions here.\n    }\n}\n```\n\nNow, you can compile this file into resources/js/dist/components/test-component.js by running the following command:\n\n`resources/js/dist/components/test-component.js````\nnode bin/build.js\n```\n\nIf you want to watch for changes to this file instead of compiling once, try the following command:\n\n```\nnode bin/build.js --dev\n```\n\nNow, you need to tell Filament to publish this compiled JavaScript file into the /public directory of the Laravel application, so it is accessible to the browser. To do this, you can use the FilamentAsset::register() method in the boot() method of a service provider, passing in an AlpineComponent object:\n\n`/public``FilamentAsset::register()``boot()``AlpineComponent````\nuse Filament\\Support\\Assets\\AlpineComponent;\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    AlpineComponent::make('test-component', __DIR__ . '/../../resources/js/dist/components/test-component.js'),\n]);\n```\n\nWhen you run php artisan filament:assets, the compiled file will be copied into the /public directory.\n\n`php artisan filament:assets``/public`Finally, you can load this asynchronous Alpine component in your view using x-load attributes and the FilamentAsset::getAlpineComponentSrc() method:\n\n`x-load``FilamentAsset::getAlpineComponentSrc()````\n<div\n    x-load\n    x-load-src=\"{{ \\Filament\\Support\\Facades\\FilamentAsset::getAlpineComponentSrc('test-component') }}\"\n    x-data=\"testComponent({\n        state: $wire.{{ $applyStateBindingModifiers(\"\\$entangle('{$statePath}')\") }},\n    })\"\n>\n    <input x-model=\"state\" />\n</div>\n```\n\nThis example is for a custom form field. It passes the state in as a parameter to the testComponent() function, which is entangled with a Livewire component property. You can pass in any parameters you want, and access them in the testComponent() function. If you’re not using a custom form field, you can ignore the state parameter in this example.\n\n`state``testComponent()``testComponent()``state`The x-load attributes come from the Async Alpine package, and any features of that package can be used here.\n\n`x-load`### #Registering script data\n\nSometimes, you may wish to make data from the backend available to JavaScript files. To do this, you can use the FilamentAsset::registerScriptData() method in the boot() method of a service provider:\n\n`FilamentAsset::registerScriptData()``boot()````\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::registerScriptData([\n    'user' => [\n        'name' => auth()->user()?->name,\n    ],\n]);\n```\n\nNow, you can access that data from any JavaScript file at runtime, using the window.filamentData object:\n\n`window.filamentData````\nwindow.filamentData.user.name // 'Dan Harrin'\n```\n\n### #Registering JavaScript files from a URL\n\nIf you want to register a JavaScript file from a URL, you may do so. These assets will be loaded on every page as normal, but not copied into the /public directory when the php artisan filament:assets command is run. This is useful for registering external scripts from a CDN, or scripts that you are already compiling directly into the /public directory:\n\n`/public``php artisan filament:assets``/public````\nuse Filament\\Support\\Assets\\Js;\n\nFilamentAsset::register([\n    Js::make('example-external-script', 'https://example.com/external.js'),\n    Js::make('example-local-script', asset('js/local.js')),\n]);\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Assets - Core Concepts - Filament",
                "content": "Core Concepts",
                "level": 1
              },
              {
                "title": "# Assets",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "All packages in the Filament ecosystem share an asset management system. This allows both official plugins and third-party plugins to register CSS and JavaScript files that can then be consumed by Blade views.",
                "level": 3
              },
              {
                "title": "## #The FilamentAsset facade",
                "content": "`FilamentAsset`The FilamentAsset facade is used to register files into the asset system. These files may be sourced from anywhere in the filesystem, but are then copied into the /public directory of the application when the php artisan filament:assets command is run. By copying them into the /public directory for you, we can predictably load them in Blade views, and also ensure that third party packages are able to load their assets without having to worry about where they are located.\n\n`FilamentAsset``/public``php artisan filament:assets``/public`Assets always have a unique ID chosen by you, which is used as the file name when the asset is copied into the /public directory. This ID is also used to reference the asset in Blade views. While the ID is unique, if you are registering assets for a plugin, then you do not need to worry about IDs clashing with other plugins, since the asset will be copied into a directory named after your plugin.\n\n`/public`The FilamentAsset facade should be used in the boot() method of a service provider. It can be used inside an application service provider such as AppServiceProvider, or inside a plugin service provider.\n\n`FilamentAsset``boot()``AppServiceProvider`The FilamentAsset facade has one main method, register(), which accepts an array of assets to register:\n\n`FilamentAsset``register()````\nuse Filament\\Support\\Facades\\FilamentAsset;\n\npublic function boot(): void\n{\n    // ...\n    \n    FilamentAsset::register([\n        // ...\n    ]);\n    \n    // ...\n}\n```",
                "level": 3
              },
              {
                "title": "### #Registering assets for a plugin",
                "content": "When registering assets for a plugin, you should pass the name of the Composer package as the second argument of the register() method:\n\n`register()````\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    // ...\n], package: 'danharrin/filament-blog');\n```\n\nNow, all the assets for this plugin will be copied into their own directory inside /public, to avoid the possibility of clashing with other plugins’ files with the same names.\n\n`/public`## #Registering CSS files\n\nTo register a CSS file with the asset system, use the FilamentAsset::register() method in the boot() method of a service provider. You must pass in an array of Css objects, which each represents a CSS file that should be registered in the asset system.\n\n`FilamentAsset::register()``boot()``Css`Each Css object has a unique ID and a path to the CSS file:\n\n`Css````\nuse Filament\\Support\\Assets\\Css;\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    Css::make('custom-stylesheet', __DIR__ . '/../../resources/css/custom.css'),\n]);\n```\n\nIn this example, we use __DIR__ to generate a relative path to the asset from the current file. For instance, if you were adding this code to /app/Providers/AppServiceProvider.php, then the CSS file should exist in /resources/css/custom.css.\n\n`__DIR__``/app/Providers/AppServiceProvider.php``/resources/css/custom.css`Now, when the php artisan filament:assets command is run, this CSS file is copied into the /public directory. In addition, it is now loaded into all Blade views that use Filament. If you’re interested in only loading the CSS when it is required by an element on the page, check out the Lazy loading CSS section.\n\n`php artisan filament:assets``/public`### #Using Tailwind CSS in plugins\n\nTypically, registering CSS files is used to register custom stylesheets for your application. If you want to process these files using Tailwind CSS, you need to consider the implications of that, especially if you are a plugin developer.\n\nTailwind builds are unique to every application - they contain a minimal set of utility classes, only the ones that you are actually using in your application. This means that if you are a plugin developer, you probably should not be building your Tailwind CSS files into your plugin. Instead, you should provide the raw CSS files and instruct the user that they should build the Tailwind CSS file themselves. To do this, they probably just need to add your vendor directory into the content array of their tailwind.config.js file:\n\n`content``tailwind.config.js````\nexport default {\n    content: [\n        './resources/**/*.blade.php',\n        './vendor/filament/**/*.blade.php',\n        './vendor/danharrin/filament-blog/resources/views/**/*.blade.php', // Your plugin's vendor directory\n    ],\n    // ...\n}\n```\n\nThis means that when they build their Tailwind CSS file, it will include all the utility classes that are used in your plugin’s views, as well as the utility classes that are used in their application and the Filament core.\n\nHowever, with this technique, there might be extra complications for users who use your plugin with the Panel Builder. If they have a custom theme, they will be fine, since they are building their own CSS file anyway using Tailwind CSS. However, if they are using the default stylesheet which is shipped with the Panel Builder, you might have to be careful about the utility classes that you use in your plugin’s views. For instance, if you use a utility class that is not included in the default stylesheet, the user is not compiling it themselves, and it will not be included in the final CSS file. This means that your plugin’s views might not look as expected. This is one of the few situations where I would recommend compiling and registering a Tailwind CSS-compiled stylesheet in your plugin.",
                "level": 4
              },
              {
                "title": "### #Lazy loading CSS",
                "content": "By default, all CSS files registered with the asset system are loaded in the <head> of every Filament page. This is the simplest way to load CSS files, but sometimes they may be quite heavy and not required on every page. In this case, you can leverage the Alpine.js Lazy Load Assets package that comes bundled with Filament. It allows you to easily load CSS files on-demand using Alpine.js. The premise is very simple, you use the x-load-css directive on an element, and when that element is loaded onto the page, the specified CSS files are loaded into the <head> of the page. This is perfect for both small UI elements and entire pages that require a CSS file:\n\n`<head>``x-load-css``<head>````\n<div\n    x-data=\"{}\"\n    x-load-css=\"[@js(\\Filament\\Support\\Facades\\FilamentAsset::getStyleHref('custom-stylesheet'))]\"\n>\n    <!-- ... -->\n</div>\n```\n\nTo prevent the CSS file from being loaded automatically, you can use the loadedOnRequest() method:\n\n`loadedOnRequest()````\nuse Filament\\Support\\Assets\\Css;\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    Css::make('custom-stylesheet', __DIR__ . '/../../resources/css/custom.css')->loadedOnRequest(),\n]);\n```\n\nIf your CSS file was registered to a plugin, you must pass that in as the second argument to the FilamentAsset::getStyleHref() method:\n\n`FilamentAsset::getStyleHref()````\n<div\n    x-data=\"{}\"\n    x-load-css=\"[@js(\\Filament\\Support\\Facades\\FilamentAsset::getStyleHref('custom-stylesheet', package: 'danharrin/filament-blog'))]\"\n>\n    <!-- ... -->\n</div>\n```",
                "level": 4
              },
              {
                "title": "### #Registering CSS files from a URL",
                "content": "If you want to register a CSS file from a URL, you may do so. These assets will be loaded on every page as normal, but not copied into the /public directory when the php artisan filament:assets command is run. This is useful for registering external stylesheets from a CDN, or stylesheets that you are already compiling directly into the /public directory:\n\n`/public``php artisan filament:assets``/public````\nuse Filament\\Support\\Assets\\Css;\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    Css::make('example-external-stylesheet', 'https://example.com/external.css'),\n    Css::make('example-local-stylesheet', asset('css/local.css')),\n]);\n```",
                "level": 4
              },
              {
                "title": "### #Registering CSS variables",
                "content": "Sometimes, you may wish to use dynamic data from the backend in CSS files. To do this, you can use the FilamentAsset::registerCssVariables() method in the boot() method of a service provider:\n\n`FilamentAsset::registerCssVariables()``boot()````\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::registerCssVariables([\n    'background-image' => asset('images/background.jpg'),\n]);\n```\n\nNow, you can access these variables from any CSS file:\n\n```\nbackground-image: var(--background-image);\n```",
                "level": 4
              },
              {
                "title": "## #Registering JavaScript files",
                "content": "To register a JavaScript file with the asset system, use the FilamentAsset::register() method in the boot() method of a service provider. You must pass in an array of Js objects, which each represents a JavaScript file that should be registered in the asset system.\n\n`FilamentAsset::register()``boot()``Js`Each Js object has a unique ID and a path to the JavaScript file:\n\n`Js````\nuse Filament\\Support\\Assets\\Js;\n\nFilamentAsset::register([\n    Js::make('custom-script', __DIR__ . '/../../resources/js/custom.js'),\n]);\n```\n\nIn this example, we use __DIR__ to generate a relative path to the asset from the current file. For instance, if you were adding this code to /app/Providers/AppServiceProvider.php, then the JavaScript file should exist in /resources/js/custom.js.\n\n`__DIR__``/app/Providers/AppServiceProvider.php``/resources/js/custom.js`Now, when the php artisan filament:assets command is run, this JavaScript file is copied into the /public directory. In addition, it is now loaded into all Blade views that use Filament. If you’re interested in only loading the JavaScript when it is required by an element on the page, check out the Lazy loading JavaScript section.\n\n`php artisan filament:assets``/public`### #Lazy loading JavaScript\n\nBy default, all JavaScript files registered with the asset system are loaded at the bottom of every Filament page. This is the simplest way to load JavaScript files, but sometimes they may be quite heavy and not required on every page. In this case, you can leverage the Alpine.js Lazy Load Assets package that comes bundled with Filament. It allows you to easily load JavaScript files on-demand using Alpine.js. The premise is very simple, you use the x-load-js directive on an element, and when that element is loaded onto the page, the specified JavaScript files are loaded at the bottom of the page. This is perfect for both small UI elements and entire pages that require a JavaScript file:\n\n`x-load-js````\n<div\n    x-data=\"{}\"\n    x-load-js=\"[@js(\\Filament\\Support\\Facades\\FilamentAsset::getScriptSrc('custom-script'))]\"\n>\n    <!-- ... -->\n</div>\n```\n\nTo prevent the JavaScript file from being loaded automatically, you can use the loadedOnRequest() method:\n\n`loadedOnRequest()````\nuse Filament\\Support\\Assets\\Js;\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    Js::make('custom-script', __DIR__ . '/../../resources/js/custom.js')->loadedOnRequest(),\n]);\n```\n\nIf your JavaScript file was registered to a plugin, you must pass that in as the second argument to the FilamentAsset::getScriptSrc() method:\n\n`FilamentAsset::getScriptSrc()````\n<div\n    x-data=\"{}\"\n    x-load-js=\"[@js(\\Filament\\Support\\Facades\\FilamentAsset::getScriptSrc('custom-script', package: 'danharrin/filament-blog'))]\"\n>\n    <!-- ... -->\n</div>\n```",
                "level": 3
              },
              {
                "title": "#### #Asynchronous Alpine.js components",
                "content": "Sometimes, you may want to load external JavaScript libraries for your Alpine.js-based components. The best way to do this is by storing the compiled JavaScript and Alpine component in a separate file, and letting us load it whenever the component is rendered.\n\nFirstly, you should install esbuild via NPM, which we will use to create a single JavaScript file containing your external library and Alpine component:\n\n```\nnpm install esbuild --save-dev\n```\n\nThen, you must create a script to compile your JavaScript and Alpine component. You can put this anywhere, for example bin/build.js:\n\n`bin/build.js````\nimport * as esbuild from 'esbuild'\n\nconst isDev = process.argv.includes('--dev')\n\nasync function compile(options) {\n    const context = await esbuild.context(options)\n\n    if (isDev) {\n        await context.watch()\n    } else {\n        await context.rebuild()\n        await context.dispose()\n    }\n}\n\nconst defaultOptions = {\n    define: {\n        'process.env.NODE_ENV': isDev ? `'development'` : `'production'`,\n    },\n    bundle: true,\n    mainFields: ['module', 'main'],\n    platform: 'neutral',\n    sourcemap: isDev ? 'inline' : false,\n    sourcesContent: isDev,\n    treeShaking: true,\n    target: ['es2020'],\n    minify: !isDev,\n    plugins: [{\n        name: 'watchPlugin',\n        setup: function (build) {\n            build.onStart(() => {\n                console.log(`Build started at ${new Date(Date.now()).toLocaleTimeString()}: ${build.initialOptions.outfile}`)\n            })\n\n            build.onEnd((result) => {\n                if (result.errors.length > 0) {\n                    console.log(`Build failed at ${new Date(Date.now()).toLocaleTimeString()}: ${build.initialOptions.outfile}`, result.errors)\n                } else {\n                    console.log(`Build finished at ${new Date(Date.now()).toLocaleTimeString()}: ${build.initialOptions.outfile}`)\n                }\n            })\n        }\n    }],\n}\n\ncompile({\n    ...defaultOptions,\n    entryPoints: ['./resources/js/components/test-component.js'],\n    outfile: './resources/js/dist/components/test-component.js',\n})\n```\n\nAs you can see at the bottom of the script, we are compiling a file called resources/js/components/test-component.js into resources/js/dist/components/test-component.js. You can change these paths to suit your needs. You can compile as many components as you want.\n\n`resources/js/components/test-component.js``resources/js/dist/components/test-component.js`Now, create a new file called resources/js/components/test-component.js:\n\n`resources/js/components/test-component.js````\n// Import any external JavaScript libraries from NPM here.\n\nexport default function testComponent({\n    state,\n}) {\n    return {\n        state,\n        \n        // You can define any other Alpine.js properties here.\n\n        init: function () {\n            // Initialise the Alpine component here, if you need to.\n        },\n        \n        // You can define any other Alpine.js functions here.\n    }\n}\n```\n\nNow, you can compile this file into resources/js/dist/components/test-component.js by running the following command:\n\n`resources/js/dist/components/test-component.js````\nnode bin/build.js\n```\n\nIf you want to watch for changes to this file instead of compiling once, try the following command:\n\n```\nnode bin/build.js --dev\n```\n\nNow, you need to tell Filament to publish this compiled JavaScript file into the /public directory of the Laravel application, so it is accessible to the browser. To do this, you can use the FilamentAsset::register() method in the boot() method of a service provider, passing in an AlpineComponent object:\n\n`/public``FilamentAsset::register()``boot()``AlpineComponent````\nuse Filament\\Support\\Assets\\AlpineComponent;\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::register([\n    AlpineComponent::make('test-component', __DIR__ . '/../../resources/js/dist/components/test-component.js'),\n]);\n```\n\nWhen you run php artisan filament:assets, the compiled file will be copied into the /public directory.\n\n`php artisan filament:assets``/public`Finally, you can load this asynchronous Alpine component in your view using x-load attributes and the FilamentAsset::getAlpineComponentSrc() method:\n\n`x-load``FilamentAsset::getAlpineComponentSrc()````\n<div\n    x-load\n    x-load-src=\"{{ \\Filament\\Support\\Facades\\FilamentAsset::getAlpineComponentSrc('test-component') }}\"\n    x-data=\"testComponent({\n        state: $wire.{{ $applyStateBindingModifiers(\"\\$entangle('{$statePath}')\") }},\n    })\"\n>\n    <input x-model=\"state\" />\n</div>\n```\n\nThis example is for a custom form field. It passes the state in as a parameter to the testComponent() function, which is entangled with a Livewire component property. You can pass in any parameters you want, and access them in the testComponent() function. If you’re not using a custom form field, you can ignore the state parameter in this example.\n\n`state``testComponent()``testComponent()``state`The x-load attributes come from the Async Alpine package, and any features of that package can be used here.\n\n`x-load`### #Registering script data\n\nSometimes, you may wish to make data from the backend available to JavaScript files. To do this, you can use the FilamentAsset::registerScriptData() method in the boot() method of a service provider:\n\n`FilamentAsset::registerScriptData()``boot()````\nuse Filament\\Support\\Facades\\FilamentAsset;\n\nFilamentAsset::registerScriptData([\n    'user' => [\n        'name' => auth()->user()?->name,\n    ],\n]);\n```\n\nNow, you can access that data from any JavaScript file at runtime, using the window.filamentData object:\n\n`window.filamentData````\nwindow.filamentData.user.name // 'Dan Harrin'\n```",
                "level": 5
              },
              {
                "title": "### #Registering JavaScript files from a URL",
                "content": "If you want to register a JavaScript file from a URL, you may do so. These assets will be loaded on every page as normal, but not copied into the /public directory when the php artisan filament:assets command is run. This is useful for registering external scripts from a CDN, or scripts that you are already compiling directly into the /public directory:\n\n`/public``php artisan filament:assets``/public````\nuse Filament\\Support\\Assets\\Js;\n\nFilamentAsset::register([\n    Js::make('example-external-script', 'https://example.com/external.js'),\n    Js::make('example-local-script', asset('js/local.js')),\n]);\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "The FilamentAsset facade",
              "Registering assets for a plugin",
              "Lazy loading CSS",
              "Registering CSS files from a URL",
              "Registering CSS variables",
              "Registering JavaScript files",
              "Registering JavaScript files from a URL"
            ],
            "code_examples_count": 48,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "icons": {
          "metadata": {
            "title": "Icons",
            "url": "https://filamentphp.com/docs/3.x/support/icons",
            "section": "support",
            "word_count": 2001,
            "character_count": 20725
          },
          "content": {
            "full_text": "\n# Icons - Core Concepts - Filament\n\nCore Concepts\n\n# Icons\n\n## #Overview\n\nIcons are used throughout the entire Filament UI to visually communicate core parts of the user experience. To render icons, we use the Blade Icons package from Blade UI Kit.\n\nThey have a website where you can search all the available icons from various Blade Icons packages. Each package contains a different icon set that you can choose from.\n\n## #Using custom SVGs as icons\n\nThe Blade Icons package allows you to register custom SVGs as icons. This is useful if you want to use your own custom icons in Filament.\n\nTo start with, publish the Blade Icons configuration file:\n\n```\nphp artisan vendor:publish --tag=blade-icons\n```\n\nNow, open the config/blade-icons.php file, and uncomment the default set in the sets array.\n\n`config/blade-icons.php``default``sets`Now that the default set exists in the config file, you can simply put any icons you want inside the resources/svg directory of your application. For example, if you put an SVG file named star.svg inside the resources/svg directory, you can reference it anywhere in Filament as icon-star. The icon- prefix is configurable in the config/blade-icons.php file too. You can also render the custom icon in a Blade view using the @svg('icon-star') directive.\n\n`resources/svg``star.svg``resources/svg``icon-star``icon-``config/blade-icons.php``@svg('icon-star')`## #Replacing the default icons\n\nFilament includes an icon management system that allows you to replace any icons that are used by default in the UI with your own. This happens in the boot() method of any service provider, like AppServiceProvider, or even a dedicated service provider for icons. If you wanted to build a plugin to replace Heroicons with a different set, you could absolutely do that by creating a Laravel package with a similar service provider.\n\n`boot()``AppServiceProvider`To replace an icon, you can use the FilamentIcon facade. It has a register() method, which accepts an array of icons to replace. The key of the array is the unique icon alias that identifies the icon in the Filament UI, and the value is name of a Blade icon to replace it instead. Alternatively, you may use HTML instead of an icon name to render an icon from a Blade view for example:\n\n`FilamentIcon``register()````\nuse Filament\\Support\\Facades\\FilamentIcon;\n\nFilamentIcon::register([\n    'panels::topbar.global-search.field' => 'fas-magnifying-glass',\n    'panels::sidebar.group.collapse-button' => view('icons.chevron-up'),\n]);\n```\n\n### #Allowing users to customize icons from your plugin\n\nIf you have built a Filament plugin, your users may want to be able to customize icons in the same way that they can with any core Filament package. This is possible if you replace any manual @svg() usages with the <x-filament::icon> Blade component. This component allows you to pass in an icon alias, the name of the SVG icon that should be used by default, and any classes or HTML attributes:\n\n`@svg()``<x-filament::icon>````\n<x-filament::icon\n    alias=\"panels::topbar.global-search.field\"\n    icon=\"heroicon-m-magnifying-glass\"\n    wire:target=\"search\"\n    class=\"h-5 w-5 text-gray-500 dark:text-gray-400\"\n/>\n```\n\nAlternatively, you may pass an SVG element into the component’s slot instead of defining a default icon name:\n\n```\n<x-filament::icon\n    alias=\"panels::topbar.global-search.field\"\n    wire:target=\"search\"\n    class=\"h-5 w-5 text-gray-500 dark:text-gray-400\"\n>\n    <svg>\n        <!-- ... -->\n    </svg>\n</x-filament::icon>\n```\n\n## #Available icon aliases\n\n### #Panel Builder icon aliases\n\n- panels::global-search.field - Global search field\n- panels::pages.dashboard.actions.filter - Trigger button of the dashboard filter action\n- panels::pages.dashboard.navigation-item - Dashboard page navigation item\n- panels::pages.password-reset.request-password-reset.actions.login - Trigger button of the login action on the request password reset page\n- panels::pages.password-reset.request-password-reset.actions.login.rtl - Trigger button of the login action on the request password reset page (right-to-left direction)\n- panels::resources.pages.edit-record.navigation-item - Resource edit record page navigation item\n- panels::resources.pages.manage-related-records.navigation-item - Resource manage related records page navigation item\n- panels::resources.pages.view-record.navigation-item - Resource view record page navigation item\n- panels::sidebar.collapse-button - Button to collapse the sidebar\n- panels::sidebar.collapse-button.rtl - Button to collapse the sidebar (right-to-left direction)\n- panels::sidebar.expand-button - Button to expand the sidebar\n- panels::sidebar.expand-button.rtl - Button to expand the sidebar (right-to-left direction)\n- panels::sidebar.group.collapse-button - Collapse button for a sidebar group\n- panels::tenant-menu.billing-button - Billing button in the tenant menu\n- panels::tenant-menu.profile-button - Profile button in the tenant menu\n- panels::tenant-menu.registration-button - Registration button in the tenant menu\n- panels::tenant-menu.toggle-button - Button to toggle the tenant menu\n- panels::theme-switcher.light-button - Button to switch to the light theme from the theme switcher\n- panels::theme-switcher.dark-button - Button to switch to the dark theme from the theme switcher\n- panels::theme-switcher.system-button - Button to switch to the system theme from the theme switcher\n- panels::topbar.close-sidebar-button - Button to close the sidebar\n- panels::topbar.open-sidebar-button - Button to open the sidebar\n- panels::topbar.group.toggle-button - Toggle button for a topbar group\n- panels::topbar.open-database-notifications-button - Button to open the database notifications modal\n- panels::user-menu.profile-item - Profile item in the user menu\n- panels::user-menu.logout-button - Button in the user menu to log out\n- panels::widgets.account.logout-button - Button in the account widget to log out\n- panels::widgets.filament-info.open-documentation-button - Button to open the documentation from the Filament info widget\n- panels::widgets.filament-info.open-github-button - Button to open GitHub from the Filament info widget\n\n`panels::global-search.field``panels::pages.dashboard.actions.filter``panels::pages.dashboard.navigation-item``panels::pages.password-reset.request-password-reset.actions.login``panels::pages.password-reset.request-password-reset.actions.login.rtl``panels::resources.pages.edit-record.navigation-item``panels::resources.pages.manage-related-records.navigation-item``panels::resources.pages.view-record.navigation-item``panels::sidebar.collapse-button``panels::sidebar.collapse-button.rtl``panels::sidebar.expand-button``panels::sidebar.expand-button.rtl``panels::sidebar.group.collapse-button``panels::tenant-menu.billing-button``panels::tenant-menu.profile-button``panels::tenant-menu.registration-button``panels::tenant-menu.toggle-button``panels::theme-switcher.light-button``panels::theme-switcher.dark-button``panels::theme-switcher.system-button``panels::topbar.close-sidebar-button``panels::topbar.open-sidebar-button``panels::topbar.group.toggle-button``panels::topbar.open-database-notifications-button``panels::user-menu.profile-item``panels::user-menu.logout-button``panels::widgets.account.logout-button``panels::widgets.filament-info.open-documentation-button``panels::widgets.filament-info.open-github-button`### #Form Builder icon aliases\n\n- forms::components.builder.actions.clone - Trigger button of a clone action in a builder item\n- forms::components.builder.actions.collapse - Trigger button of a collapse action in a builder item\n- forms::components.builder.actions.delete - Trigger button of a delete action in a builder item\n- forms::components.builder.actions.expand - Trigger button of an expand action in a builder item\n- forms::components.builder.actions.move-down - Trigger button of a move down action in a builder item\n- forms::components.builder.actions.move-up - Trigger button of a move up action in a builder item\n- forms::components.builder.actions.reorder - Trigger button of a reorder action in a builder item\n- forms::components.checkbox-list.search-field - Search input in a checkbox list\n- forms::components.file-upload.editor.actions.drag-crop - Trigger button of a drag crop action in a file upload editor\n- forms::components.file-upload.editor.actions.drag-move - Trigger button of a drag move action in a file upload editor\n- forms::components.file-upload.editor.actions.flip-horizontal - Trigger button of a flip horizontal action in a file upload editor\n- forms::components.file-upload.editor.actions.flip-vertical - Trigger button of a flip vertical action in a file upload editor\n- forms::components.file-upload.editor.actions.move-down - Trigger button of a move down action in a file upload editor\n- forms::components.file-upload.editor.actions.move-left - Trigger button of a move left action in a file upload editor\n- forms::components.file-upload.editor.actions.move-right - Trigger button of a move right action in a file upload editor\n- forms::components.file-upload.editor.actions.move-up - Trigger button of a move up action in a file upload editor\n- forms::components.file-upload.editor.actions.rotate-left - Trigger button of a rotate left action in a file upload editor\n- forms::components.file-upload.editor.actions.rotate-right - Trigger button of a rotate right action in a file upload editor\n- forms::components.file-upload.editor.actions.zoom-100 - Trigger button of a zoom 100 action in a file upload editor\n- forms::components.file-upload.editor.actions.zoom-in - Trigger button of a zoom in action in a file upload editor\n- forms::components.file-upload.editor.actions.zoom-out - Trigger button of a zoom out action in a file upload editor\n- forms::components.key-value.actions.delete - Trigger button of a delete action in a key-value field item\n- forms::components.key-value.actions.reorder - Trigger button of a reorder action in a key-value field item\n- forms::components.repeater.actions.clone - Trigger button of a clone action in a repeater item\n- forms::components.repeater.actions.collapse - Trigger button of a collapse action in a repeater item\n- forms::components.repeater.actions.delete - Trigger button of a delete action in a repeater item\n- forms::components.repeater.actions.expand - Trigger button of an expand action in a repeater item\n- forms::components.repeater.actions.move-down - Trigger button of a move down action in a repeater item\n- forms::components.repeater.actions.move-up - Trigger button of a move up action in a repeater item\n- forms::components.repeater.actions.reorder - Trigger button of a reorder action in a repeater item\n- forms::components.select.actions.create-option - Trigger button of a create option action in a select field\n- forms::components.select.actions.edit-option - Trigger button of an edit option action in a select field\n- forms::components.text-input.actions.hide-password - Trigger button of a hide password action in a text input field\n- forms::components.text-input.actions.show-password - Trigger button of a show password action in a text input field\n- forms::components.toggle-buttons.boolean.false - “False” option of a boolean() toggle buttons field\n- forms::components.toggle-buttons.boolean.true - “True” option of a boolean() toggle buttons field\n- forms::components.wizard.completed-step - Completed step in a wizard\n\n`forms::components.builder.actions.clone``forms::components.builder.actions.collapse``forms::components.builder.actions.delete``forms::components.builder.actions.expand``forms::components.builder.actions.move-down``forms::components.builder.actions.move-up``forms::components.builder.actions.reorder``forms::components.checkbox-list.search-field``forms::components.file-upload.editor.actions.drag-crop``forms::components.file-upload.editor.actions.drag-move``forms::components.file-upload.editor.actions.flip-horizontal``forms::components.file-upload.editor.actions.flip-vertical``forms::components.file-upload.editor.actions.move-down``forms::components.file-upload.editor.actions.move-left``forms::components.file-upload.editor.actions.move-right``forms::components.file-upload.editor.actions.move-up``forms::components.file-upload.editor.actions.rotate-left``forms::components.file-upload.editor.actions.rotate-right``forms::components.file-upload.editor.actions.zoom-100``forms::components.file-upload.editor.actions.zoom-in``forms::components.file-upload.editor.actions.zoom-out``forms::components.key-value.actions.delete``forms::components.key-value.actions.reorder``forms::components.repeater.actions.clone``forms::components.repeater.actions.collapse``forms::components.repeater.actions.delete``forms::components.repeater.actions.expand``forms::components.repeater.actions.move-down``forms::components.repeater.actions.move-up``forms::components.repeater.actions.reorder``forms::components.select.actions.create-option``forms::components.select.actions.edit-option``forms::components.text-input.actions.hide-password``forms::components.text-input.actions.show-password``forms::components.toggle-buttons.boolean.false``boolean()``forms::components.toggle-buttons.boolean.true``boolean()``forms::components.wizard.completed-step`### #Table Builder icon aliases\n\n- tables::actions.disable-reordering - Trigger button of the disable reordering action\n- tables::actions.enable-reordering - Trigger button of the enable reordering action\n- tables::actions.filter - Trigger button of the filter action\n- tables::actions.group - Trigger button of a group records action\n- tables::actions.open-bulk-actions - Trigger button of an open bulk actions action\n- tables::actions.toggle-columns - Trigger button of the toggle columns action\n- tables::columns.collapse-button - Button to collapse a column\n- tables::columns.icon-column.false - Falsy state of an icon column\n- tables::columns.icon-column.true - Truthy state of an icon column\n- tables::empty-state - Empty state icon\n- tables::filters.query-builder.constraints.boolean - Default icon for a boolean constraint in the query builder\n- tables::filters.query-builder.constraints.date - Default icon for a date constraint in the query builder\n- tables::filters.query-builder.constraints.number - Default icon for a number constraint in the query builder\n- tables::filters.query-builder.constraints.relationship - Default icon for a relationship constraint in the query builder\n- tables::filters.query-builder.constraints.select - Default icon for a select constraint in the query builder\n- tables::filters.query-builder.constraints.text - Default icon for a text constraint in the query builder\n- tables::filters.remove-all-button - Button to remove all filters\n- tables::grouping.collapse-button - Button to collapse a group of records\n- tables::header-cell.sort-asc-button - Sort button of a column sorted in ascending order\n- tables::header-cell.sort-button - Sort button of a column when it is currently not sorted\n- tables::header-cell.sort-desc-button - Sort button of a column sorted in descending order\n- tables::reorder.handle - Handle to grab in order to reorder a record with drag and drop\n- tables::search-field - Search input\n\n`tables::actions.disable-reordering``tables::actions.enable-reordering``tables::actions.filter``tables::actions.group``tables::actions.open-bulk-actions``tables::actions.toggle-columns``tables::columns.collapse-button``tables::columns.icon-column.false``tables::columns.icon-column.true``tables::empty-state``tables::filters.query-builder.constraints.boolean``tables::filters.query-builder.constraints.date``tables::filters.query-builder.constraints.number``tables::filters.query-builder.constraints.relationship``tables::filters.query-builder.constraints.select``tables::filters.query-builder.constraints.text``tables::filters.remove-all-button``tables::grouping.collapse-button``tables::header-cell.sort-asc-button``tables::header-cell.sort-button``tables::header-cell.sort-desc-button``tables::reorder.handle``tables::search-field`### #Notifications icon aliases\n\n- notifications::database.modal.empty-state - Empty state of the database notifications modal\n- notifications::notification.close-button - Button to close a notification\n- notifications::notification.danger - Danger notification\n- notifications::notification.info - Info notification\n- notifications::notification.success - Success notification\n- notifications::notification.warning - Warning notification\n\n`notifications::database.modal.empty-state``notifications::notification.close-button``notifications::notification.danger``notifications::notification.info``notifications::notification.success``notifications::notification.warning`### #Actions icon aliases\n\n- actions::action-group - Trigger button of an action group\n- actions::create-action.grouped - Trigger button of a grouped create action\n- actions::delete-action - Trigger button of a delete action\n- actions::delete-action.grouped - Trigger button of a grouped delete action\n- actions::delete-action.modal - Modal of a delete action\n- actions::detach-action - Trigger button of a detach action\n- actions::detach-action.modal - Modal of a detach action\n- actions::dissociate-action - Trigger button of a dissociate action\n- actions::dissociate-action.modal - Modal of a dissociate action\n- actions::edit-action - Trigger button of an edit action\n- actions::edit-action.grouped - Trigger button of a grouped edit action\n- actions::export-action.grouped - Trigger button of a grouped export action\n- actions::force-delete-action - Trigger button of a force delete action\n- actions::force-delete-action.grouped - Trigger button of a grouped force delete action\n- actions::force-delete-action.modal - Modal of a force delete action\n- actions::import-action.grouped - Trigger button of a grouped import action\n- actions::modal.confirmation - Modal of an action that requires confirmation\n- actions::replicate-action - Trigger button of a replicate action\n- actions::replicate-action.grouped - Trigger button of a grouped replicate action\n- actions::restore-action - Trigger button of a restore action\n- actions::restore-action.grouped - Trigger button of a grouped restore action\n- actions::restore-action.modal - Modal of a restore action\n- actions::view-action - Trigger button of a view action\n- actions::view-action.grouped - Trigger button of a grouped view action\n\n`actions::action-group``actions::create-action.grouped``actions::delete-action``actions::delete-action.grouped``actions::delete-action.modal``actions::detach-action``actions::detach-action.modal``actions::dissociate-action``actions::dissociate-action.modal``actions::edit-action``actions::edit-action.grouped``actions::export-action.grouped``actions::force-delete-action``actions::force-delete-action.grouped``actions::force-delete-action.modal``actions::import-action.grouped``actions::modal.confirmation``actions::replicate-action``actions::replicate-action.grouped``actions::restore-action``actions::restore-action.grouped``actions::restore-action.modal``actions::view-action``actions::view-action.grouped`### #Infolist Builder icon aliases\n\n- infolists::components.icon-entry.false - Falsy state of an icon entry\n- infolists::components.icon-entry.true - Truthy state of an icon entry\n\n`infolists::components.icon-entry.false``infolists::components.icon-entry.true`### #UI components icon aliases\n\n- badge.delete-button - Button to delete a badge\n- breadcrumbs.separator - Separator between breadcrumbs\n- breadcrumbs.separator.rtl - Separator between breadcrumbs (right-to-left direction)\n- modal.close-button - Button to close a modal\n- pagination.first-button - Button to go to the first page\n- pagination.first-button.rtl - Button to go to the first page (right-to-left direction)\n- pagination.last-button - Button to go to the last page\n- pagination.last-button.rtl - Button to go to the last page (right-to-left direction)\n- pagination.next-button - Button to go to the next page\n- pagination.next-button.rtl - Button to go to the next page (right-to-left direction)\n- pagination.previous-button - Button to go to the previous page\n- pagination.previous-button.rtl - Button to go to the previous page (right-to-left direction)\n- section.collapse-button - Button to collapse a section\n\n`badge.delete-button``breadcrumbs.separator``breadcrumbs.separator.rtl``modal.close-button``pagination.first-button``pagination.first-button.rtl``pagination.last-button``pagination.last-button.rtl``pagination.next-button``pagination.next-button.rtl``pagination.previous-button``pagination.previous-button.rtl``section.collapse-button`Still need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Icons - Core Concepts - Filament",
                "content": "Core Concepts",
                "level": 1
              },
              {
                "title": "# Icons",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Icons are used throughout the entire Filament UI to visually communicate core parts of the user experience. To render icons, we use the Blade Icons package from Blade UI Kit.\n\nThey have a website where you can search all the available icons from various Blade Icons packages. Each package contains a different icon set that you can choose from.",
                "level": 3
              },
              {
                "title": "## #Using custom SVGs as icons",
                "content": "The Blade Icons package allows you to register custom SVGs as icons. This is useful if you want to use your own custom icons in Filament.\n\nTo start with, publish the Blade Icons configuration file:\n\n```\nphp artisan vendor:publish --tag=blade-icons\n```\n\nNow, open the config/blade-icons.php file, and uncomment the default set in the sets array.\n\n`config/blade-icons.php``default``sets`Now that the default set exists in the config file, you can simply put any icons you want inside the resources/svg directory of your application. For example, if you put an SVG file named star.svg inside the resources/svg directory, you can reference it anywhere in Filament as icon-star. The icon- prefix is configurable in the config/blade-icons.php file too. You can also render the custom icon in a Blade view using the @svg('icon-star') directive.\n\n`resources/svg``star.svg``resources/svg``icon-star``icon-``config/blade-icons.php``@svg('icon-star')`## #Replacing the default icons\n\nFilament includes an icon management system that allows you to replace any icons that are used by default in the UI with your own. This happens in the boot() method of any service provider, like AppServiceProvider, or even a dedicated service provider for icons. If you wanted to build a plugin to replace Heroicons with a different set, you could absolutely do that by creating a Laravel package with a similar service provider.\n\n`boot()``AppServiceProvider`To replace an icon, you can use the FilamentIcon facade. It has a register() method, which accepts an array of icons to replace. The key of the array is the unique icon alias that identifies the icon in the Filament UI, and the value is name of a Blade icon to replace it instead. Alternatively, you may use HTML instead of an icon name to render an icon from a Blade view for example:\n\n`FilamentIcon``register()````\nuse Filament\\Support\\Facades\\FilamentIcon;\n\nFilamentIcon::register([\n    'panels::topbar.global-search.field' => 'fas-magnifying-glass',\n    'panels::sidebar.group.collapse-button' => view('icons.chevron-up'),\n]);\n```",
                "level": 3
              },
              {
                "title": "### #Allowing users to customize icons from your plugin",
                "content": "If you have built a Filament plugin, your users may want to be able to customize icons in the same way that they can with any core Filament package. This is possible if you replace any manual @svg() usages with the <x-filament::icon> Blade component. This component allows you to pass in an icon alias, the name of the SVG icon that should be used by default, and any classes or HTML attributes:\n\n`@svg()``<x-filament::icon>````\n<x-filament::icon\n    alias=\"panels::topbar.global-search.field\"\n    icon=\"heroicon-m-magnifying-glass\"\n    wire:target=\"search\"\n    class=\"h-5 w-5 text-gray-500 dark:text-gray-400\"\n/>\n```\n\nAlternatively, you may pass an SVG element into the component’s slot instead of defining a default icon name:\n\n```\n<x-filament::icon\n    alias=\"panels::topbar.global-search.field\"\n    wire:target=\"search\"\n    class=\"h-5 w-5 text-gray-500 dark:text-gray-400\"\n>\n    <svg>\n        <!-- ... -->\n    </svg>\n</x-filament::icon>\n```",
                "level": 4
              },
              {
                "title": "## #Available icon aliases",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Panel Builder icon aliases",
                "content": "- panels::global-search.field - Global search field\n- panels::pages.dashboard.actions.filter - Trigger button of the dashboard filter action\n- panels::pages.dashboard.navigation-item - Dashboard page navigation item\n- panels::pages.password-reset.request-password-reset.actions.login - Trigger button of the login action on the request password reset page\n- panels::pages.password-reset.request-password-reset.actions.login.rtl - Trigger button of the login action on the request password reset page (right-to-left direction)\n- panels::resources.pages.edit-record.navigation-item - Resource edit record page navigation item\n- panels::resources.pages.manage-related-records.navigation-item - Resource manage related records page navigation item\n- panels::resources.pages.view-record.navigation-item - Resource view record page navigation item\n- panels::sidebar.collapse-button - Button to collapse the sidebar\n- panels::sidebar.collapse-button.rtl - Button to collapse the sidebar (right-to-left direction)\n- panels::sidebar.expand-button - Button to expand the sidebar\n- panels::sidebar.expand-button.rtl - Button to expand the sidebar (right-to-left direction)\n- panels::sidebar.group.collapse-button - Collapse button for a sidebar group\n- panels::tenant-menu.billing-button - Billing button in the tenant menu\n- panels::tenant-menu.profile-button - Profile button in the tenant menu\n- panels::tenant-menu.registration-button - Registration button in the tenant menu\n- panels::tenant-menu.toggle-button - Button to toggle the tenant menu\n- panels::theme-switcher.light-button - Button to switch to the light theme from the theme switcher\n- panels::theme-switcher.dark-button - Button to switch to the dark theme from the theme switcher\n- panels::theme-switcher.system-button - Button to switch to the system theme from the theme switcher\n- panels::topbar.close-sidebar-button - Button to close the sidebar\n- panels::topbar.open-sidebar-button - Button to open the sidebar\n- panels::topbar.group.toggle-button - Toggle button for a topbar group\n- panels::topbar.open-database-notifications-button - Button to open the database notifications modal\n- panels::user-menu.profile-item - Profile item in the user menu\n- panels::user-menu.logout-button - Button in the user menu to log out\n- panels::widgets.account.logout-button - Button in the account widget to log out\n- panels::widgets.filament-info.open-documentation-button - Button to open the documentation from the Filament info widget\n- panels::widgets.filament-info.open-github-button - Button to open GitHub from the Filament info widget\n\n`panels::global-search.field``panels::pages.dashboard.actions.filter``panels::pages.dashboard.navigation-item``panels::pages.password-reset.request-password-reset.actions.login``panels::pages.password-reset.request-password-reset.actions.login.rtl``panels::resources.pages.edit-record.navigation-item``panels::resources.pages.manage-related-records.navigation-item``panels::resources.pages.view-record.navigation-item``panels::sidebar.collapse-button``panels::sidebar.collapse-button.rtl``panels::sidebar.expand-button``panels::sidebar.expand-button.rtl``panels::sidebar.group.collapse-button``panels::tenant-menu.billing-button``panels::tenant-menu.profile-button``panels::tenant-menu.registration-button``panels::tenant-menu.toggle-button``panels::theme-switcher.light-button``panels::theme-switcher.dark-button``panels::theme-switcher.system-button``panels::topbar.close-sidebar-button``panels::topbar.open-sidebar-button``panels::topbar.group.toggle-button``panels::topbar.open-database-notifications-button``panels::user-menu.profile-item``panels::user-menu.logout-button``panels::widgets.account.logout-button``panels::widgets.filament-info.open-documentation-button``panels::widgets.filament-info.open-github-button`### #Form Builder icon aliases\n\n- forms::components.builder.actions.clone - Trigger button of a clone action in a builder item\n- forms::components.builder.actions.collapse - Trigger button of a collapse action in a builder item\n- forms::components.builder.actions.delete - Trigger button of a delete action in a builder item\n- forms::components.builder.actions.expand - Trigger button of an expand action in a builder item\n- forms::components.builder.actions.move-down - Trigger button of a move down action in a builder item\n- forms::components.builder.actions.move-up - Trigger button of a move up action in a builder item\n- forms::components.builder.actions.reorder - Trigger button of a reorder action in a builder item\n- forms::components.checkbox-list.search-field - Search input in a checkbox list\n- forms::components.file-upload.editor.actions.drag-crop - Trigger button of a drag crop action in a file upload editor\n- forms::components.file-upload.editor.actions.drag-move - Trigger button of a drag move action in a file upload editor\n- forms::components.file-upload.editor.actions.flip-horizontal - Trigger button of a flip horizontal action in a file upload editor\n- forms::components.file-upload.editor.actions.flip-vertical - Trigger button of a flip vertical action in a file upload editor\n- forms::components.file-upload.editor.actions.move-down - Trigger button of a move down action in a file upload editor\n- forms::components.file-upload.editor.actions.move-left - Trigger button of a move left action in a file upload editor\n- forms::components.file-upload.editor.actions.move-right - Trigger button of a move right action in a file upload editor\n- forms::components.file-upload.editor.actions.move-up - Trigger button of a move up action in a file upload editor\n- forms::components.file-upload.editor.actions.rotate-left - Trigger button of a rotate left action in a file upload editor\n- forms::components.file-upload.editor.actions.rotate-right - Trigger button of a rotate right action in a file upload editor\n- forms::components.file-upload.editor.actions.zoom-100 - Trigger button of a zoom 100 action in a file upload editor\n- forms::components.file-upload.editor.actions.zoom-in - Trigger button of a zoom in action in a file upload editor\n- forms::components.file-upload.editor.actions.zoom-out - Trigger button of a zoom out action in a file upload editor\n- forms::components.key-value.actions.delete - Trigger button of a delete action in a key-value field item\n- forms::components.key-value.actions.reorder - Trigger button of a reorder action in a key-value field item\n- forms::components.repeater.actions.clone - Trigger button of a clone action in a repeater item\n- forms::components.repeater.actions.collapse - Trigger button of a collapse action in a repeater item\n- forms::components.repeater.actions.delete - Trigger button of a delete action in a repeater item\n- forms::components.repeater.actions.expand - Trigger button of an expand action in a repeater item\n- forms::components.repeater.actions.move-down - Trigger button of a move down action in a repeater item\n- forms::components.repeater.actions.move-up - Trigger button of a move up action in a repeater item\n- forms::components.repeater.actions.reorder - Trigger button of a reorder action in a repeater item\n- forms::components.select.actions.create-option - Trigger button of a create option action in a select field\n- forms::components.select.actions.edit-option - Trigger button of an edit option action in a select field\n- forms::components.text-input.actions.hide-password - Trigger button of a hide password action in a text input field\n- forms::components.text-input.actions.show-password - Trigger button of a show password action in a text input field\n- forms::components.toggle-buttons.boolean.false - “False” option of a boolean() toggle buttons field\n- forms::components.toggle-buttons.boolean.true - “True” option of a boolean() toggle buttons field\n- forms::components.wizard.completed-step - Completed step in a wizard\n\n`forms::components.builder.actions.clone``forms::components.builder.actions.collapse``forms::components.builder.actions.delete``forms::components.builder.actions.expand``forms::components.builder.actions.move-down``forms::components.builder.actions.move-up``forms::components.builder.actions.reorder``forms::components.checkbox-list.search-field``forms::components.file-upload.editor.actions.drag-crop``forms::components.file-upload.editor.actions.drag-move``forms::components.file-upload.editor.actions.flip-horizontal``forms::components.file-upload.editor.actions.flip-vertical``forms::components.file-upload.editor.actions.move-down``forms::components.file-upload.editor.actions.move-left``forms::components.file-upload.editor.actions.move-right``forms::components.file-upload.editor.actions.move-up``forms::components.file-upload.editor.actions.rotate-left``forms::components.file-upload.editor.actions.rotate-right``forms::components.file-upload.editor.actions.zoom-100``forms::components.file-upload.editor.actions.zoom-in``forms::components.file-upload.editor.actions.zoom-out``forms::components.key-value.actions.delete``forms::components.key-value.actions.reorder``forms::components.repeater.actions.clone``forms::components.repeater.actions.collapse``forms::components.repeater.actions.delete``forms::components.repeater.actions.expand``forms::components.repeater.actions.move-down``forms::components.repeater.actions.move-up``forms::components.repeater.actions.reorder``forms::components.select.actions.create-option``forms::components.select.actions.edit-option``forms::components.text-input.actions.hide-password``forms::components.text-input.actions.show-password``forms::components.toggle-buttons.boolean.false``boolean()``forms::components.toggle-buttons.boolean.true``boolean()``forms::components.wizard.completed-step`### #Table Builder icon aliases\n\n- tables::actions.disable-reordering - Trigger button of the disable reordering action\n- tables::actions.enable-reordering - Trigger button of the enable reordering action\n- tables::actions.filter - Trigger button of the filter action\n- tables::actions.group - Trigger button of a group records action\n- tables::actions.open-bulk-actions - Trigger button of an open bulk actions action\n- tables::actions.toggle-columns - Trigger button of the toggle columns action\n- tables::columns.collapse-button - Button to collapse a column\n- tables::columns.icon-column.false - Falsy state of an icon column\n- tables::columns.icon-column.true - Truthy state of an icon column\n- tables::empty-state - Empty state icon\n- tables::filters.query-builder.constraints.boolean - Default icon for a boolean constraint in the query builder\n- tables::filters.query-builder.constraints.date - Default icon for a date constraint in the query builder\n- tables::filters.query-builder.constraints.number - Default icon for a number constraint in the query builder\n- tables::filters.query-builder.constraints.relationship - Default icon for a relationship constraint in the query builder\n- tables::filters.query-builder.constraints.select - Default icon for a select constraint in the query builder\n- tables::filters.query-builder.constraints.text - Default icon for a text constraint in the query builder\n- tables::filters.remove-all-button - Button to remove all filters\n- tables::grouping.collapse-button - Button to collapse a group of records\n- tables::header-cell.sort-asc-button - Sort button of a column sorted in ascending order\n- tables::header-cell.sort-button - Sort button of a column when it is currently not sorted\n- tables::header-cell.sort-desc-button - Sort button of a column sorted in descending order\n- tables::reorder.handle - Handle to grab in order to reorder a record with drag and drop\n- tables::search-field - Search input\n\n`tables::actions.disable-reordering``tables::actions.enable-reordering``tables::actions.filter``tables::actions.group``tables::actions.open-bulk-actions``tables::actions.toggle-columns``tables::columns.collapse-button``tables::columns.icon-column.false``tables::columns.icon-column.true``tables::empty-state``tables::filters.query-builder.constraints.boolean``tables::filters.query-builder.constraints.date``tables::filters.query-builder.constraints.number``tables::filters.query-builder.constraints.relationship``tables::filters.query-builder.constraints.select``tables::filters.query-builder.constraints.text``tables::filters.remove-all-button``tables::grouping.collapse-button``tables::header-cell.sort-asc-button``tables::header-cell.sort-button``tables::header-cell.sort-desc-button``tables::reorder.handle``tables::search-field`### #Notifications icon aliases\n\n- notifications::database.modal.empty-state - Empty state of the database notifications modal\n- notifications::notification.close-button - Button to close a notification\n- notifications::notification.danger - Danger notification\n- notifications::notification.info - Info notification\n- notifications::notification.success - Success notification\n- notifications::notification.warning - Warning notification\n\n`notifications::database.modal.empty-state``notifications::notification.close-button``notifications::notification.danger``notifications::notification.info``notifications::notification.success``notifications::notification.warning`### #Actions icon aliases\n\n- actions::action-group - Trigger button of an action group\n- actions::create-action.grouped - Trigger button of a grouped create action\n- actions::delete-action - Trigger button of a delete action\n- actions::delete-action.grouped - Trigger button of a grouped delete action\n- actions::delete-action.modal - Modal of a delete action\n- actions::detach-action - Trigger button of a detach action\n- actions::detach-action.modal - Modal of a detach action\n- actions::dissociate-action - Trigger button of a dissociate action\n- actions::dissociate-action.modal - Modal of a dissociate action\n- actions::edit-action - Trigger button of an edit action\n- actions::edit-action.grouped - Trigger button of a grouped edit action\n- actions::export-action.grouped - Trigger button of a grouped export action\n- actions::force-delete-action - Trigger button of a force delete action\n- actions::force-delete-action.grouped - Trigger button of a grouped force delete action\n- actions::force-delete-action.modal - Modal of a force delete action\n- actions::import-action.grouped - Trigger button of a grouped import action\n- actions::modal.confirmation - Modal of an action that requires confirmation\n- actions::replicate-action - Trigger button of a replicate action\n- actions::replicate-action.grouped - Trigger button of a grouped replicate action\n- actions::restore-action - Trigger button of a restore action\n- actions::restore-action.grouped - Trigger button of a grouped restore action\n- actions::restore-action.modal - Modal of a restore action\n- actions::view-action - Trigger button of a view action\n- actions::view-action.grouped - Trigger button of a grouped view action\n\n`actions::action-group``actions::create-action.grouped``actions::delete-action``actions::delete-action.grouped``actions::delete-action.modal``actions::detach-action``actions::detach-action.modal``actions::dissociate-action``actions::dissociate-action.modal``actions::edit-action``actions::edit-action.grouped``actions::export-action.grouped``actions::force-delete-action``actions::force-delete-action.grouped``actions::force-delete-action.modal``actions::import-action.grouped``actions::modal.confirmation``actions::replicate-action``actions::replicate-action.grouped``actions::restore-action``actions::restore-action.grouped``actions::restore-action.modal``actions::view-action``actions::view-action.grouped`### #Infolist Builder icon aliases\n\n- infolists::components.icon-entry.false - Falsy state of an icon entry\n- infolists::components.icon-entry.true - Truthy state of an icon entry\n\n`infolists::components.icon-entry.false``infolists::components.icon-entry.true`### #UI components icon aliases\n\n- badge.delete-button - Button to delete a badge\n- breadcrumbs.separator - Separator between breadcrumbs\n- breadcrumbs.separator.rtl - Separator between breadcrumbs (right-to-left direction)\n- modal.close-button - Button to close a modal\n- pagination.first-button - Button to go to the first page\n- pagination.first-button.rtl - Button to go to the first page (right-to-left direction)\n- pagination.last-button - Button to go to the last page\n- pagination.last-button.rtl - Button to go to the last page (right-to-left direction)\n- pagination.next-button - Button to go to the next page\n- pagination.next-button.rtl - Button to go to the next page (right-to-left direction)\n- pagination.previous-button - Button to go to the previous page\n- pagination.previous-button.rtl - Button to go to the previous page (right-to-left direction)\n- section.collapse-button - Button to collapse a section\n\n`badge.delete-button``breadcrumbs.separator``breadcrumbs.separator.rtl``modal.close-button``pagination.first-button``pagination.first-button.rtl``pagination.last-button``pagination.last-button.rtl``pagination.next-button``pagination.next-button.rtl``pagination.previous-button``pagination.previous-button.rtl``section.collapse-button`Still need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Using custom SVGs as icons",
              "Allowing users to customize icons from your plugin",
              "Available icon aliases",
              "Panel Builder icon aliases"
            ],
            "code_examples_count": 8,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "colors": {
          "metadata": {
            "title": "Colors",
            "url": "https://filamentphp.com/docs/3.x/support/colors",
            "section": "support",
            "word_count": 398,
            "character_count": 2960
          },
          "content": {
            "full_text": "\n# Colors - Core Concepts - Filament\n\nCore Concepts\n\n# Colors\n\n## #Overview\n\nFilament uses CSS variables to define its color palette. These CSS variables are mapped to Tailwind classes in the preset file that you load when installing Filament.\n\n## #Customizing the default colors\n\nFrom a service provider’s boot() method, or middleware, you can call the FilamentColor::register() method, which you can use to customize which colors Filament uses for UI elements.\n\n`boot()``FilamentColor::register()`There are 6 default colors that are used throughout Filament that you are able to customize:\n\n```\nuse Filament\\Support\\Colors\\Color;\nuse Filament\\Support\\Facades\\FilamentColor;\n\nFilamentColor::register([\n    'danger' => Color::Red,\n    'gray' => Color::Zinc,\n    'info' => Color::Blue,\n    'primary' => Color::Amber,\n    'success' => Color::Green,\n    'warning' => Color::Amber,\n]);\n```\n\nThe Color class contains every Tailwind CSS color to choose from.\n\n`Color`You can also pass in a function to register() which will only get called when the app is getting rendered. This is useful if you are calling register() from a service provider, and want to access objects like the currently authenticated user, which are initialized later in middleware.\n\n`register()``register()`## #Using a non-Tailwind color\n\nYou can use custom colors that are not included in the Tailwind CSS color palette by passing an array of color shades from 50 to 950 in RGB format:\n\n`50``950````\nuse Filament\\Support\\Facades\\FilamentColor;\n\nFilamentColor::register([\n    'danger' => [\n        50 => '254, 242, 242',\n        100 => '254, 226, 226',\n        200 => '254, 202, 202',\n        300 => '252, 165, 165',\n        400 => '248, 113, 113',\n        500 => '239, 68, 68',\n        600 => '220, 38, 38',\n        700 => '185, 28, 28',\n        800 => '153, 27, 27',\n        900 => '127, 29, 29',\n        950 => '69, 10, 10',\n    ],\n]);\n```\n\n### #Generating a custom color from a hex code\n\nYou can use the Color::hex() method to generate a custom color palette from a hex code:\n\n`Color::hex()````\nuse Filament\\Support\\Colors\\Color;\nuse Filament\\Support\\Facades\\FilamentColor;\n\nFilamentColor::register([\n    'danger' => Color::hex('#ff0000'),\n]);\n```\n\n### #Generating a custom color from an RGB value\n\nYou can use the Color::rgb() method to generate a custom color palette from an RGB value:\n\n`Color::rgb()````\nuse Filament\\Support\\Colors\\Color;\nuse Filament\\Support\\Facades\\FilamentColor;\n\nFilamentColor::register([\n    'danger' => Color::rgb('rgb(255, 0, 0)'),\n]);\n```\n\n## #Registering extra colors\n\nYou can register extra colors that you can use throughout Filament:\n\n```\nuse Filament\\Support\\Colors\\Color;\nuse Filament\\Support\\Facades\\FilamentColor;\n\nFilamentColor::register([\n    'indigo' => Color::Indigo,\n]);\n```\n\nNow, you can use this color anywhere you would normally add primary, danger, etc.\n\n`primary``danger`Still need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Colors - Core Concepts - Filament",
                "content": "Core Concepts",
                "level": 1
              },
              {
                "title": "# Colors",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament uses CSS variables to define its color palette. These CSS variables are mapped to Tailwind classes in the preset file that you load when installing Filament.",
                "level": 3
              },
              {
                "title": "## #Customizing the default colors",
                "content": "From a service provider’s boot() method, or middleware, you can call the FilamentColor::register() method, which you can use to customize which colors Filament uses for UI elements.\n\n`boot()``FilamentColor::register()`There are 6 default colors that are used throughout Filament that you are able to customize:\n\n```\nuse Filament\\Support\\Colors\\Color;\nuse Filament\\Support\\Facades\\FilamentColor;\n\nFilamentColor::register([\n    'danger' => Color::Red,\n    'gray' => Color::Zinc,\n    'info' => Color::Blue,\n    'primary' => Color::Amber,\n    'success' => Color::Green,\n    'warning' => Color::Amber,\n]);\n```\n\nThe Color class contains every Tailwind CSS color to choose from.\n\n`Color`You can also pass in a function to register() which will only get called when the app is getting rendered. This is useful if you are calling register() from a service provider, and want to access objects like the currently authenticated user, which are initialized later in middleware.\n\n`register()``register()`## #Using a non-Tailwind color\n\nYou can use custom colors that are not included in the Tailwind CSS color palette by passing an array of color shades from 50 to 950 in RGB format:\n\n`50``950````\nuse Filament\\Support\\Facades\\FilamentColor;\n\nFilamentColor::register([\n    'danger' => [\n        50 => '254, 242, 242',\n        100 => '254, 226, 226',\n        200 => '254, 202, 202',\n        300 => '252, 165, 165',\n        400 => '248, 113, 113',\n        500 => '239, 68, 68',\n        600 => '220, 38, 38',\n        700 => '185, 28, 28',\n        800 => '153, 27, 27',\n        900 => '127, 29, 29',\n        950 => '69, 10, 10',\n    ],\n]);\n```",
                "level": 3
              },
              {
                "title": "### #Generating a custom color from a hex code",
                "content": "You can use the Color::hex() method to generate a custom color palette from a hex code:\n\n`Color::hex()````\nuse Filament\\Support\\Colors\\Color;\nuse Filament\\Support\\Facades\\FilamentColor;\n\nFilamentColor::register([\n    'danger' => Color::hex('#ff0000'),\n]);\n```",
                "level": 4
              },
              {
                "title": "### #Generating a custom color from an RGB value",
                "content": "You can use the Color::rgb() method to generate a custom color palette from an RGB value:\n\n`Color::rgb()````\nuse Filament\\Support\\Colors\\Color;\nuse Filament\\Support\\Facades\\FilamentColor;\n\nFilamentColor::register([\n    'danger' => Color::rgb('rgb(255, 0, 0)'),\n]);\n```",
                "level": 4
              },
              {
                "title": "## #Registering extra colors",
                "content": "You can register extra colors that you can use throughout Filament:\n\n```\nuse Filament\\Support\\Colors\\Color;\nuse Filament\\Support\\Facades\\FilamentColor;\n\nFilamentColor::register([\n    'indigo' => Color::Indigo,\n]);\n```\n\nNow, you can use this color anywhere you would normally add primary, danger, etc.\n\n`primary``danger`Still need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Customizing the default colors",
              "Generating a custom color from a hex code",
              "Generating a custom color from an RGB value",
              "Registering extra colors"
            ],
            "code_examples_count": 10,
            "has_installation_info": true,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "style-customization": {
          "metadata": {
            "title": "Style Customization",
            "url": "https://filamentphp.com/docs/3.x/support/style-customization",
            "section": "support",
            "word_count": 593,
            "character_count": 3673
          },
          "content": {
            "full_text": "\n# Style customization - Core Concepts - Filament\n\nCore Concepts\n\n# Style customization\n\n## #Overview\n\nFilament uses CSS “hook” classes to allow various HTML elements to be customized using CSS.\n\n## #Discovering hook classes\n\nWe could document all the hook classes across the entire Filament UI, but that would be a lot of work, and probably not very useful to you. Instead, we recommend using your browser’s developer tools to inspect the elements you want to customize, and then use the hook classes to target those elements.\n\nAll hook classes are prefixed with fi-, which is a great way to identify them. They are usually right at the start of the class list, so they are easy to find, but sometimes they may fall further down the list if we have to apply them conditionally with JavaScript or Blade.\n\n`fi-`If you don’t find a hook class you’re looking for, try not to hack around it, as it might expose your styling customizations to breaking changes in future releases. Instead, please open a pull request to add the hook class you need. We can help you maintain naming consistency. You probably don’t even need to pull down the Filament repository locally for these pull requests, as you can just edit the Blade files directly on GitHub.\n\n## #Applying styles to hook classes\n\nFor example, if you want to customize the color of the sidebar, you can inspect the sidebar element in your browser’s developer tools, see that it uses the fi-sidebar, and then add CSS to your app like this:\n\n`fi-sidebar````\n.fi-sidebar {\n    background-color: #fafafa;\n}\n```\n\nAlternatively, since Filament is built upon Tailwind CSS, you can use their @apply directive to apply Tailwind classes to Filament elements:\n\n`@apply````\n.fi-sidebar {\n    @apply bg-gray-50 dark:bg-gray-950;\n}\n```\n\nOccasionally, you may need to use the !important modifier to override existing styles, but please use this sparingly, as it can make your styles difficult to maintain:\n\n`!important````\n.fi-sidebar {\n    @apply bg-gray-50 dark:bg-gray-950 !important;\n}\n```\n\nYou can even apply !important to only specific Tailwind classes, which is a little less intrusive, by prefixing the class name with !:\n\n`!important``!````\n.fi-sidebar {\n    @apply !bg-gray-50 dark:!bg-gray-950;\n}\n```\n\n## #Common hook class abbreviations\n\nWe use a few common abbreviations in our hook classes to keep them short and readable:\n\n- fi is short for “Filament”\n- fi-ac is used to represent classes used in the Actions package\n- fi-fo is used to represent classes used in the Form Builder package\n- fi-in is used to represent classes used in the Infolist Builder package\n- fi-no is used to represent classes used in the Notifications package\n- fi-ta is used to represent classes used in the Table Builder package\n- fi-wi is used to represent classes used in the Widgets package\n- btn is short for “button”\n- col is short for “column”\n- ctn is short for “container”\n- wrp is short for “wrapper”\n\n`fi``fi-ac``fi-fo``fi-in``fi-no``fi-ta``fi-wi``btn``col``ctn``wrp`## #Publishing Blade views\n\nYou may be tempted to publish the internal Blade views to your application so that you can customize them. We don’t recommend this, as it will introduce breaking changes into your application in future updates. Please use the CSS hook classes wherever possible.\n\nIf you do decide to publish the Blade views, please lock all Filament packages to a specific version in your composer.json file, and then update Filament manually by bumping this number, testing your entire application after each update. This will help you identify breaking changes safely.\n\n`composer.json`Still need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Style customization - Core Concepts - Filament",
                "content": "Core Concepts",
                "level": 1
              },
              {
                "title": "# Style customization",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament uses CSS “hook” classes to allow various HTML elements to be customized using CSS.",
                "level": 3
              },
              {
                "title": "## #Discovering hook classes",
                "content": "We could document all the hook classes across the entire Filament UI, but that would be a lot of work, and probably not very useful to you. Instead, we recommend using your browser’s developer tools to inspect the elements you want to customize, and then use the hook classes to target those elements.\n\nAll hook classes are prefixed with fi-, which is a great way to identify them. They are usually right at the start of the class list, so they are easy to find, but sometimes they may fall further down the list if we have to apply them conditionally with JavaScript or Blade.\n\n`fi-`If you don’t find a hook class you’re looking for, try not to hack around it, as it might expose your styling customizations to breaking changes in future releases. Instead, please open a pull request to add the hook class you need. We can help you maintain naming consistency. You probably don’t even need to pull down the Filament repository locally for these pull requests, as you can just edit the Blade files directly on GitHub.",
                "level": 3
              },
              {
                "title": "## #Applying styles to hook classes",
                "content": "For example, if you want to customize the color of the sidebar, you can inspect the sidebar element in your browser’s developer tools, see that it uses the fi-sidebar, and then add CSS to your app like this:\n\n`fi-sidebar````\n.fi-sidebar {\n    background-color: #fafafa;\n}\n```\n\nAlternatively, since Filament is built upon Tailwind CSS, you can use their @apply directive to apply Tailwind classes to Filament elements:\n\n`@apply````\n.fi-sidebar {\n    @apply bg-gray-50 dark:bg-gray-950;\n}\n```\n\nOccasionally, you may need to use the !important modifier to override existing styles, but please use this sparingly, as it can make your styles difficult to maintain:\n\n`!important````\n.fi-sidebar {\n    @apply bg-gray-50 dark:bg-gray-950 !important;\n}\n```\n\nYou can even apply !important to only specific Tailwind classes, which is a little less intrusive, by prefixing the class name with !:\n\n`!important``!````\n.fi-sidebar {\n    @apply !bg-gray-50 dark:!bg-gray-950;\n}\n```",
                "level": 3
              },
              {
                "title": "## #Common hook class abbreviations",
                "content": "We use a few common abbreviations in our hook classes to keep them short and readable:\n\n- fi is short for “Filament”\n- fi-ac is used to represent classes used in the Actions package\n- fi-fo is used to represent classes used in the Form Builder package\n- fi-in is used to represent classes used in the Infolist Builder package\n- fi-no is used to represent classes used in the Notifications package\n- fi-ta is used to represent classes used in the Table Builder package\n- fi-wi is used to represent classes used in the Widgets package\n- btn is short for “button”\n- col is short for “column”\n- ctn is short for “container”\n- wrp is short for “wrapper”\n\n`fi``fi-ac``fi-fo``fi-in``fi-no``fi-ta``fi-wi``btn``col``ctn``wrp`## #Publishing Blade views\n\nYou may be tempted to publish the internal Blade views to your application so that you can customize them. We don’t recommend this, as it will introduce breaking changes into your application in future updates. Please use the CSS hook classes wherever possible.\n\nIf you do decide to publish the Blade views, please lock all Filament packages to a specific version in your composer.json file, and then update Filament manually by bumping this number, testing your entire application after each update. This will help you identify breaking changes safely.\n\n`composer.json`Still need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Discovering hook classes",
              "Applying styles to hook classes",
              "Common hook class abbreviations"
            ],
            "code_examples_count": 8,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "render-hooks": {
          "metadata": {
            "title": "Render Hooks",
            "url": "https://filamentphp.com/docs/3.x/support/render-hooks",
            "section": "support",
            "word_count": 1592,
            "character_count": 16974
          },
          "content": {
            "full_text": "\n# Render hooks - Core Concepts - Filament\n\nCore Concepts\n\n# Render hooks\n\n## #Overview\n\nFilament allows you to render Blade content at various points in the frameworks views. It’s useful for plugins to be able to inject HTML into the framework. Also, since Filament does not recommend publishing the views due to an increased risk of breaking changes, it’s also useful for users.\n\n## #Registering render hooks\n\nTo register render hooks, you can call FilamentView::registerRenderHook() from a service provider or middleware. The first argument is the name of the render hook, and the second argument is a callback that returns the content to be rendered:\n\n`FilamentView::registerRenderHook()````\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\nuse Illuminate\\Support\\Facades\\Blade;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::BODY_START,\n    fn (): string => Blade::render('@livewire(\\'livewire-ui-modal\\')'),\n);\n```\n\nYou could also render view content from a file:\n\n```\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\nuse Illuminate\\Contracts\\View\\View;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::BODY_START,\n    fn (): View => view('impersonation-banner'),\n);\n```\n\n## #Available render hooks\n\n### #Panel Builder render hooks\n\n```\nuse Filament\\View\\PanelsRenderHook;\n```\n\n- PanelsRenderHook::AUTH_LOGIN_FORM_AFTER - After login form\n- PanelsRenderHook::AUTH_LOGIN_FORM_BEFORE - Before login form\n- PanelsRenderHook::AUTH_PASSWORD_RESET_REQUEST_FORM_AFTER - After password reset request form\n- PanelsRenderHook::AUTH_PASSWORD_RESET_REQUEST_FORM_BEFORE - Before password reset request form\n- PanelsRenderHook::AUTH_PASSWORD_RESET_RESET_FORM_AFTER - After password reset form\n- PanelsRenderHook::AUTH_PASSWORD_RESET_RESET_FORM_BEFORE - Before password reset form\n- PanelsRenderHook::AUTH_REGISTER_FORM_AFTER - After register form\n- PanelsRenderHook::AUTH_REGISTER_FORM_BEFORE - Before register form\n- PanelsRenderHook::BODY_END - Before </body>\n- PanelsRenderHook::BODY_START - After <body>\n- PanelsRenderHook::CONTENT_AFTER - After page content\n- PanelsRenderHook::CONTENT_BEFORE - Before page content\n- PanelsRenderHook::CONTENT_END - After page content, inside <main>\n- PanelsRenderHook::CONTENT_START - Before page content, inside <main>\n- PanelsRenderHook::FOOTER - Footer of the page\n- PanelsRenderHook::GLOBAL_SEARCH_AFTER - After the global search container, inside the topbar\n- PanelsRenderHook::GLOBAL_SEARCH_BEFORE - Before the global search container, inside the topbar\n- PanelsRenderHook::GLOBAL_SEARCH_END - The end of the global search container\n- PanelsRenderHook::GLOBAL_SEARCH_START - The start of the global search container\n- PanelsRenderHook::HEAD_END - Before </head>\n- PanelsRenderHook::HEAD_START - After <head>\n- PanelsRenderHook::PAGE_END - End of the page content container, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_FOOTER_WIDGETS_AFTER - After the page footer widgets, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_FOOTER_WIDGETS_BEFORE - Before the page footer widgets, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_HEADER_ACTIONS_AFTER - After the page header actions, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_HEADER_ACTIONS_BEFORE - Before the page header actions, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_HEADER_WIDGETS_AFTER - After the page header widgets, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_HEADER_WIDGETS_BEFORE - Before the page header widgets, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_START - Start of the page content container, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_END_AFTER - After the page sub navigation “end” sidebar position, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_END_BEFORE - Before the page sub navigation “end” sidebar position, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_SELECT_AFTER - After the page sub navigation select (for mobile), also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_SELECT_BEFORE - Before the page sub navigation select (for mobile), also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_SIDEBAR_AFTER - After the page sub navigation sidebar, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_SIDEBAR_BEFORE - Before the page sub navigation sidebar, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_START_AFTER - After the page sub navigation “start” sidebar position, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_START_BEFORE - Before the page sub navigation “start” sidebar position, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_TOP_AFTER - After the page sub navigation “top” tabs position, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_TOP_BEFORE - Before the page sub navigation “top” tabs position, also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABLE_AFTER - After the resource table, also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABLE_BEFORE - Before the resource table, also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABS_END - The end of the filter tabs (after the last tab), also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABS_START - The start of the filter tabs (before the first tab), also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_MANAGE_RELATED_RECORDS_TABLE_AFTER - After the relation manager table, also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_MANAGE_RELATED_RECORDS_TABLE_BEFORE - Before the relation manager table, also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_RELATION_MANAGER_AFTER - After the relation manager table, also can be scoped to the page or relation manager class\n- PanelsRenderHook::RESOURCE_RELATION_MANAGER_BEFORE - Before the relation manager table, also can be scoped to the page or relation manager class\n- PanelsRenderHook::RESOURCE_TABS_END - The end of the resource tabs (after the last tab), also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_TABS_START - The start of the resource tabs (before the first tab), also can be scoped to the page or resource class\n- PanelsRenderHook::SCRIPTS_AFTER - After scripts are defined\n- PanelsRenderHook::SCRIPTS_BEFORE - Before scripts are defined\n- PanelsRenderHook::SIDEBAR_NAV_END - In the sidebar, before </nav>\n- PanelsRenderHook::SIDEBAR_NAV_START - In the sidebar, after <nav>\n- PanelsRenderHook::SIMPLE_PAGE_END - End of the simple page content container, also can be scoped to the page class\n- PanelsRenderHook::SIMPLE_PAGE_START - Start of the simple page content container, also can be scoped to the page class\n- PanelsRenderHook::SIDEBAR_FOOTER - Pinned to the bottom of the sidebar, below the content\n- PanelsRenderHook::STYLES_AFTER - After styles are defined\n- PanelsRenderHook::STYLES_BEFORE - Before styles are defined\n- PanelsRenderHook::TENANT_MENU_AFTER - After the tenant menu\n- PanelsRenderHook::TENANT_MENU_BEFORE - Before the tenant menu\n- PanelsRenderHook::TOPBAR_AFTER - Below the topbar\n- PanelsRenderHook::TOPBAR_BEFORE - Above the topbar\n- PanelsRenderHook::TOPBAR_END - End of the topbar container\n- PanelsRenderHook::TOPBAR_START - Start of the topbar container\n- PanelsRenderHook::USER_MENU_AFTER - After the user menu\n- PanelsRenderHook::USER_MENU_BEFORE - Before the user menu\n- PanelsRenderHook::USER_MENU_PROFILE_AFTER - After the profile item in the user menu\n- PanelsRenderHook::USER_MENU_PROFILE_BEFORE - Before the profile item in the user menu\n\n`PanelsRenderHook::AUTH_LOGIN_FORM_AFTER``PanelsRenderHook::AUTH_LOGIN_FORM_BEFORE``PanelsRenderHook::AUTH_PASSWORD_RESET_REQUEST_FORM_AFTER``PanelsRenderHook::AUTH_PASSWORD_RESET_REQUEST_FORM_BEFORE``PanelsRenderHook::AUTH_PASSWORD_RESET_RESET_FORM_AFTER``PanelsRenderHook::AUTH_PASSWORD_RESET_RESET_FORM_BEFORE``PanelsRenderHook::AUTH_REGISTER_FORM_AFTER``PanelsRenderHook::AUTH_REGISTER_FORM_BEFORE``PanelsRenderHook::BODY_END``</body>``PanelsRenderHook::BODY_START``<body>``PanelsRenderHook::CONTENT_AFTER``PanelsRenderHook::CONTENT_BEFORE``PanelsRenderHook::CONTENT_END``<main>``PanelsRenderHook::CONTENT_START``<main>``PanelsRenderHook::FOOTER``PanelsRenderHook::GLOBAL_SEARCH_AFTER``PanelsRenderHook::GLOBAL_SEARCH_BEFORE``PanelsRenderHook::GLOBAL_SEARCH_END``PanelsRenderHook::GLOBAL_SEARCH_START``PanelsRenderHook::HEAD_END``</head>``PanelsRenderHook::HEAD_START``<head>``PanelsRenderHook::PAGE_END``PanelsRenderHook::PAGE_FOOTER_WIDGETS_AFTER``PanelsRenderHook::PAGE_FOOTER_WIDGETS_BEFORE``PanelsRenderHook::PAGE_HEADER_ACTIONS_AFTER``PanelsRenderHook::PAGE_HEADER_ACTIONS_BEFORE``PanelsRenderHook::PAGE_HEADER_WIDGETS_AFTER``PanelsRenderHook::PAGE_HEADER_WIDGETS_BEFORE``PanelsRenderHook::PAGE_START``PanelsRenderHook::PAGE_SUB_NAVIGATION_END_AFTER``PanelsRenderHook::PAGE_SUB_NAVIGATION_END_BEFORE``PanelsRenderHook::PAGE_SUB_NAVIGATION_SELECT_AFTER``PanelsRenderHook::PAGE_SUB_NAVIGATION_SELECT_BEFORE``PanelsRenderHook::PAGE_SUB_NAVIGATION_SIDEBAR_AFTER``PanelsRenderHook::PAGE_SUB_NAVIGATION_SIDEBAR_BEFORE``PanelsRenderHook::PAGE_SUB_NAVIGATION_START_AFTER``PanelsRenderHook::PAGE_SUB_NAVIGATION_START_BEFORE``PanelsRenderHook::PAGE_SUB_NAVIGATION_TOP_AFTER``PanelsRenderHook::PAGE_SUB_NAVIGATION_TOP_BEFORE``PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABLE_AFTER``PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABLE_BEFORE``PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABS_END``PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABS_START``PanelsRenderHook::RESOURCE_PAGES_MANAGE_RELATED_RECORDS_TABLE_AFTER``PanelsRenderHook::RESOURCE_PAGES_MANAGE_RELATED_RECORDS_TABLE_BEFORE``PanelsRenderHook::RESOURCE_RELATION_MANAGER_AFTER``PanelsRenderHook::RESOURCE_RELATION_MANAGER_BEFORE``PanelsRenderHook::RESOURCE_TABS_END``PanelsRenderHook::RESOURCE_TABS_START``PanelsRenderHook::SCRIPTS_AFTER``PanelsRenderHook::SCRIPTS_BEFORE``PanelsRenderHook::SIDEBAR_NAV_END``</nav>``PanelsRenderHook::SIDEBAR_NAV_START``<nav>``PanelsRenderHook::SIMPLE_PAGE_END``PanelsRenderHook::SIMPLE_PAGE_START``PanelsRenderHook::SIDEBAR_FOOTER``PanelsRenderHook::STYLES_AFTER``PanelsRenderHook::STYLES_BEFORE``PanelsRenderHook::TENANT_MENU_AFTER``PanelsRenderHook::TENANT_MENU_BEFORE``PanelsRenderHook::TOPBAR_AFTER``PanelsRenderHook::TOPBAR_BEFORE``PanelsRenderHook::TOPBAR_END``PanelsRenderHook::TOPBAR_START``PanelsRenderHook::USER_MENU_AFTER``PanelsRenderHook::USER_MENU_BEFORE``PanelsRenderHook::USER_MENU_PROFILE_AFTER``PanelsRenderHook::USER_MENU_PROFILE_BEFORE`### #Table Builder render hooks\n\nAll these render hooks can be scoped to any table Livewire component class. When using the Panel Builder, these classes might be the List or Manage page of a resource, or a relation manager. Table widgets are also Livewire component classes.\n\n```\nuse Filament\\Tables\\View\\TablesRenderHook;\n```\n\n- TablesRenderHook::SELECTION_INDICATOR_ACTIONS_AFTER - After the “select all” and “deselect all” action buttons in the selection indicator bar\n- TablesRenderHook::SELECTION_INDICATOR_ACTIONS_BEFORE - Before the “select all” and “deselect all” action buttons in the selection indicator bar\n- TablesRenderHook::HEADER_AFTER - After the header container\n- TablesRenderHook::HEADER_BEFORE - Before the header container\n- TablesRenderHook::TOOLBAR_AFTER - After the toolbar container\n- TablesRenderHook::TOOLBAR_BEFORE - Before the toolbar container\n- TablesRenderHook::TOOLBAR_END - The end of the toolbar\n- TablesRenderHook::TOOLBAR_GROUPING_SELECTOR_AFTER - After the grouping selector\n- TablesRenderHook::TOOLBAR_GROUPING_SELECTOR_BEFORE - Before the grouping selector\n- TablesRenderHook::TOOLBAR_REORDER_TRIGGER_AFTER - After the reorder trigger\n- TablesRenderHook::TOOLBAR_REORDER_TRIGGER_BEFORE - Before the reorder trigger\n- TablesRenderHook::TOOLBAR_SEARCH_AFTER - After the search container\n- TablesRenderHook::TOOLBAR_SEARCH_BEFORE - Before the search container\n- TablesRenderHook::TOOLBAR_START - The start of the toolbar\n- TablesRenderHook::TOOLBAR_TOGGLE_COLUMN_TRIGGER_AFTER - After the toggle columns trigger\n- TablesRenderHook::TOOLBAR_TOGGLE_COLUMN_TRIGGER_BEFORE - Before the toggle columns trigger\n\n`TablesRenderHook::SELECTION_INDICATOR_ACTIONS_AFTER``TablesRenderHook::SELECTION_INDICATOR_ACTIONS_BEFORE``TablesRenderHook::HEADER_AFTER``TablesRenderHook::HEADER_BEFORE``TablesRenderHook::TOOLBAR_AFTER``TablesRenderHook::TOOLBAR_BEFORE``TablesRenderHook::TOOLBAR_END``TablesRenderHook::TOOLBAR_GROUPING_SELECTOR_AFTER``TablesRenderHook::TOOLBAR_GROUPING_SELECTOR_BEFORE``TablesRenderHook::TOOLBAR_REORDER_TRIGGER_AFTER``TablesRenderHook::TOOLBAR_REORDER_TRIGGER_BEFORE``TablesRenderHook::TOOLBAR_SEARCH_AFTER``TablesRenderHook::TOOLBAR_SEARCH_BEFORE``TablesRenderHook::TOOLBAR_START``TablesRenderHook::TOOLBAR_TOGGLE_COLUMN_TRIGGER_AFTER``TablesRenderHook::TOOLBAR_TOGGLE_COLUMN_TRIGGER_BEFORE`### #Widgets render hooks\n\n```\nuse Filament\\Widgets\\View\\WidgetsRenderHook;\n```\n\n- WidgetsRenderHook::TABLE_WIDGET_END - End of the table widget, after the table itself, also can be scoped to the table widget class\n- WidgetsRenderHook::TABLE_WIDGET_START - Start of the table widget, before the table itself, also can be scoped to the table widget class\n\n`WidgetsRenderHook::TABLE_WIDGET_END``WidgetsRenderHook::TABLE_WIDGET_START`## #Scoping render hooks\n\nSome render hooks can be given a “scope”, which allows them to only be output on a specific page or Livewire component. For instance, you might want to register a render hook for just 1 page. To do that, you can pass the class of the page or component as the second argument to registerRenderHook():\n\n`registerRenderHook()````\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\nuse Illuminate\\Support\\Facades\\Blade;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::PAGE_START,\n    fn (): View => view('warning-banner'),\n    scopes: \\App\\Filament\\Resources\\UserResource\\Pages\\EditUser::class,\n);\n```\n\nYou can also pass an array of scopes to register the render hook for:\n\n```\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::PAGE_START,\n    fn (): View => view('warning-banner'),\n    scopes: [\n        \\App\\Filament\\Resources\\UserResource\\Pages\\CreateUser::class,\n        \\App\\Filament\\Resources\\UserResource\\Pages\\EditUser::class,\n    ],\n);\n```\n\nSome render hooks for the Panel Builder allow you to scope hooks to all pages in a resource:\n\n```\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::PAGE_START,\n    fn (): View => view('warning-banner'),\n    scopes: \\App\\Filament\\Resources\\UserResource::class,\n);\n```\n\n### #Retrieving the currently active scopes inside the render hook\n\nThe $scopes are passed to the render hook function, and you can use them to determine which page or component the render hook is being rendered on:\n\n`$scopes````\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::PAGE_START,\n    fn (array $scopes): View => view('warning-banner', ['scopes' => $scopes]),\n    scopes: \\App\\Filament\\Resources\\UserResource::class,\n);\n```\n\n## #Rendering hooks\n\nPlugin developers might find it useful to expose render hooks to their users. You do not need to register them anywhere, simply output them in Blade like so:\n\n```\n{{ \\Filament\\Support\\Facades\\FilamentView::renderHook(\\Filament\\View\\PanelsRenderHook::PAGE_START) }}\n```\n\nTo provide scope your render hook, you can pass it as the second argument to renderHook(). For instance, if your hook is inside a Livewire component, you can pass the class of the component using static::class:\n\n`renderHook()``static::class````\n{{ \\Filament\\Support\\Facades\\FilamentView::renderHook(\\Filament\\View\\PanelsRenderHook::PAGE_START, scopes: $this->getRenderHookScopes()) }}\n```\n\nYou can even pass multiple scopes as an array, and all render hooks that match any of the scopes will be rendered:\n\n```\n{{ \\Filament\\Support\\Facades\\FilamentView::renderHook(\\Filament\\View\\PanelsRenderHook::PAGE_START, scopes: [static::class, \\App\\Filament\\Resources\\UserResource::class]) }}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Render hooks - Core Concepts - Filament",
                "content": "Core Concepts",
                "level": 1
              },
              {
                "title": "# Render hooks",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament allows you to render Blade content at various points in the frameworks views. It’s useful for plugins to be able to inject HTML into the framework. Also, since Filament does not recommend publishing the views due to an increased risk of breaking changes, it’s also useful for users.",
                "level": 3
              },
              {
                "title": "## #Registering render hooks",
                "content": "To register render hooks, you can call FilamentView::registerRenderHook() from a service provider or middleware. The first argument is the name of the render hook, and the second argument is a callback that returns the content to be rendered:\n\n`FilamentView::registerRenderHook()````\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\nuse Illuminate\\Support\\Facades\\Blade;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::BODY_START,\n    fn (): string => Blade::render('@livewire(\\'livewire-ui-modal\\')'),\n);\n```\n\nYou could also render view content from a file:\n\n```\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\nuse Illuminate\\Contracts\\View\\View;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::BODY_START,\n    fn (): View => view('impersonation-banner'),\n);\n```",
                "level": 3
              },
              {
                "title": "## #Available render hooks",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Panel Builder render hooks",
                "content": "```\nuse Filament\\View\\PanelsRenderHook;\n```\n\n- PanelsRenderHook::AUTH_LOGIN_FORM_AFTER - After login form\n- PanelsRenderHook::AUTH_LOGIN_FORM_BEFORE - Before login form\n- PanelsRenderHook::AUTH_PASSWORD_RESET_REQUEST_FORM_AFTER - After password reset request form\n- PanelsRenderHook::AUTH_PASSWORD_RESET_REQUEST_FORM_BEFORE - Before password reset request form\n- PanelsRenderHook::AUTH_PASSWORD_RESET_RESET_FORM_AFTER - After password reset form\n- PanelsRenderHook::AUTH_PASSWORD_RESET_RESET_FORM_BEFORE - Before password reset form\n- PanelsRenderHook::AUTH_REGISTER_FORM_AFTER - After register form\n- PanelsRenderHook::AUTH_REGISTER_FORM_BEFORE - Before register form\n- PanelsRenderHook::BODY_END - Before </body>\n- PanelsRenderHook::BODY_START - After <body>\n- PanelsRenderHook::CONTENT_AFTER - After page content\n- PanelsRenderHook::CONTENT_BEFORE - Before page content\n- PanelsRenderHook::CONTENT_END - After page content, inside <main>\n- PanelsRenderHook::CONTENT_START - Before page content, inside <main>\n- PanelsRenderHook::FOOTER - Footer of the page\n- PanelsRenderHook::GLOBAL_SEARCH_AFTER - After the global search container, inside the topbar\n- PanelsRenderHook::GLOBAL_SEARCH_BEFORE - Before the global search container, inside the topbar\n- PanelsRenderHook::GLOBAL_SEARCH_END - The end of the global search container\n- PanelsRenderHook::GLOBAL_SEARCH_START - The start of the global search container\n- PanelsRenderHook::HEAD_END - Before </head>\n- PanelsRenderHook::HEAD_START - After <head>\n- PanelsRenderHook::PAGE_END - End of the page content container, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_FOOTER_WIDGETS_AFTER - After the page footer widgets, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_FOOTER_WIDGETS_BEFORE - Before the page footer widgets, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_HEADER_ACTIONS_AFTER - After the page header actions, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_HEADER_ACTIONS_BEFORE - Before the page header actions, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_HEADER_WIDGETS_AFTER - After the page header widgets, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_HEADER_WIDGETS_BEFORE - Before the page header widgets, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_START - Start of the page content container, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_END_AFTER - After the page sub navigation “end” sidebar position, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_END_BEFORE - Before the page sub navigation “end” sidebar position, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_SELECT_AFTER - After the page sub navigation select (for mobile), also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_SELECT_BEFORE - Before the page sub navigation select (for mobile), also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_SIDEBAR_AFTER - After the page sub navigation sidebar, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_SIDEBAR_BEFORE - Before the page sub navigation sidebar, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_START_AFTER - After the page sub navigation “start” sidebar position, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_START_BEFORE - Before the page sub navigation “start” sidebar position, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_TOP_AFTER - After the page sub navigation “top” tabs position, also can be scoped to the page or resource class\n- PanelsRenderHook::PAGE_SUB_NAVIGATION_TOP_BEFORE - Before the page sub navigation “top” tabs position, also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABLE_AFTER - After the resource table, also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABLE_BEFORE - Before the resource table, also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABS_END - The end of the filter tabs (after the last tab), also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABS_START - The start of the filter tabs (before the first tab), also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_MANAGE_RELATED_RECORDS_TABLE_AFTER - After the relation manager table, also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_PAGES_MANAGE_RELATED_RECORDS_TABLE_BEFORE - Before the relation manager table, also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_RELATION_MANAGER_AFTER - After the relation manager table, also can be scoped to the page or relation manager class\n- PanelsRenderHook::RESOURCE_RELATION_MANAGER_BEFORE - Before the relation manager table, also can be scoped to the page or relation manager class\n- PanelsRenderHook::RESOURCE_TABS_END - The end of the resource tabs (after the last tab), also can be scoped to the page or resource class\n- PanelsRenderHook::RESOURCE_TABS_START - The start of the resource tabs (before the first tab), also can be scoped to the page or resource class\n- PanelsRenderHook::SCRIPTS_AFTER - After scripts are defined\n- PanelsRenderHook::SCRIPTS_BEFORE - Before scripts are defined\n- PanelsRenderHook::SIDEBAR_NAV_END - In the sidebar, before </nav>\n- PanelsRenderHook::SIDEBAR_NAV_START - In the sidebar, after <nav>\n- PanelsRenderHook::SIMPLE_PAGE_END - End of the simple page content container, also can be scoped to the page class\n- PanelsRenderHook::SIMPLE_PAGE_START - Start of the simple page content container, also can be scoped to the page class\n- PanelsRenderHook::SIDEBAR_FOOTER - Pinned to the bottom of the sidebar, below the content\n- PanelsRenderHook::STYLES_AFTER - After styles are defined\n- PanelsRenderHook::STYLES_BEFORE - Before styles are defined\n- PanelsRenderHook::TENANT_MENU_AFTER - After the tenant menu\n- PanelsRenderHook::TENANT_MENU_BEFORE - Before the tenant menu\n- PanelsRenderHook::TOPBAR_AFTER - Below the topbar\n- PanelsRenderHook::TOPBAR_BEFORE - Above the topbar\n- PanelsRenderHook::TOPBAR_END - End of the topbar container\n- PanelsRenderHook::TOPBAR_START - Start of the topbar container\n- PanelsRenderHook::USER_MENU_AFTER - After the user menu\n- PanelsRenderHook::USER_MENU_BEFORE - Before the user menu\n- PanelsRenderHook::USER_MENU_PROFILE_AFTER - After the profile item in the user menu\n- PanelsRenderHook::USER_MENU_PROFILE_BEFORE - Before the profile item in the user menu\n\n`PanelsRenderHook::AUTH_LOGIN_FORM_AFTER``PanelsRenderHook::AUTH_LOGIN_FORM_BEFORE``PanelsRenderHook::AUTH_PASSWORD_RESET_REQUEST_FORM_AFTER``PanelsRenderHook::AUTH_PASSWORD_RESET_REQUEST_FORM_BEFORE``PanelsRenderHook::AUTH_PASSWORD_RESET_RESET_FORM_AFTER``PanelsRenderHook::AUTH_PASSWORD_RESET_RESET_FORM_BEFORE``PanelsRenderHook::AUTH_REGISTER_FORM_AFTER``PanelsRenderHook::AUTH_REGISTER_FORM_BEFORE``PanelsRenderHook::BODY_END``</body>``PanelsRenderHook::BODY_START``<body>``PanelsRenderHook::CONTENT_AFTER``PanelsRenderHook::CONTENT_BEFORE``PanelsRenderHook::CONTENT_END``<main>``PanelsRenderHook::CONTENT_START``<main>``PanelsRenderHook::FOOTER``PanelsRenderHook::GLOBAL_SEARCH_AFTER``PanelsRenderHook::GLOBAL_SEARCH_BEFORE``PanelsRenderHook::GLOBAL_SEARCH_END``PanelsRenderHook::GLOBAL_SEARCH_START``PanelsRenderHook::HEAD_END``</head>``PanelsRenderHook::HEAD_START``<head>``PanelsRenderHook::PAGE_END``PanelsRenderHook::PAGE_FOOTER_WIDGETS_AFTER``PanelsRenderHook::PAGE_FOOTER_WIDGETS_BEFORE``PanelsRenderHook::PAGE_HEADER_ACTIONS_AFTER``PanelsRenderHook::PAGE_HEADER_ACTIONS_BEFORE``PanelsRenderHook::PAGE_HEADER_WIDGETS_AFTER``PanelsRenderHook::PAGE_HEADER_WIDGETS_BEFORE``PanelsRenderHook::PAGE_START``PanelsRenderHook::PAGE_SUB_NAVIGATION_END_AFTER``PanelsRenderHook::PAGE_SUB_NAVIGATION_END_BEFORE``PanelsRenderHook::PAGE_SUB_NAVIGATION_SELECT_AFTER``PanelsRenderHook::PAGE_SUB_NAVIGATION_SELECT_BEFORE``PanelsRenderHook::PAGE_SUB_NAVIGATION_SIDEBAR_AFTER``PanelsRenderHook::PAGE_SUB_NAVIGATION_SIDEBAR_BEFORE``PanelsRenderHook::PAGE_SUB_NAVIGATION_START_AFTER``PanelsRenderHook::PAGE_SUB_NAVIGATION_START_BEFORE``PanelsRenderHook::PAGE_SUB_NAVIGATION_TOP_AFTER``PanelsRenderHook::PAGE_SUB_NAVIGATION_TOP_BEFORE``PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABLE_AFTER``PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABLE_BEFORE``PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABS_END``PanelsRenderHook::RESOURCE_PAGES_LIST_RECORDS_TABS_START``PanelsRenderHook::RESOURCE_PAGES_MANAGE_RELATED_RECORDS_TABLE_AFTER``PanelsRenderHook::RESOURCE_PAGES_MANAGE_RELATED_RECORDS_TABLE_BEFORE``PanelsRenderHook::RESOURCE_RELATION_MANAGER_AFTER``PanelsRenderHook::RESOURCE_RELATION_MANAGER_BEFORE``PanelsRenderHook::RESOURCE_TABS_END``PanelsRenderHook::RESOURCE_TABS_START``PanelsRenderHook::SCRIPTS_AFTER``PanelsRenderHook::SCRIPTS_BEFORE``PanelsRenderHook::SIDEBAR_NAV_END``</nav>``PanelsRenderHook::SIDEBAR_NAV_START``<nav>``PanelsRenderHook::SIMPLE_PAGE_END``PanelsRenderHook::SIMPLE_PAGE_START``PanelsRenderHook::SIDEBAR_FOOTER``PanelsRenderHook::STYLES_AFTER``PanelsRenderHook::STYLES_BEFORE``PanelsRenderHook::TENANT_MENU_AFTER``PanelsRenderHook::TENANT_MENU_BEFORE``PanelsRenderHook::TOPBAR_AFTER``PanelsRenderHook::TOPBAR_BEFORE``PanelsRenderHook::TOPBAR_END``PanelsRenderHook::TOPBAR_START``PanelsRenderHook::USER_MENU_AFTER``PanelsRenderHook::USER_MENU_BEFORE``PanelsRenderHook::USER_MENU_PROFILE_AFTER``PanelsRenderHook::USER_MENU_PROFILE_BEFORE`### #Table Builder render hooks\n\nAll these render hooks can be scoped to any table Livewire component class. When using the Panel Builder, these classes might be the List or Manage page of a resource, or a relation manager. Table widgets are also Livewire component classes.\n\n```\nuse Filament\\Tables\\View\\TablesRenderHook;\n```\n\n- TablesRenderHook::SELECTION_INDICATOR_ACTIONS_AFTER - After the “select all” and “deselect all” action buttons in the selection indicator bar\n- TablesRenderHook::SELECTION_INDICATOR_ACTIONS_BEFORE - Before the “select all” and “deselect all” action buttons in the selection indicator bar\n- TablesRenderHook::HEADER_AFTER - After the header container\n- TablesRenderHook::HEADER_BEFORE - Before the header container\n- TablesRenderHook::TOOLBAR_AFTER - After the toolbar container\n- TablesRenderHook::TOOLBAR_BEFORE - Before the toolbar container\n- TablesRenderHook::TOOLBAR_END - The end of the toolbar\n- TablesRenderHook::TOOLBAR_GROUPING_SELECTOR_AFTER - After the grouping selector\n- TablesRenderHook::TOOLBAR_GROUPING_SELECTOR_BEFORE - Before the grouping selector\n- TablesRenderHook::TOOLBAR_REORDER_TRIGGER_AFTER - After the reorder trigger\n- TablesRenderHook::TOOLBAR_REORDER_TRIGGER_BEFORE - Before the reorder trigger\n- TablesRenderHook::TOOLBAR_SEARCH_AFTER - After the search container\n- TablesRenderHook::TOOLBAR_SEARCH_BEFORE - Before the search container\n- TablesRenderHook::TOOLBAR_START - The start of the toolbar\n- TablesRenderHook::TOOLBAR_TOGGLE_COLUMN_TRIGGER_AFTER - After the toggle columns trigger\n- TablesRenderHook::TOOLBAR_TOGGLE_COLUMN_TRIGGER_BEFORE - Before the toggle columns trigger\n\n`TablesRenderHook::SELECTION_INDICATOR_ACTIONS_AFTER``TablesRenderHook::SELECTION_INDICATOR_ACTIONS_BEFORE``TablesRenderHook::HEADER_AFTER``TablesRenderHook::HEADER_BEFORE``TablesRenderHook::TOOLBAR_AFTER``TablesRenderHook::TOOLBAR_BEFORE``TablesRenderHook::TOOLBAR_END``TablesRenderHook::TOOLBAR_GROUPING_SELECTOR_AFTER``TablesRenderHook::TOOLBAR_GROUPING_SELECTOR_BEFORE``TablesRenderHook::TOOLBAR_REORDER_TRIGGER_AFTER``TablesRenderHook::TOOLBAR_REORDER_TRIGGER_BEFORE``TablesRenderHook::TOOLBAR_SEARCH_AFTER``TablesRenderHook::TOOLBAR_SEARCH_BEFORE``TablesRenderHook::TOOLBAR_START``TablesRenderHook::TOOLBAR_TOGGLE_COLUMN_TRIGGER_AFTER``TablesRenderHook::TOOLBAR_TOGGLE_COLUMN_TRIGGER_BEFORE`### #Widgets render hooks\n\n```\nuse Filament\\Widgets\\View\\WidgetsRenderHook;\n```\n\n- WidgetsRenderHook::TABLE_WIDGET_END - End of the table widget, after the table itself, also can be scoped to the table widget class\n- WidgetsRenderHook::TABLE_WIDGET_START - Start of the table widget, before the table itself, also can be scoped to the table widget class\n\n`WidgetsRenderHook::TABLE_WIDGET_END``WidgetsRenderHook::TABLE_WIDGET_START`## #Scoping render hooks\n\nSome render hooks can be given a “scope”, which allows them to only be output on a specific page or Livewire component. For instance, you might want to register a render hook for just 1 page. To do that, you can pass the class of the page or component as the second argument to registerRenderHook():\n\n`registerRenderHook()````\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\nuse Illuminate\\Support\\Facades\\Blade;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::PAGE_START,\n    fn (): View => view('warning-banner'),\n    scopes: \\App\\Filament\\Resources\\UserResource\\Pages\\EditUser::class,\n);\n```\n\nYou can also pass an array of scopes to register the render hook for:\n\n```\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::PAGE_START,\n    fn (): View => view('warning-banner'),\n    scopes: [\n        \\App\\Filament\\Resources\\UserResource\\Pages\\CreateUser::class,\n        \\App\\Filament\\Resources\\UserResource\\Pages\\EditUser::class,\n    ],\n);\n```\n\nSome render hooks for the Panel Builder allow you to scope hooks to all pages in a resource:\n\n```\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::PAGE_START,\n    fn (): View => view('warning-banner'),\n    scopes: \\App\\Filament\\Resources\\UserResource::class,\n);\n```",
                "level": 4
              },
              {
                "title": "### #Retrieving the currently active scopes inside the render hook",
                "content": "The $scopes are passed to the render hook function, and you can use them to determine which page or component the render hook is being rendered on:\n\n`$scopes````\nuse Filament\\Support\\Facades\\FilamentView;\nuse Filament\\View\\PanelsRenderHook;\n\nFilamentView::registerRenderHook(\n    PanelsRenderHook::PAGE_START,\n    fn (array $scopes): View => view('warning-banner', ['scopes' => $scopes]),\n    scopes: \\App\\Filament\\Resources\\UserResource::class,\n);\n```",
                "level": 4
              },
              {
                "title": "## #Rendering hooks",
                "content": "Plugin developers might find it useful to expose render hooks to their users. You do not need to register them anywhere, simply output them in Blade like so:\n\n```\n{{ \\Filament\\Support\\Facades\\FilamentView::renderHook(\\Filament\\View\\PanelsRenderHook::PAGE_START) }}\n```\n\nTo provide scope your render hook, you can pass it as the second argument to renderHook(). For instance, if your hook is inside a Livewire component, you can pass the class of the component using static::class:\n\n`renderHook()``static::class````\n{{ \\Filament\\Support\\Facades\\FilamentView::renderHook(\\Filament\\View\\PanelsRenderHook::PAGE_START, scopes: $this->getRenderHookScopes()) }}\n```\n\nYou can even pass multiple scopes as an array, and all render hooks that match any of the scopes will be rendered:\n\n```\n{{ \\Filament\\Support\\Facades\\FilamentView::renderHook(\\Filament\\View\\PanelsRenderHook::PAGE_START, scopes: [static::class, \\App\\Filament\\Resources\\UserResource::class]) }}\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Registering render hooks",
              "Available render hooks",
              "Panel Builder render hooks",
              "Retrieving the currently active scopes inside the render hook",
              "Rendering hooks"
            ],
            "code_examples_count": 24,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "enums": {
          "metadata": {
            "title": "Enums",
            "url": "https://filamentphp.com/docs/3.x/support/enums",
            "section": "support",
            "word_count": 1164,
            "character_count": 8477
          },
          "content": {
            "full_text": "\n# Enums - Core Concepts - Filament\n\nCore Concepts\n\n# Enums\n\n## #Overview\n\nEnums are special PHP classes that represent a fixed set of constants. They are useful for modeling concepts that have a limited number of possible values, like days of the week, months in a year, or the suits in a deck of cards.\n\nSince enum “cases” are instances of the enum class, adding interfaces to enums proves to be very useful. Filament provides a collection of interfaces that you can add to enums, which enhance your experience when working with them.\n\n> When using an enum with an attribute on your Eloquent model, please ensure that it is cast correctly.\n\nWhen using an enum with an attribute on your Eloquent model, please ensure that it is cast correctly.\n\n## #Enum labels\n\nThe HasLabel interface transforms an enum instance into a textual label. This is useful for displaying human-readable enum values in your UI.\n\n`HasLabel````\nuse Filament\\Support\\Contracts\\HasLabel;\n\nenum Status: string implements HasLabel\n{\n    case Draft = 'draft';\n    case Reviewing = 'reviewing';\n    case Published = 'published';\n    case Rejected = 'rejected';\n    \n    public function getLabel(): ?string\n    {\n        return $this->name;\n        \n        // or\n    \n        return match ($this) {\n            self::Draft => 'Draft',\n            self::Reviewing => 'Reviewing',\n            self::Published => 'Published',\n            self::Rejected => 'Rejected',\n        };\n    }\n}\n```\n\n### #Using the enum label with form field options\n\nThe HasLabel interface can be used to generate an array of options from an enum, where the enum’s value is the key and the enum’s label is the value. This applies to Form Builder fields like Select and CheckboxList, as well as the Table Builder’s SelectColumn and SelectFilter:\n\n`HasLabel``Select``CheckboxList``SelectColumn``SelectFilter````\nuse Filament\\Forms\\Components\\CheckboxList;\nuse Filament\\Forms\\Components\\Radio;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Tables\\Columns\\SelectColumn;\nuse Filament\\Tables\\Filters\\SelectFilter;\n\nSelect::make('status')\n    ->options(Status::class)\n\nCheckboxList::make('status')\n    ->options(Status::class)\n\nRadio::make('status')\n    ->options(Status::class)\n\nSelectColumn::make('status')\n    ->options(Status::class)\n\nSelectFilter::make('status')\n    ->options(Status::class)\n```\n\nIn these examples, Status::class is the enum class which implements HasLabel, and the options are generated from that:\n\n`Status::class``HasLabel````\n[\n    'draft' => 'Draft',\n    'reviewing' => 'Reviewing',\n    'published' => 'Published',\n    'rejected' => 'Rejected',\n]\n```\n\n### #Using the enum label with a text column in your table\n\nIf you use a TextColumn with the Table Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasLabel interface to display the enum’s label instead of its raw value.\n\n`TextColumn``HasLabel`### #Using the enum label as a group title in your table\n\nIf you use a grouping with the Table Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasLabel interface to display the enum’s label instead of its raw value. The label will be displayed as the title of each group.\n\n`HasLabel`### #Using the enum label with a text entry in your infolist\n\nIf you use a TextEntry with the Infolist Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasLabel interface to display the enum’s label instead of its raw value.\n\n`TextEntry``HasLabel`## #Enum colors\n\nThe HasColor interface transforms an enum instance into a color. This is useful for displaying colored enum values in your UI.\n\n`HasColor````\nuse Filament\\Support\\Contracts\\HasColor;\n\nenum Status: string implements HasColor\n{\n    case Draft = 'draft';\n    case Reviewing = 'reviewing';\n    case Published = 'published';\n    case Rejected = 'rejected';\n    \n    public function getColor(): string | array | null\n    {\n        return match ($this) {\n            self::Draft => 'gray',\n            self::Reviewing => 'warning',\n            self::Published => 'success',\n            self::Rejected => 'danger',\n        };\n    }\n}\n```\n\n### #Using the enum color with a text column in your table\n\nIf you use a TextColumn with the Table Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasColor interface to display the enum label in its color. This works best if you use the badge() method on the column.\n\n`TextColumn``HasColor``badge()`### #Using the enum color with a text entry in your infolist\n\nIf you use a TextEntry with the Infolist Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasColor interface to display the enum label in its color. This works best if you use the badge() method on the entry.\n\n`TextEntry``HasColor``badge()`### #Using the enum color with a toggle buttons field in your form\n\nIf you use a ToggleButtons with the Form Builder, and it is set to use an enum for its options, Filament will automatically use the HasColor interface to display the enum label in its color.\n\n`ToggleButtons``HasColor`## #Enum icons\n\nThe HasIcon interface transforms an enum instance into an icon. This is useful for displaying icons alongside enum values in your UI.\n\n`HasIcon````\nuse Filament\\Support\\Contracts\\HasIcon;\n\nenum Status: string implements HasIcon\n{\n    case Draft = 'draft';\n    case Reviewing = 'reviewing';\n    case Published = 'published';\n    case Rejected = 'rejected';\n    \n    public function getIcon(): ?string\n    {\n        return match ($this) {\n            self::Draft => 'heroicon-m-pencil',\n            self::Reviewing => 'heroicon-m-eye',\n            self::Published => 'heroicon-m-check',\n            self::Rejected => 'heroicon-m-x-mark',\n        };\n    }\n}\n```\n\n### #Using the enum icon with a text column in your table\n\nIf you use a TextColumn with the Table Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasIcon interface to display the enum’s icon aside its label. This works best if you use the badge() method on the column.\n\n`TextColumn``HasIcon``badge()`### #Using the enum icon with a text entry in your infolist\n\nIf you use a TextEntry with the Infolist Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasIcon interface to display the enum’s icon aside its label. This works best if you use the badge() method on the entry.\n\n`TextEntry``HasIcon``badge()`### #Using the enum icon with a toggle buttons field in your form\n\nIf you use a ToggleButtons with the Form Builder, and it is set to use an enum for its options, Filament will automatically use the HasIcon interface to display the enum’s icon aside its label.\n\n`ToggleButtons``HasIcon`## #Enum descriptions\n\nThe HasDescription interface transforms an enum instance into a textual description, often displayed under its label. This is useful for displaying human-friendly descriptions in your UI.\n\n`HasDescription````\nuse Filament\\Support\\Contracts\\HasDescription;\nuse Filament\\Support\\Contracts\\HasLabel;\n\nenum Status: string implements HasLabel, HasDescription\n{\n    case Draft = 'draft';\n    case Reviewing = 'reviewing';\n    case Published = 'published';\n    case Rejected = 'rejected';\n    \n    public function getLabel(): ?string\n    {\n        return $this->name;\n    }\n    \n    public function getDescription(): ?string\n    {\n        return match ($this) {\n            self::Draft => 'This has not finished being written yet.',\n            self::Reviewing => 'This is ready for a staff member to read.',\n            self::Published => 'This has been approved by a staff member and is public on the website.',\n            self::Rejected => 'A staff member has decided this is not appropriate for the website.',\n        };\n    }\n}\n```\n\n### #Using the enum description with form field descriptions\n\nThe HasDescription interface can be used to generate an array of descriptions from an enum, where the enum’s value is the key and the enum’s description is the value. This applies to Form Builder fields like Radio and CheckboxList:\n\n`HasDescription``Radio``CheckboxList````\nuse Filament\\Forms\\Components\\CheckboxList;\nuse Filament\\Forms\\Components\\Radio;\n\nRadio::make('status')\n    ->options(Status::class)\n\nCheckboxList::make('status')\n    ->options(Status::class)\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Enums - Core Concepts - Filament",
                "content": "Core Concepts",
                "level": 1
              },
              {
                "title": "# Enums",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Enums are special PHP classes that represent a fixed set of constants. They are useful for modeling concepts that have a limited number of possible values, like days of the week, months in a year, or the suits in a deck of cards.\n\nSince enum “cases” are instances of the enum class, adding interfaces to enums proves to be very useful. Filament provides a collection of interfaces that you can add to enums, which enhance your experience when working with them.\n\n> When using an enum with an attribute on your Eloquent model, please ensure that it is cast correctly.\n\nWhen using an enum with an attribute on your Eloquent model, please ensure that it is cast correctly.",
                "level": 3
              },
              {
                "title": "## #Enum labels",
                "content": "The HasLabel interface transforms an enum instance into a textual label. This is useful for displaying human-readable enum values in your UI.\n\n`HasLabel````\nuse Filament\\Support\\Contracts\\HasLabel;\n\nenum Status: string implements HasLabel\n{\n    case Draft = 'draft';\n    case Reviewing = 'reviewing';\n    case Published = 'published';\n    case Rejected = 'rejected';\n    \n    public function getLabel(): ?string\n    {\n        return $this->name;\n        \n        // or\n    \n        return match ($this) {\n            self::Draft => 'Draft',\n            self::Reviewing => 'Reviewing',\n            self::Published => 'Published',\n            self::Rejected => 'Rejected',\n        };\n    }\n}\n```",
                "level": 3
              },
              {
                "title": "### #Using the enum label with form field options",
                "content": "The HasLabel interface can be used to generate an array of options from an enum, where the enum’s value is the key and the enum’s label is the value. This applies to Form Builder fields like Select and CheckboxList, as well as the Table Builder’s SelectColumn and SelectFilter:\n\n`HasLabel``Select``CheckboxList``SelectColumn``SelectFilter````\nuse Filament\\Forms\\Components\\CheckboxList;\nuse Filament\\Forms\\Components\\Radio;\nuse Filament\\Forms\\Components\\Select;\nuse Filament\\Tables\\Columns\\SelectColumn;\nuse Filament\\Tables\\Filters\\SelectFilter;\n\nSelect::make('status')\n    ->options(Status::class)\n\nCheckboxList::make('status')\n    ->options(Status::class)\n\nRadio::make('status')\n    ->options(Status::class)\n\nSelectColumn::make('status')\n    ->options(Status::class)\n\nSelectFilter::make('status')\n    ->options(Status::class)\n```\n\nIn these examples, Status::class is the enum class which implements HasLabel, and the options are generated from that:\n\n`Status::class``HasLabel````\n[\n    'draft' => 'Draft',\n    'reviewing' => 'Reviewing',\n    'published' => 'Published',\n    'rejected' => 'Rejected',\n]\n```",
                "level": 4
              },
              {
                "title": "### #Using the enum label with a text column in your table",
                "content": "If you use a TextColumn with the Table Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasLabel interface to display the enum’s label instead of its raw value.\n\n`TextColumn``HasLabel`### #Using the enum label as a group title in your table\n\nIf you use a grouping with the Table Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasLabel interface to display the enum’s label instead of its raw value. The label will be displayed as the title of each group.\n\n`HasLabel`### #Using the enum label with a text entry in your infolist\n\nIf you use a TextEntry with the Infolist Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasLabel interface to display the enum’s label instead of its raw value.\n\n`TextEntry``HasLabel`## #Enum colors\n\nThe HasColor interface transforms an enum instance into a color. This is useful for displaying colored enum values in your UI.\n\n`HasColor````\nuse Filament\\Support\\Contracts\\HasColor;\n\nenum Status: string implements HasColor\n{\n    case Draft = 'draft';\n    case Reviewing = 'reviewing';\n    case Published = 'published';\n    case Rejected = 'rejected';\n    \n    public function getColor(): string | array | null\n    {\n        return match ($this) {\n            self::Draft => 'gray',\n            self::Reviewing => 'warning',\n            self::Published => 'success',\n            self::Rejected => 'danger',\n        };\n    }\n}\n```",
                "level": 4
              },
              {
                "title": "### #Using the enum color with a text column in your table",
                "content": "If you use a TextColumn with the Table Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasColor interface to display the enum label in its color. This works best if you use the badge() method on the column.\n\n`TextColumn``HasColor``badge()`### #Using the enum color with a text entry in your infolist\n\nIf you use a TextEntry with the Infolist Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasColor interface to display the enum label in its color. This works best if you use the badge() method on the entry.\n\n`TextEntry``HasColor``badge()`### #Using the enum color with a toggle buttons field in your form\n\nIf you use a ToggleButtons with the Form Builder, and it is set to use an enum for its options, Filament will automatically use the HasColor interface to display the enum label in its color.\n\n`ToggleButtons``HasColor`## #Enum icons\n\nThe HasIcon interface transforms an enum instance into an icon. This is useful for displaying icons alongside enum values in your UI.\n\n`HasIcon````\nuse Filament\\Support\\Contracts\\HasIcon;\n\nenum Status: string implements HasIcon\n{\n    case Draft = 'draft';\n    case Reviewing = 'reviewing';\n    case Published = 'published';\n    case Rejected = 'rejected';\n    \n    public function getIcon(): ?string\n    {\n        return match ($this) {\n            self::Draft => 'heroicon-m-pencil',\n            self::Reviewing => 'heroicon-m-eye',\n            self::Published => 'heroicon-m-check',\n            self::Rejected => 'heroicon-m-x-mark',\n        };\n    }\n}\n```",
                "level": 4
              },
              {
                "title": "### #Using the enum icon with a text column in your table",
                "content": "If you use a TextColumn with the Table Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasIcon interface to display the enum’s icon aside its label. This works best if you use the badge() method on the column.\n\n`TextColumn``HasIcon``badge()`### #Using the enum icon with a text entry in your infolist\n\nIf you use a TextEntry with the Infolist Builder, and it is cast to an enum in your Eloquent model, Filament will automatically use the HasIcon interface to display the enum’s icon aside its label. This works best if you use the badge() method on the entry.\n\n`TextEntry``HasIcon``badge()`### #Using the enum icon with a toggle buttons field in your form\n\nIf you use a ToggleButtons with the Form Builder, and it is set to use an enum for its options, Filament will automatically use the HasIcon interface to display the enum’s icon aside its label.\n\n`ToggleButtons``HasIcon`## #Enum descriptions\n\nThe HasDescription interface transforms an enum instance into a textual description, often displayed under its label. This is useful for displaying human-friendly descriptions in your UI.\n\n`HasDescription````\nuse Filament\\Support\\Contracts\\HasDescription;\nuse Filament\\Support\\Contracts\\HasLabel;\n\nenum Status: string implements HasLabel, HasDescription\n{\n    case Draft = 'draft';\n    case Reviewing = 'reviewing';\n    case Published = 'published';\n    case Rejected = 'rejected';\n    \n    public function getLabel(): ?string\n    {\n        return $this->name;\n    }\n    \n    public function getDescription(): ?string\n    {\n        return match ($this) {\n            self::Draft => 'This has not finished being written yet.',\n            self::Reviewing => 'This is ready for a staff member to read.',\n            self::Published => 'This has been approved by a staff member and is public on the website.',\n            self::Rejected => 'A staff member has decided this is not appropriate for the website.',\n        };\n    }\n}\n```",
                "level": 4
              },
              {
                "title": "### #Using the enum description with form field descriptions",
                "content": "The HasDescription interface can be used to generate an array of descriptions from an enum, where the enum’s value is the key and the enum’s description is the value. This applies to Form Builder fields like Radio and CheckboxList:\n\n`HasDescription``Radio``CheckboxList````\nuse Filament\\Forms\\Components\\CheckboxList;\nuse Filament\\Forms\\Components\\Radio;\n\nRadio::make('status')\n    ->options(Status::class)\n\nCheckboxList::make('status')\n    ->options(Status::class)\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Enum labels",
              "Using the enum label with form field options",
              "Using the enum label with a text column in your table",
              "Using the enum color with a text column in your table",
              "Using the enum icon with a text column in your table",
              "Using the enum description with form field descriptions"
            ],
            "code_examples_count": 14,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": true
          }
        },
        "contributing": {
          "metadata": {
            "title": "Contributing",
            "url": "https://filamentphp.com/docs/3.x/support/contributing",
            "section": "support",
            "word_count": 725,
            "character_count": 4565
          },
          "content": {
            "full_text": "\n# Contributing - Core Concepts - Filament\n\nCore Concepts\n\n# Contributing\n\n> Parts of this guide are taken from Laravel’s contribution guide, and it served as very useful inspiration.\n\nParts of this guide are taken from Laravel’s contribution guide, and it served as very useful inspiration.\n\n## #Reporting bugs\n\nIf you find a bug in Filament, please report it by opening an issue on our GitHub repository. Before opening an issue, please search the existing issues to see if the bug has already been reported.\n\nPlease make sure to include as much information as possible, including the version of packages in your app. You can use this Artisan command in your app to open a new issue with all the correct versions pre-filled:\n\n```\nphp artisan make:filament-issue\n```\n\nWhen creating an issue, we require a “reproduction repository”. Please do not link to your actual project, what we need instead is a minimal reproduction in a fresh project without any unnecessary code. This means it doesn’t matter if your real project is private / confidential, since we want a link to a separate, isolated reproduction. This allows us to fix the problem much quicker. Issues will be automatically closed and not reviewed if this is missing, to preserve maintainer time and to ensure the process is fair for those who put effort into reporting. If you believe a reproduction repository is not suitable for the issue, which is a very rare case, please @danharrin and explain why. Saying that “it’s just a simple issue” is not an excuse for not creating a repository! Need a headstart? We have a template Filament project for you.\n\n`@danharrin`Remember, bug reports are created in the hope that others with the same problem will be able to collaborate with you on solving it. Do not expect that the bug report will automatically see any activity or that others will jump to fix it. Creating a bug report serves to help yourself and others start on the path of fixing the problem.\n\n## #Development of new features\n\nIf you would like to propose a new feature or improvement to Filament, you may use our discussion form hosted on GitHub. If you are intending on implementing the feature yourself in a pull request, we advise you to @danharrin in your feature discussion beforehand and ask if it is suitable for the framework to prevent wasting your time.\n\n`@danharrin`## #Development of plugins\n\nIf you would like to develop a plugin for Filament, please refer to the plugin development section here in the documentation. Our Discord server is also a great place to ask questions and get help with plugin development. You can start a conversation in the #plugin-developers-chat channel.\n\n`#plugin-developers-chat`You can submit your plugin to the Filament website.\n\n## #Developing with a local copy of Filament\n\nIf you want to contribute to the Filament packages, then you may want to test it in a real Laravel project:\n\n- Fork the GitHub repository to your GitHub account.\n- Create a Laravel app locally.\n- Clone your fork in your Laravel app’s root directory.\n- In the /filament directory, create a branch for your fix, e.g. fix/error-message.\n\n`/filament``fix/error-message`Install the packages in your app’s composer.json:\n\n`composer.json````\n{\n    // ...\n    \"require\": {\n        \"filament/filament\": \"*\",\n    },\n    \"minimum-stability\": \"dev\",\n    \"repositories\": [\n        {\n            \"type\": \"path\",\n            \"url\": \"filament/packages/*\"\n        }\n    ],\n    // ...\n}\n```\n\nNow, run composer update.\n\n`composer update`Once you’re finished making changes, you can commit them and submit a pull request to the GitHub repository.\n\n## #Checking for missing translations\n\nSet up a Laravel app, and install the panel builder.\n\nNow, if you want to check for missing Spanish translations, run:\n\n```\nphp artisan filament:check-translations es\n```\n\nThis will let you know which translations are missing for this locale. You can make a pull request with the changes to the GitHub repository.\n\nIf you’ve published the translations into your app and you’d like to check those instead, try:\n\n```\nphp artisan filament:check-translations es --source=app\n```\n\n## #Security vulnerabilities\n\nIf you discover a security vulnerability within Filament, please email Dan Harrin via [email protected]. All security vulnerabilities will be promptly addressed.\n\n## #Code of Conduct\n\nPlease note that Filament is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms.\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Contributing - Core Concepts - Filament",
                "content": "Core Concepts",
                "level": 1
              },
              {
                "title": "# Contributing",
                "content": "> Parts of this guide are taken from Laravel’s contribution guide, and it served as very useful inspiration.\n\nParts of this guide are taken from Laravel’s contribution guide, and it served as very useful inspiration.",
                "level": 1
              },
              {
                "title": "## #Reporting bugs",
                "content": "If you find a bug in Filament, please report it by opening an issue on our GitHub repository. Before opening an issue, please search the existing issues to see if the bug has already been reported.\n\nPlease make sure to include as much information as possible, including the version of packages in your app. You can use this Artisan command in your app to open a new issue with all the correct versions pre-filled:\n\n```\nphp artisan make:filament-issue\n```\n\nWhen creating an issue, we require a “reproduction repository”. Please do not link to your actual project, what we need instead is a minimal reproduction in a fresh project without any unnecessary code. This means it doesn’t matter if your real project is private / confidential, since we want a link to a separate, isolated reproduction. This allows us to fix the problem much quicker. Issues will be automatically closed and not reviewed if this is missing, to preserve maintainer time and to ensure the process is fair for those who put effort into reporting. If you believe a reproduction repository is not suitable for the issue, which is a very rare case, please @danharrin and explain why. Saying that “it’s just a simple issue” is not an excuse for not creating a repository! Need a headstart? We have a template Filament project for you.\n\n`@danharrin`Remember, bug reports are created in the hope that others with the same problem will be able to collaborate with you on solving it. Do not expect that the bug report will automatically see any activity or that others will jump to fix it. Creating a bug report serves to help yourself and others start on the path of fixing the problem.",
                "level": 3
              },
              {
                "title": "## #Development of new features",
                "content": "If you would like to propose a new feature or improvement to Filament, you may use our discussion form hosted on GitHub. If you are intending on implementing the feature yourself in a pull request, we advise you to @danharrin in your feature discussion beforehand and ask if it is suitable for the framework to prevent wasting your time.\n\n`@danharrin`## #Development of plugins\n\nIf you would like to develop a plugin for Filament, please refer to the plugin development section here in the documentation. Our Discord server is also a great place to ask questions and get help with plugin development. You can start a conversation in the #plugin-developers-chat channel.\n\n`#plugin-developers-chat`You can submit your plugin to the Filament website.",
                "level": 3
              },
              {
                "title": "## #Developing with a local copy of Filament",
                "content": "If you want to contribute to the Filament packages, then you may want to test it in a real Laravel project:\n\n- Fork the GitHub repository to your GitHub account.\n- Create a Laravel app locally.\n- Clone your fork in your Laravel app’s root directory.\n- In the /filament directory, create a branch for your fix, e.g. fix/error-message.\n\n`/filament``fix/error-message`Install the packages in your app’s composer.json:\n\n`composer.json````\n{\n    // ...\n    \"require\": {\n        \"filament/filament\": \"*\",\n    },\n    \"minimum-stability\": \"dev\",\n    \"repositories\": [\n        {\n            \"type\": \"path\",\n            \"url\": \"filament/packages/*\"\n        }\n    ],\n    // ...\n}\n```\n\nNow, run composer update.\n\n`composer update`Once you’re finished making changes, you can commit them and submit a pull request to the GitHub repository.",
                "level": 3
              },
              {
                "title": "## #Checking for missing translations",
                "content": "Set up a Laravel app, and install the panel builder.\n\nNow, if you want to check for missing Spanish translations, run:\n\n```\nphp artisan filament:check-translations es\n```\n\nThis will let you know which translations are missing for this locale. You can make a pull request with the changes to the GitHub repository.\n\nIf you’ve published the translations into your app and you’d like to check those instead, try:\n\n```\nphp artisan filament:check-translations es --source=app\n```",
                "level": 3
              },
              {
                "title": "## #Security vulnerabilities",
                "content": "If you discover a security vulnerability within Filament, please email Dan Harrin via [email protected]. All security vulnerabilities will be promptly addressed.",
                "level": 3
              },
              {
                "title": "## #Code of Conduct",
                "content": "Please note that Filament is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms.\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Reporting bugs",
              "Development of new features",
              "Developing with a local copy of Filament",
              "Checking for missing translations",
              "Security vulnerabilities",
              "Code of Conduct"
            ],
            "code_examples_count": 8,
            "has_installation_info": true,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "plugins": {
          "metadata": {
            "title": "Plugins",
            "url": "https://filamentphp.com/docs/3.x/support/plugins",
            "section": "support",
            "word_count": 869,
            "character_count": 5341
          },
          "content": {
            "full_text": "\n# Getting started - Core Concepts - Filament\n\nCore Concepts  \n-  Plugins\n\n# Getting started\n\n## #Overview\n\nWhile Filament comes with virtually any tool you’ll need to build great apps, sometimes you’ll need to add your own functionality either for just your app or as redistributable packages that other developers can include in their own apps. This is why Filament offers a plugin system that allows you to extend its functionality.\n\nBefore we dive in, it’s important to understand the different contexts in which plugins can be used. There are two main contexts:\n\n- Panel Plugins: These are plugins that are used with Panel Builders. They are typically used only to add functionality when used inside a Panel or as a complete Panel in and of itself. Examples of this are:\n\nA plugin that adds specific functionality to the dashboard in the form of Widgets.\nA plugin that adds a set of Resources / functionality to an app like a Blog or User Management feature.\n- Standalone Plugins: These are plugins that are used in any context outside a Panel Builder. Examples of this are:\n\nA plugin that adds custom fields to be used with the Form Builders.\nA plugin that adds custom columns or filters to the Table Builders.\n\n- A plugin that adds specific functionality to the dashboard in the form of Widgets.\n- A plugin that adds a set of Resources / functionality to an app like a Blog or User Management feature.\n\n- A plugin that adds custom fields to be used with the Form Builders.\n- A plugin that adds custom columns or filters to the Table Builders.\n\nAlthough these are two different mental contexts to keep in mind when building plugins, they can be used together inside the same plugin. They do not have to be mutually exclusive.\n\n## #Important Concepts\n\nBefore we dive into the specifics of building plugins, there are a few concepts that are important to understand. You should familiarize yourself with the following before building a plugin:\n\n- Laravel Package Development\n- Spatie Package Tools\n- Filament Asset Management\n\n### #The Plugin object\n\nFilament v3 introduces the concept of a Plugin object that is used to configure the plugin. This object is a simple PHP class that implements the Filament\\Contracts\\Plugin interface. This class is used to configure the plugin and is the main entry point for the plugin. It is also used to register Resources and Icons that might be used by your plugin.\n\n`Filament\\Contracts\\Plugin`While the plugin object is extremely helpful, it is not required to build a plugin. You can still build plugins without using the plugin object as you can see in the Building a Panel Plugin tutorial.\n\n> Info\nThe Plugin object is only used for Panel Providers. Standalone Plugins do not use this object. All configuration for Standalone Plugins should be handled in the plugin’s service provider.\n\nInfo\nThe Plugin object is only used for Panel Providers. Standalone Plugins do not use this object. All configuration for Standalone Plugins should be handled in the plugin’s service provider.\n\n### #Registering Assets\n\nAll asset registration, including CSS, JS and Alpine Components, should be done through the plugin’s service provider in the packageBooted() method. This allows Filament to register the assets with the Asset Manager and load them when needed.\n\n`packageBooted()`## #Creating a Plugin\n\nWhile you can certainly build plugins from scratch, we recommend using the Filament Plugin Skeleton to quickly get started. This skeleton includes all the necessary boilerplate to get you up and running quickly.\n\n### #Usage\n\nTo use the skeleton, simply go to the GitHub repo and click the “Use this template” button. This will create a new repo in your account with the skeleton code. After that, you can clone the repo to your machine. Once you have the code on your machine, navigate to the root of the project and run the following command:\n\n```\nphp ./configure.php\n```\n\nThis will ask you a series of questions to configure the plugin. Once you’ve answered all the questions, the script will stub out a new plugin for you, and you can begin to build your amazing new extension for Filament.\n\n## #Upgrading existing plugins\n\nSince every plugin varies greatly in its scope of use and functionality, there is no one size fits all approaches to upgrading existing plugins. However, one thing to note, that is consistent to all plugins is the deprecation of the PluginServiceProvider.\n\n`PluginServiceProvider`In your plugin service provider, you will need to change it to extend the PackageServiceProvider instead. You will also need to add a static $name property to the service provider. This property is used to register the plugin with Filament. Here is an example of what your service provider might look like:\n\n`$name````\nclass MyPluginServiceProvider extends PackageServiceProvider\n{\n    public static string $name = 'my-plugin';\n\n    public function configurePackage(Package $package): void\n    {\n        $package->name(static::$name);\n    }\n}\n```\n\n### #Helpful links\n\nPlease read this guide in its entirety before upgrading your plugin. It will help you understand the concepts and how to build your plugin.\n\n- Filament Asset Management\n- Panel Plugin Development\n- Icon Management\n- Colors Management\n- Style Customization\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Getting started - Core Concepts - Filament",
                "content": "Core Concepts  \n-  Plugins",
                "level": 1
              },
              {
                "title": "# Getting started",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "While Filament comes with virtually any tool you’ll need to build great apps, sometimes you’ll need to add your own functionality either for just your app or as redistributable packages that other developers can include in their own apps. This is why Filament offers a plugin system that allows you to extend its functionality.\n\nBefore we dive in, it’s important to understand the different contexts in which plugins can be used. There are two main contexts:\n\n- Panel Plugins: These are plugins that are used with Panel Builders. They are typically used only to add functionality when used inside a Panel or as a complete Panel in and of itself. Examples of this are:\n\nA plugin that adds specific functionality to the dashboard in the form of Widgets.\nA plugin that adds a set of Resources / functionality to an app like a Blog or User Management feature.\n- Standalone Plugins: These are plugins that are used in any context outside a Panel Builder. Examples of this are:\n\nA plugin that adds custom fields to be used with the Form Builders.\nA plugin that adds custom columns or filters to the Table Builders.\n\n- A plugin that adds specific functionality to the dashboard in the form of Widgets.\n- A plugin that adds a set of Resources / functionality to an app like a Blog or User Management feature.\n\n- A plugin that adds custom fields to be used with the Form Builders.\n- A plugin that adds custom columns or filters to the Table Builders.\n\nAlthough these are two different mental contexts to keep in mind when building plugins, they can be used together inside the same plugin. They do not have to be mutually exclusive.",
                "level": 3
              },
              {
                "title": "## #Important Concepts",
                "content": "Before we dive into the specifics of building plugins, there are a few concepts that are important to understand. You should familiarize yourself with the following before building a plugin:\n\n- Laravel Package Development\n- Spatie Package Tools\n- Filament Asset Management",
                "level": 3
              },
              {
                "title": "### #The Plugin object",
                "content": "Filament v3 introduces the concept of a Plugin object that is used to configure the plugin. This object is a simple PHP class that implements the Filament\\Contracts\\Plugin interface. This class is used to configure the plugin and is the main entry point for the plugin. It is also used to register Resources and Icons that might be used by your plugin.\n\n`Filament\\Contracts\\Plugin`While the plugin object is extremely helpful, it is not required to build a plugin. You can still build plugins without using the plugin object as you can see in the Building a Panel Plugin tutorial.\n\n> Info\nThe Plugin object is only used for Panel Providers. Standalone Plugins do not use this object. All configuration for Standalone Plugins should be handled in the plugin’s service provider.\n\nInfo\nThe Plugin object is only used for Panel Providers. Standalone Plugins do not use this object. All configuration for Standalone Plugins should be handled in the plugin’s service provider.",
                "level": 4
              },
              {
                "title": "### #Registering Assets",
                "content": "All asset registration, including CSS, JS and Alpine Components, should be done through the plugin’s service provider in the packageBooted() method. This allows Filament to register the assets with the Asset Manager and load them when needed.\n\n`packageBooted()`## #Creating a Plugin\n\nWhile you can certainly build plugins from scratch, we recommend using the Filament Plugin Skeleton to quickly get started. This skeleton includes all the necessary boilerplate to get you up and running quickly.",
                "level": 4
              },
              {
                "title": "### #Usage",
                "content": "To use the skeleton, simply go to the GitHub repo and click the “Use this template” button. This will create a new repo in your account with the skeleton code. After that, you can clone the repo to your machine. Once you have the code on your machine, navigate to the root of the project and run the following command:\n\n```\nphp ./configure.php\n```\n\nThis will ask you a series of questions to configure the plugin. Once you’ve answered all the questions, the script will stub out a new plugin for you, and you can begin to build your amazing new extension for Filament.",
                "level": 4
              },
              {
                "title": "## #Upgrading existing plugins",
                "content": "Since every plugin varies greatly in its scope of use and functionality, there is no one size fits all approaches to upgrading existing plugins. However, one thing to note, that is consistent to all plugins is the deprecation of the PluginServiceProvider.\n\n`PluginServiceProvider`In your plugin service provider, you will need to change it to extend the PackageServiceProvider instead. You will also need to add a static $name property to the service provider. This property is used to register the plugin with Filament. Here is an example of what your service provider might look like:\n\n`$name````\nclass MyPluginServiceProvider extends PackageServiceProvider\n{\n    public static string $name = 'my-plugin';\n\n    public function configurePackage(Package $package): void\n    {\n        $package->name(static::$name);\n    }\n}\n```",
                "level": 3
              },
              {
                "title": "### #Helpful links",
                "content": "Please read this guide in its entirety before upgrading your plugin. It will help you understand the concepts and how to build your plugin.\n\n- Filament Asset Management\n- Panel Plugin Development\n- Icon Management\n- Colors Management\n- Style Customization\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Important Concepts",
              "The Plugin object",
              "Registering Assets",
              "Usage",
              "Upgrading existing plugins",
              "Helpful links"
            ],
            "code_examples_count": 4,
            "has_installation_info": false,
            "has_configuration": true,
            "has_examples": true
          }
        },
        "blade-components": {
          "metadata": {
            "title": "Blade Components",
            "url": "https://filamentphp.com/docs/3.x/support/blade-components",
            "section": "support",
            "word_count": 121,
            "character_count": 725
          },
          "content": {
            "full_text": "\n# Overview - Core Concepts - Filament\n\nCore Concepts  \n-  Blade Components\n\n# Overview\n\n## #Overview\n\nFilament packages consume a set of core Blade components that aim to provide a consistent and maintainable foundation for all interfaces. Some of these components are also available for use in your own applications and Filament plugins.\n\n## #Available UI components\n\n- Avatar\n- Badge\n- Breadcrumbs\n- Loading indicator\n- Section\n- Tabs\n\n### #UI components for actions\n\n- Button\n- Dropdown\n- Icon button\n- Link\n- Modal\n\n### #UI components for forms\n\n- Checkbox\n- Fieldset\n- Input\n- Input wrapper\n- Select\n\n### #UI components for tables\n\n- Pagination\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Overview - Core Concepts - Filament",
                "content": "Core Concepts  \n-  Blade Components",
                "level": 1
              },
              {
                "title": "# Overview",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Overview",
                "content": "Filament packages consume a set of core Blade components that aim to provide a consistent and maintainable foundation for all interfaces. Some of these components are also available for use in your own applications and Filament plugins.",
                "level": 3
              },
              {
                "title": "## #Available UI components",
                "content": "- Avatar\n- Badge\n- Breadcrumbs\n- Loading indicator\n- Section\n- Tabs",
                "level": 3
              },
              {
                "title": "### #UI components for actions",
                "content": "- Button\n- Dropdown\n- Icon button\n- Link\n- Modal",
                "level": 4
              },
              {
                "title": "### #UI components for forms",
                "content": "- Checkbox\n- Fieldset\n- Input\n- Input wrapper\n- Select",
                "level": 4
              },
              {
                "title": "### #UI components for tables",
                "content": "- Pagination\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 4
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Overview",
              "Available UI components",
              "UI components for actions",
              "UI components for forms",
              "UI components for tables"
            ],
            "code_examples_count": 0,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "stubs": {
          "metadata": {
            "title": "Stubs",
            "url": "https://filamentphp.com/docs/3.x/support/stubs",
            "section": "support",
            "word_count": 81,
            "character_count": 520
          },
          "content": {
            "full_text": "\n# Stubs - Core Concepts - Filament\n\nCore Concepts\n\n# Stubs\n\n## #Publishing the stubs\n\nIf you would like to customize the files that are generated by Filament, you can do so by publishing the “stubs” to your application. These are template files that you can modify to your own preferences.\n\nTo publish the stubs to the stubs/filament directory, run the following command:\n\n`stubs/filament````\nphp artisan vendor:publish --tag=filament-stubs\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Stubs - Core Concepts - Filament",
                "content": "Core Concepts",
                "level": 1
              },
              {
                "title": "# Stubs",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Publishing the stubs",
                "content": "If you would like to customize the files that are generated by Filament, you can do so by publishing the “stubs” to your application. These are template files that you can modify to your own preferences.\n\nTo publish the stubs to the stubs/filament directory, run the following command:\n\n`stubs/filament````\nphp artisan vendor:publish --tag=filament-stubs\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Publishing the stubs"
            ],
            "code_examples_count": 2,
            "has_installation_info": false,
            "has_configuration": false,
            "has_examples": false
          }
        },
        "help": {
          "metadata": {
            "title": "Help",
            "url": "https://filamentphp.com/docs/3.x/support/help",
            "section": "support",
            "word_count": 1069,
            "character_count": 8037
          },
          "content": {
            "full_text": "\n# Installation - Panels - Filament\n\nPanels\n\n# Installation\n\n## #Requirements\n\nFilament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+\n\n## #Installation\n\n> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.\n\n## #Using other Filament packages\n\nThe Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.\n\n## #Improving Filament panel performance\n\n### #Optimizing Filament for production\n\nTo optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```\n\n#### #Caching Filament components\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.\n\n### #Optimizing your Laravel app\n\nYou should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production\n\n### #Allowing users to access a panel\n\nBy default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.\n\n### #Using a production-ready storage disk\n\nFilament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```\n\n## #Publishing translations\n\nYou can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```\n\n## #Upgrading\n\n> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion\n\n",
            "sections": [
              {
                "title": "# Installation - Panels - Filament",
                "content": "Panels",
                "level": 1
              },
              {
                "title": "# Installation",
                "content": "",
                "level": 1
              },
              {
                "title": "## #Requirements",
                "content": "Filament requires the following to run:\n\n- PHP 8.1+\n- Laravel v10.0+\n- Livewire v3.0+",
                "level": 3
              },
              {
                "title": "## #Installation",
                "content": "> If you are upgrading from Filament v2, please review the upgrade guide.\n\nIf you are upgrading from Filament v2, please review the upgrade guide.\n\nInstall the Filament Panel Builder by running the following commands in your Laravel project directory:\n\n```\ncomposer require filament/filament:\"^3.3\" -W\n\nphp artisan filament:install --panels\n```\n\nThis will create and register a new Laravel service provider called app/Providers/Filament/AdminPanelProvider.php.\n\n`app/Providers/Filament/AdminPanelProvider.php`> If you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\nIf you get an error when accessing your panel, check that the service provider was registered in bootstrap/providers.php (Laravel 11 and above) or config/app.php (Laravel 10 and below). If not, you should manually add it.\n\n`bootstrap/providers.php``config/app.php`## #Create a user\n\nYou can create a new user account with the following command:\n\n```\nphp artisan make:filament-user\n```\n\nOpen /admin in your web browser, sign in, and start building your app!\n\n`/admin`Not sure where to start? Review the Getting Started guide to learn how to build a complete Filament admin panel.",
                "level": 3
              },
              {
                "title": "## #Using other Filament packages",
                "content": "The Filament Panel Builder pre-installs the Form Builder, Table Builder, Notifications, Actions, Infolists, and Widgets packages. No other installation steps are required to use these packages within a panel.",
                "level": 3
              },
              {
                "title": "## #Improving Filament panel performance",
                "content": "",
                "level": 3
              },
              {
                "title": "### #Optimizing Filament for production",
                "content": "To optimize Filament for production, you should run the following command in your deployment script:\n\n```\nphp artisan filament:optimize\n```\n\nThis command will cache the Filament components and additionally the Blade icons, which can significantly improve the performance of your Filament panels. This command is a shorthand for the commands php artisan filament:cache-components and php artisan icons:cache.\n\n`php artisan filament:cache-components``php artisan icons:cache`To clear the caches at once, you can run:\n\n```\nphp artisan filament:optimize-clear\n```",
                "level": 4
              },
              {
                "title": "#### #Caching Filament components",
                "content": "If you’re not using the filament:optimize command, you may wish to consider running php artisan filament:cache-components in your deployment script, especially if you have large numbers of components (resources, pages, widgets, relation managers, custom Livewire components, etc.). This will create cache files in the bootstrap/cache/filament directory of your application, which contain indexes for each type of component. This can significantly improve the performance of Filament in some apps, as it reduces the number of files that need to be scanned and auto-discovered for components.\n\n`filament:optimize``php artisan filament:cache-components``bootstrap/cache/filament`However, if you are actively developing your app locally, you should avoid using this command, as it will prevent any new components from being discovered until the cache is cleared or rebuilt.\n\nYou can clear the cache at any time without rebuilding it by running php artisan filament:clear-cached-components.\n\n`php artisan filament:clear-cached-components`#### #Caching Blade Icons\n\nIf you’re not using the filament:optimize command, you may wish to consider running php artisan icons:cache locally, and also in your deployment script. This is because Filament uses the Blade Icons package, which can be much more performant when cached.\n\n`filament:optimize``php artisan icons:cache`### #Enabling OPcache on your server\n\nFrom the Laravel Forge documentation:\n\n> Optimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nOptimizing the PHP OPcache for production will configure OPcache to store your compiled PHP code in memory to greatly improve performance.\n\nPlease use a search engine to find the relevant OPcache setup instructions for your environment.",
                "level": 5
              },
              {
                "title": "### #Optimizing your Laravel app",
                "content": "You should also consider optimizing your Laravel app for production by running php artisan optimize in your deployment script. This will cache the configuration files and routes.\n\n`php artisan optimize`## #Deploying to production",
                "level": 4
              },
              {
                "title": "### #Allowing users to access a panel",
                "content": "By default, all User models can access Filament locally. However, when deploying to production or running unit tests, you must update your App\\Models\\User.php to implement the FilamentUser contract — ensuring that only the correct users can access your panel:\n\n`User``App\\Models\\User.php``FilamentUser````\n<?php\n\nnamespace App\\Models;\n\nuse Filament\\Models\\Contracts\\FilamentUser;\nuse Filament\\Panel;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\n\nclass User extends Authenticatable implements FilamentUser\n{\n    // ...\n\n    public function canAccessPanel(Panel $panel): bool\n    {\n        return str_ends_with($this->email, '@yourdomain.com') && $this->hasVerifiedEmail();\n    }\n}\n```\n\n> If you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nIf you don’t complete these steps, a 403 Forbidden error will be returned when accessing the app in production.\n\nLearn more about users.",
                "level": 4
              },
              {
                "title": "### #Using a production-ready storage disk",
                "content": "Filament has a storage disk defined in the configuration, which by default is set to public. You can set the FILAMENT_FILESYSTEM_DISK environment variable to change this.\n\n`public``FILAMENT_FILESYSTEM_DISK`The public disk, while great for easy local development, is not suitable for production. It does not support file visibility, so features of Filament such as file uploads will create public files. In production, you need to use a production-ready disk such as s3 with a private access policy, to prevent unauthorized access to the uploaded files.\n\n`public``s3`## #Publishing configuration\n\nYou can publish the Filament package configuration (if needed) using the following command:\n\n```\nphp artisan vendor:publish --tag=filament-config\n```",
                "level": 4
              },
              {
                "title": "## #Publishing translations",
                "content": "You can publish the language files for translations (if needed) with the following command:\n\n```\nphp artisan vendor:publish --tag=filament-panels-translations\n```\n\nSince this package depends on other Filament packages, you can publish the language files for those packages with the following commands:\n\n```\nphp artisan vendor:publish --tag=filament-actions-translations\n\nphp artisan vendor:publish --tag=filament-forms-translations\n\nphp artisan vendor:publish --tag=filament-infolists-translations\n\nphp artisan vendor:publish --tag=filament-notifications-translations\n\nphp artisan vendor:publish --tag=filament-tables-translations\n\nphp artisan vendor:publish --tag=filament-translations\n```",
                "level": 3
              },
              {
                "title": "## #Upgrading",
                "content": "> Upgrading from Filament v2? Please review the upgrade guide.\n\nUpgrading from Filament v2? Please review the upgrade guide.\n\nFilament automatically upgrades to the latest non-breaking version when you run composer update. After any updates, all Laravel caches need to be cleared, and frontend assets need to be republished. You can do this all at once using the filament:upgrade command, which should have been added to your composer.json file when you ran filament:install the first time:\n\n`composer update``filament:upgrade``composer.json``filament:install````\n\"post-autoload-dump\": [\n    // ...\n    \"@php artisan filament:upgrade\"\n],\n```\n\nPlease note that filament:upgrade does not actually handle the update process, as Composer does that already. If you’re upgrading manually without a post-autoload-dump hook, you can run the command yourself:\n\n`filament:upgrade``post-autoload-dump````\ncomposer update\n\nphp artisan filament:upgrade\n```\n\nStill need help? Join our Discord community or open a GitHub discussion",
                "level": 3
              }
            ]
          },
          "ai_summary": {
            "main_topics": [
              "Requirements",
              "Installation",
              "Using other Filament packages",
              "Improving Filament panel performance",
              "Optimizing Filament for production",
              "Optimizing your Laravel app",
              "Allowing users to access a panel",
              "Using a production-ready storage disk",
              "Publishing translations",
              "Upgrading"
            ],
            "code_examples_count": 20,
            "has_installation_info": true,
            "has_configuration": true,
            "has_examples": false
          }
        }
      }
    }
  }
}